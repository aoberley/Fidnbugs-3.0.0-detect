diff --git a/.reviewboardrc b/.reviewboardrc
deleted file mode 100644
index 0d29469f0cf91dcc3b70c92349de336d9e1bb33a..0000000000000000000000000000000000000000
--- a/.reviewboardrc
+++ /dev/null
@@ -1,4 +0,0 @@
-REVIEWBOARD_URL = "http://reviewboard.server.com"
-REPOSITORY = "Findbugs-3.0.0-detect "
-BRANCH = "master"
-LAND_DEST_BRANCH = "master"
diff --git a/AppendingToAnObjectOutputStream.java b/AppendingToAnObjectOutputStream.java
index b932574ba1dbe4a3fc6d929e8b98228976ec8d19..44ad42ac967668ed04dfce819c6c869157ef59a9 100644
--- a/AppendingToAnObjectOutputStream.java
+++ b/AppendingToAnObjectOutputStream.java
@@ -19,12 +19,15 @@
 
 package edu.umd.cs.findbugs.detect;
 
+import java.util.Collections;
+
 import org.apache.bcel.classfile.Method;
 
 import edu.umd.cs.findbugs.BugInstance;
 import edu.umd.cs.findbugs.BugReporter;
 import edu.umd.cs.findbugs.OpcodeStack;
 import edu.umd.cs.findbugs.Priorities;
+import edu.umd.cs.findbugs.ba.ClassContext;
 import edu.umd.cs.findbugs.bcel.OpcodeStackDetector;
 
 public class AppendingToAnObjectOutputStream extends OpcodeStackDetector {
@@ -35,6 +38,13 @@ public class AppendingToAnObjectOutputStream extends OpcodeStackDetector {
         this.bugReporter = bugReporter;
     }
 
+    @Override
+    public void visitClassContext(ClassContext classContext) {
+        if(hasInterestingClass(classContext.getJavaClass().getConstantPool(), Collections.singleton("java/io/ObjectOutputStream"))) {
+            super.visitClassContext(classContext);
+        }
+    }
+
     boolean sawOpenInAppendMode;
 
     @Override
@@ -57,27 +67,27 @@ public class AppendingToAnObjectOutputStream extends OpcodeStackDetector {
         String calledMethodName = getNameConstantOperand();
         String calledMethodSig = getSigConstantOperand();
         if (!sawOpenInAppendMode) {
-            if (calledClassName.equals("java/io/ObjectOutputStream") && calledMethodName.equals("<init>")
-                    && calledMethodSig.equals("(Ljava/io/OutputStream;)V")
+            if ("java/io/ObjectOutputStream".equals(calledClassName) && "<init>".equals(calledMethodName)
+                    && "(Ljava/io/OutputStream;)V".equals(calledMethodSig)
                     && stack.getStackItem(0).getSpecialKind() == OpcodeStack.Item.FILE_OPENED_IN_APPEND_MODE) {
                 bugReporter.reportBug(new BugInstance(this, "IO_APPENDING_TO_OBJECT_OUTPUT_STREAM", Priorities.HIGH_PRIORITY)
                 .addClassAndMethod(this).addSourceLine(this));
             }
             return;
         }
-        if (calledClassName.equals("java/io/FileOutputStream") && calledMethodName.equals("<init>")
-                && (calledMethodSig.equals("(Ljava/io/File;Z)V") || calledMethodSig.equals("(Ljava/lang/String;Z)V"))) {
+        if ("java/io/FileOutputStream".equals(calledClassName) && "<init>".equals(calledMethodName)
+                && ("(Ljava/io/File;Z)V".equals(calledMethodSig) || "(Ljava/lang/String;Z)V".equals(calledMethodSig))) {
             OpcodeStack.Item item = stack.getStackItem(0);
             Object value = item.getConstant();
             sawOpenInAppendMode = value instanceof Integer && ((Integer) value).intValue() == 1;
         } else if (!sawOpenInAppendMode) {
             return;
-        } else if (calledClassName.equals("java/io/BufferedOutputStream") && calledMethodName.equals("<init>")
-                && calledMethodSig.equals("(Ljava/io/OutputStream;)V")) {
+        } else if ("java/io/BufferedOutputStream".equals(calledClassName) && "<init>".equals(calledMethodName)
+                && "(Ljava/io/OutputStream;)V".equals(calledMethodSig)) {
             // do nothing
 
-        } else if (calledClassName.equals("java/io/ObjectOutputStream") && calledMethodName.equals("<init>")
-                && calledMethodSig.equals("(Ljava/io/OutputStream;)V")) {
+        } else if ("java/io/ObjectOutputStream".equals(calledClassName) && "<init>".equals(calledMethodName)
+                && "(Ljava/io/OutputStream;)V".equals(calledMethodSig)) {
             bugReporter.reportBug(new BugInstance(this, "IO_APPENDING_TO_OBJECT_OUTPUT_STREAM", Priorities.HIGH_PRIORITY)
             .addClassAndMethod(this).addSourceLine(this));
             sawOpenInAppendMode = false;
diff --git a/AtomicityProblem.java b/AtomicityProblem.java
index a4978c9b20ffbb203fce0469f69923fdf47e73e1..5ac8915fec3b26e7b2930e6ca11e3f392dac39e9 100644
--- a/AtomicityProblem.java
+++ b/AtomicityProblem.java
@@ -19,11 +19,14 @@
 
 package edu.umd.cs.findbugs.detect;
 
+import java.util.Collections;
+
 import org.apache.bcel.classfile.Code;
 
 import edu.umd.cs.findbugs.BugInstance;
 import edu.umd.cs.findbugs.BugReporter;
 import edu.umd.cs.findbugs.OpcodeStack;
+import edu.umd.cs.findbugs.ba.ClassContext;
 import edu.umd.cs.findbugs.ba.XClass;
 import edu.umd.cs.findbugs.ba.XMethod;
 import edu.umd.cs.findbugs.bcel.OpcodeStackDetector;
@@ -50,6 +53,13 @@ public class AtomicityProblem extends OpcodeStackDetector {
     }
 
     @Override
+    public void visitClassContext(ClassContext classContext) {
+        if(hasInterestingClass(classContext.getJavaClass().getConstantPool(), Collections.singleton("java/util/concurrent/ConcurrentHashMap"))) {
+            super.visitClassContext(classContext);
+        }
+    }
+
+    @Override
     public void visit(Code obj) {
         if (DEBUG) {
             System.out.println("Checking " + obj);
@@ -77,8 +87,8 @@ public class AtomicityProblem extends OpcodeStackDetector {
                 System.out.println("Stack top: " + top);
             }
             XMethod m = top.getReturnValueOf();
-            if (m != null && m.getClassName().equals("java.util.concurrent.ConcurrentHashMap")
-                    && m.getName().equals("containsKey")) {
+            if (m != null && "java.util.concurrent.ConcurrentHashMap".equals(m.getClassName())
+                    && "containsKey".equals(m.getName())) {
                 lastQuestionableCheckTarget = getBranchTarget();
                 if (seen == IFEQ) {
                     priority = LOW_PRIORITY;
@@ -98,7 +108,7 @@ public class AtomicityProblem extends OpcodeStackDetector {
             if (DEBUG) {
                 System.out.println("Found null check");
             }
-            if (m != null && m.getClassName().equals("java.util.concurrent.ConcurrentHashMap") && m.getName().equals("get")) {
+            if (m != null && "java.util.concurrent.ConcurrentHashMap".equals(m.getClassName()) && "get".equals(m.getName())) {
                 lastQuestionableCheckTarget = getBranchTarget();
                 if (seen == IFNULL) {
                     priority = LOW_PRIORITY;
@@ -110,10 +120,10 @@ public class AtomicityProblem extends OpcodeStackDetector {
         }
         case INVOKEVIRTUAL:
         case INVOKEINTERFACE: {
-            if (getDottedClassConstantOperand().equals("java.util.concurrent.ConcurrentHashMap")) {
+            if ("java.util.concurrent.ConcurrentHashMap".equals(getDottedClassConstantOperand())) {
                 String methodName = getNameConstantOperand();
                 XClass xClass = getXClassOperand();
-                if (xClass != null && methodName.equals("put")) {
+                if (xClass != null && "put".equals(methodName)) {
                     if ((getPC() < lastQuestionableCheckTarget) && (lastQuestionableCheckTarget != -1)) {
                         bugReporter.reportBug(new BugInstance(this, "AT_OPERATION_SEQUENCE_ON_CONCURRENT_ABSTRACTION", priority)
                         .addClassAndMethod(this).addType(xClass.getClassDescriptor()).addCalledMethod(this)
diff --git a/BadAppletConstructor.java b/BadAppletConstructor.java
index 4efb3af3fab085dff52fd49f0d374a7569c1781a..d5edfe597080b743b32678471d3908a45bc89214 100644
--- a/BadAppletConstructor.java
+++ b/BadAppletConstructor.java
@@ -66,7 +66,7 @@ public class BadAppletConstructor extends BytecodeScanningDetector {
 
     @Override
     public void visit(Method obj) {
-        inConstructor = obj.getName().equals("<init>");
+        inConstructor = "<init>".equals(obj.getName());
     }
 
     @Override
@@ -81,9 +81,9 @@ public class BadAppletConstructor extends BytecodeScanningDetector {
         if (seen == INVOKEVIRTUAL) {
             String method = getNameConstantOperand();
             String signature = getSigConstantOperand();
-            if (((method.equals("getDocumentBase") || method.equals("getCodeBase")) && signature.equals("()Ljava/net/URL;"))
-                    || (method.equals("getAppletContext") && signature.equals("()Ljava/applet/AppletContext;"))
-                    || (method.equals("getParameter") && signature.equals("(Ljava/lang/String;)Ljava/lang/String;"))) {
+            if ((("getDocumentBase".equals(method) || "getCodeBase".equals(method)) && "()Ljava/net/URL;".equals(signature))
+                    || ("getAppletContext".equals(method) && "()Ljava/applet/AppletContext;".equals(signature))
+                    || ("getParameter".equals(method) && "(Ljava/lang/String;)Ljava/lang/String;".equals(signature))) {
                 bugReporter.reportBug(new BugInstance(this, "BAC_BAD_APPLET_CONSTRUCTOR", NORMAL_PRIORITY)
                 .addClassAndMethod(this).addSourceLine(this));
             }
diff --git a/BadResultSetAccess.java b/BadResultSetAccess.java
index bf27ed2ecc0f53cbd1b2c548ecfd7f7c28e11640..2244690abfefa920649fc86ea8f75ea8b4f2bd4e 100644
--- a/BadResultSetAccess.java
+++ b/BadResultSetAccess.java
@@ -20,12 +20,14 @@
 
 package edu.umd.cs.findbugs.detect;
 
+import java.util.Collections;
 import java.util.HashSet;
 import java.util.Set;
 
 import edu.umd.cs.findbugs.BugInstance;
 import edu.umd.cs.findbugs.BugReporter;
 import edu.umd.cs.findbugs.OpcodeStack;
+import edu.umd.cs.findbugs.ba.ClassContext;
 import edu.umd.cs.findbugs.bcel.OpcodeStackDetector;
 import edu.umd.cs.findbugs.internalAnnotations.StaticConstant;
 import edu.umd.cs.findbugs.visitclass.PreorderVisitor;
@@ -70,15 +72,22 @@ public class BadResultSetAccess extends OpcodeStackDetector {
     }
 
     @Override
+    public void visitClassContext(ClassContext classContext) {
+        if(hasInterestingClass(classContext.getJavaClass().getConstantPool(), Collections.singleton("java/sql/ResultSet"))) {
+            super.visitClassContext(classContext);
+        }
+    }
+
+    @Override
     public void sawOpcode(int seen) {
 
         if (seen == INVOKEINTERFACE) {
             String methodName = getNameConstantOperand();
             String clsConstant = getClassConstantOperand();
-            if ((clsConstant.equals("java/sql/ResultSet") && ((methodName.startsWith("get") && dbFieldTypesSet
+            if (("java/sql/ResultSet".equals(clsConstant) && ((methodName.startsWith("get") && dbFieldTypesSet
                     .contains(methodName.substring(3))) || (methodName.startsWith("update") && dbFieldTypesSet
                             .contains(methodName.substring(6)))))
-                            || ((clsConstant.equals("java/sql/PreparedStatement") && ((methodName.startsWith("set") && dbFieldTypesSet
+                            || (("java/sql/PreparedStatement".equals(clsConstant) && ((methodName.startsWith("set") && dbFieldTypesSet
                                     .contains(methodName.substring(3))))))) {
                 String signature = getSigConstantOperand();
                 int numParms = PreorderVisitor.getNumberArguments(signature);
@@ -87,7 +96,7 @@ public class BadResultSetAccess extends OpcodeStackDetector {
 
                     if ("I".equals(item.getSignature()) && item.couldBeZero()) {
                         bugReporter.reportBug(new BugInstance(this,
-                                clsConstant.equals("java/sql/PreparedStatement") ? "SQL_BAD_PREPARED_STATEMENT_ACCESS"
+                                "java/sql/PreparedStatement".equals(clsConstant) ? "SQL_BAD_PREPARED_STATEMENT_ACCESS"
                                         : "SQL_BAD_RESULTSET_ACCESS", item.mustBeZero() ? HIGH_PRIORITY : NORMAL_PRIORITY)
                         .addClassAndMethod(this).addSourceLine(this));
                     }
diff --git a/BadSyntaxForRegularExpression.java b/BadSyntaxForRegularExpression.java
index 2b92ea6989cfa062d5c3a48fa0e78c0b529112cf..40bba4fb8c5ce21cf53593b885115f370c1328eb 100644
--- a/BadSyntaxForRegularExpression.java
+++ b/BadSyntaxForRegularExpression.java
@@ -50,8 +50,8 @@ public class BadSyntaxForRegularExpression extends OpcodeStackDetector {
             return;
         }
         String regex = (String) value;
-        boolean dotIsUsed = regex.equals(".");
-        if (!dotIsUsed && !regex.equals("|")) {
+        boolean dotIsUsed = ".".equals(regex);
+        if (!dotIsUsed && !"|".equals(regex)) {
             return;
         }
         int priority = HIGH_PRIORITY;
@@ -61,8 +61,8 @@ public class BadSyntaxForRegularExpression extends OpcodeStackDetector {
             Object topValue = top.getConstant();
             if (topValue instanceof String) {
                 String replacementString = (String) topValue;
-                if (replacementString.toLowerCase().equals("x") || replacementString.equals("-") || replacementString.equals("*")
-                        || replacementString.equals(" ") || replacementString.equals("\\*")) {
+                if ("x".equals(replacementString.toLowerCase()) || "-".equals(replacementString) || "*".equals(replacementString)
+                        || " ".equals(replacementString) || "\\*".equals(replacementString)) {
                     return;
                 }
                 if (replacementString.length() == 1 && getMethodName().toLowerCase().indexOf("pass") >= 0) {
@@ -129,29 +129,29 @@ public class BadSyntaxForRegularExpression extends OpcodeStackDetector {
 
     @Override
     public void sawOpcode(int seen) {
-        if (seen == INVOKESTATIC && getClassConstantOperand().equals("java/util/regex/Pattern")
-                && getNameConstantOperand().equals("compile") && getSigConstantOperand().startsWith("(Ljava/lang/String;I)")) {
+        if (seen == INVOKESTATIC && "java/util/regex/Pattern".equals(getClassConstantOperand())
+                && "compile".equals(getNameConstantOperand()) && getSigConstantOperand().startsWith("(Ljava/lang/String;I)")) {
             sawRegExPattern(1, getIntValue(0, 0));
-        } else if (seen == INVOKESTATIC && getClassConstantOperand().equals("java/util/regex/Pattern")
-                && getNameConstantOperand().equals("compile") && getSigConstantOperand().startsWith("(Ljava/lang/String;)")) {
+        } else if (seen == INVOKESTATIC && "java/util/regex/Pattern".equals(getClassConstantOperand())
+                && "compile".equals(getNameConstantOperand()) && getSigConstantOperand().startsWith("(Ljava/lang/String;)")) {
             sawRegExPattern(0);
-        } else if (seen == INVOKESTATIC && getClassConstantOperand().equals("java/util/regex/Pattern")
-                && getNameConstantOperand().equals("matches")) {
+        } else if (seen == INVOKESTATIC && "java/util/regex/Pattern".equals(getClassConstantOperand())
+                && "matches".equals(getNameConstantOperand())) {
             sawRegExPattern(1);
-        } else if (seen == INVOKEVIRTUAL && getClassConstantOperand().equals("java/lang/String")
-                && getNameConstantOperand().equals("replaceAll")) {
+        } else if (seen == INVOKEVIRTUAL && "java/lang/String".equals(getClassConstantOperand())
+                && "replaceAll".equals(getNameConstantOperand())) {
             sawRegExPattern(1);
             singleDotPatternWouldBeSilly(1, true);
-        } else if (seen == INVOKEVIRTUAL && getClassConstantOperand().equals("java/lang/String")
-                && getNameConstantOperand().equals("replaceFirst")) {
+        } else if (seen == INVOKEVIRTUAL && "java/lang/String".equals(getClassConstantOperand())
+                && "replaceFirst".equals(getNameConstantOperand())) {
             sawRegExPattern(1);
             singleDotPatternWouldBeSilly(1, false);
-        } else if (seen == INVOKEVIRTUAL && getClassConstantOperand().equals("java/lang/String")
-                && getNameConstantOperand().equals("matches")) {
+        } else if (seen == INVOKEVIRTUAL && "java/lang/String".equals(getClassConstantOperand())
+                && "matches".equals(getNameConstantOperand())) {
             sawRegExPattern(0);
             singleDotPatternWouldBeSilly(0, false);
-        } else if (seen == INVOKEVIRTUAL && getClassConstantOperand().equals("java/lang/String")
-                && getNameConstantOperand().equals("split")) {
+        } else if (seen == INVOKEVIRTUAL && "java/lang/String".equals(getClassConstantOperand())
+                && "split".equals(getNameConstantOperand())) {
             sawRegExPattern(0);
             singleDotPatternWouldBeSilly(0, false);
         }
diff --git a/BadUseOfReturnValue.java b/BadUseOfReturnValue.java
index 6699c76d51a0ea54e30c3f61fee494251debaf23..8581cce7f0c8a73a589e70c5140376f768c8f372 100644
--- a/BadUseOfReturnValue.java
+++ b/BadUseOfReturnValue.java
@@ -48,9 +48,9 @@ public class BadUseOfReturnValue extends BytecodeScanningDetector {
 
     @Override
     public void sawOpcode(int seen) {
-        if (seen == INVOKEVIRTUAL && getNameConstantOperand().equals("indexOf")
-                && getClassConstantOperand().equals("java/lang/String")
-                && getSigConstantOperand().equals("(Ljava/lang/String;)I")) {
+        if (seen == INVOKEVIRTUAL && "indexOf".equals(getNameConstantOperand())
+                && "java/lang/String".equals(getClassConstantOperand())
+                && "(Ljava/lang/String;)I".equals(getSigConstantOperand())) {
             stringIndexOfOnTOS = true;
         } else if (stringIndexOfOnTOS) {
             if (seen == IFLE || seen == IFGT) {
@@ -60,9 +60,9 @@ public class BadUseOfReturnValue extends BytecodeScanningDetector {
             stringIndexOfOnTOS = false;
         }
 
-        if (seen == INVOKEVIRTUAL && getNameConstantOperand().equals("readLine")
-                && getSigConstantOperand().equals("()Ljava/lang/String;") && getClassConstantOperand().startsWith("java/io")
-                && !getClassConstantOperand().equals("java/io/LineNumberReader")) {
+        if (seen == INVOKEVIRTUAL && "readLine".equals(getNameConstantOperand())
+                && "()Ljava/lang/String;".equals(getSigConstantOperand()) && getClassConstantOperand().startsWith("java/io")
+                && !"java/io/LineNumberReader".equals(getClassConstantOperand())) {
             readLineOnTOS = true;
         } else if (readLineOnTOS) {
             if (seen == IFNULL || seen == IFNONNULL) {
diff --git a/BadlyOverriddenAdapter.java b/BadlyOverriddenAdapter.java
index 78f35be7bbdd7cb91b731522ab733623ee37c0c5..afaa7f6d82c32a3df5eec894a34200ec4ca55e6b 100644
--- a/BadlyOverriddenAdapter.java
+++ b/BadlyOverriddenAdapter.java
@@ -58,9 +58,8 @@ public class BadlyOverriddenAdapter extends BytecodeScanningDetector {
             String className = superClass.getClassName();
 
             // A more generic way to add Adapters would be nice here
-            isAdapter = ((className.endsWith("Adapter")) && (packageName.equals("java.awt.event") || packageName
-                    .equals("javax.swing.event")))
-                    || ((className.equals("DefaultHandler") && (packageName.equals("org.xml.sax.helpers"))));
+            isAdapter = ((className.endsWith("Adapter")) && ("java.awt.event".equals(packageName) || "javax.swing.event".equals(packageName)))
+                    || (("DefaultHandler".equals(className) && ("org.xml.sax.helpers".equals(packageName))));
             if (isAdapter) {
                 Method[] methods = superClass.getMethods();
                 for (Method method1 : methods) {
@@ -86,7 +85,7 @@ public class BadlyOverriddenAdapter extends BytecodeScanningDetector {
         if (isAdapter) {
             String methodName = obj.getName();
             String signature = methodMap.get(methodName);
-            if (!methodName.equals("<init>") && signature != null) {
+            if (!"<init>".equals(methodName) && signature != null) {
                 if (!signature.equals(obj.getSignature())) {
                     if (!badOverrideMap.keySet().contains(methodName)) {
                         badOverrideMap.put(methodName, new BugInstance(this, "BOA_BADLY_OVERRIDDEN_ADAPTER", NORMAL_PRIORITY)
diff --git a/BuildCheckReturnAnnotationDatabase.java b/BuildCheckReturnAnnotationDatabase.java
index 7222d8c140bea796d386dd778185ec16465b4a89..826b014c51bbd7ec32e33a617fa3f6583718da7a 100644
--- a/BuildCheckReturnAnnotationDatabase.java
+++ b/BuildCheckReturnAnnotationDatabase.java
@@ -102,11 +102,11 @@ public class BuildCheckReturnAnnotationDatabase extends AnnotationVisitor {
             if (v instanceof EnumElementValue) {
                 EnumElementValue when = (EnumElementValue) v;
                 String w = simpleClassName(when.getEnumValueString());
-                if (w.equals("NEVER") || w.equals("UNKNOWN")) {
+                if ("NEVER".equals(w) || "UNKNOWN".equals(w)) {
                     n = CheckReturnValueAnnotation.CHECK_RETURN_VALUE_IGNORE;
-                } else if (w.equals("MAYBE")) {
+                } else if ("MAYBE".equals(w)) {
                     n = CheckReturnValueAnnotation.CHECK_RETURN_VALUE_MEDIUM_BAD_PRACTICE;
-                } else if (w.equals("ALWAYS")) {
+                } else if ("ALWAYS".equals(w)) {
                     n = CheckReturnValueAnnotation.CHECK_RETURN_VALUE_HIGH;
                 } else {
                     return;
@@ -117,7 +117,7 @@ public class BuildCheckReturnAnnotationDatabase extends AnnotationVisitor {
 
         } else if (annotationClassName.equals(edu.umd.cs.findbugs.annotations.CheckReturnValue.class.getName())) {
             n = CheckReturnValueAnnotation.parse(getAnnotationParameterAsString(map, "priority"));
-        } else if (annotationClassSimpleName.equals("CheckReturnValue")) {
+        } else if ("CheckReturnValue".equals(annotationClassSimpleName)) {
             n = CheckReturnValueAnnotation.CHECK_RETURN_VALUE_MEDIUM;
         } else {
             return;
@@ -136,7 +136,7 @@ public class BuildCheckReturnAnnotationDatabase extends AnnotationVisitor {
     }
 
     private void handleClassElementValue(ClassElementValue value, Map<String, ElementValue> map, Target annotationTarget) {
-        if (simpleClassName(value.getClassString()).equals("CheckReturnValue")) {
+        if ("CheckReturnValue".equals(simpleClassName(value.getClassString()))) {
             CheckReturnValueAnnotation n = CheckReturnValueAnnotation.parse(getAnnotationParameterAsString(map, "priority"));
             if (n != null) {
                 AnalysisContext.currentAnalysisContext().getCheckReturnAnnotationDatabase()
diff --git a/BuildObligationPolicyDatabase.java b/BuildObligationPolicyDatabase.java
index eb62ec7e085f8d787e63813e0b4c7901c5f0715b..3a840ec4dc9ffa4db124aa53b0ef3980e63ddc64 100644
--- a/BuildObligationPolicyDatabase.java
+++ b/BuildObligationPolicyDatabase.java
@@ -243,7 +243,7 @@ public class BuildObligationPolicyDatabase implements Detector2, NonReportingDet
                      * obligation. If strict checking is performed, // weak
                      * entries are ignored.
                      */
-                    if (xmethod.getName().equals("<init>") || xmethod.isStatic()
+                    if ("<init>".equals(xmethod.getName()) || xmethod.isStatic()
                             || xmethod.getName().toLowerCase().indexOf("close") >= 0
                             || xmethod.getSignature().toLowerCase().indexOf("Closeable") >= 0) {
                         addParameterDeletesObligationDatabaseEntry(xmethod, obligationType,
@@ -388,7 +388,7 @@ public class BuildObligationPolicyDatabase implements Detector2, NonReportingDet
 
         // See what type of obligation is being created.
         Obligation createdObligation = null;
-        if (xmethod.getName().equals("<init>")) {
+        if ("<init>".equals(xmethod.getName())) {
             // Constructor - obligation type is the type of object being created
             // (or some supertype)
             createdObligation = database.getFactory().getObligationByType(xmethod.getClassDescriptor());
diff --git a/BuildStringPassthruGraph.java b/BuildStringPassthruGraph.java
new file mode 100644
index 0000000000000000000000000000000000000000..5c67f380517b2bb65d609378feb86fc191700f00
--- /dev/null
+++ b/BuildStringPassthruGraph.java
@@ -0,0 +1,293 @@
+/*
+ * FindBugs - Find Bugs in Java programs
+ * Copyright (C) 2003-2008 University of Maryland
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+package edu.umd.cs.findbugs.detect;
+
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Queue;
+import java.util.Set;
+
+import org.apache.bcel.classfile.Code;
+import org.apache.bcel.classfile.Method;
+
+import edu.umd.cs.findbugs.BugReporter;
+import edu.umd.cs.findbugs.NonReportingDetector;
+import edu.umd.cs.findbugs.OpcodeStack.Item;
+import edu.umd.cs.findbugs.bcel.OpcodeStackDetector;
+import edu.umd.cs.findbugs.classfile.Global;
+import edu.umd.cs.findbugs.classfile.MethodDescriptor;
+
+/**
+ * Builds the database of string parameters passed from method to method unchanged.
+ * @author Tagir Valeev
+ */
+public class BuildStringPassthruGraph extends OpcodeStackDetector implements NonReportingDetector {
+
+    public static class MethodParameter {
+        final MethodDescriptor md;
+
+        final int parameterNumber;
+
+        public MethodParameter(MethodDescriptor md, int parameterNumber) {
+            super();
+            this.md = md;
+            this.parameterNumber = parameterNumber;
+        }
+
+        public MethodDescriptor getMethodDescriptor() {
+            return md;
+        }
+
+        public int getParameterNumber() {
+            return parameterNumber;
+        }
+
+        @Override
+        public String toString() {
+            return this.md + "[" + this.parameterNumber + "]";
+        }
+
+        @Override
+        public int hashCode() {
+            final int prime = 31;
+            int result = 1;
+            result = prime * result + ((md == null) ? 0 : md.hashCode());
+            result = prime * result + parameterNumber;
+            return result;
+        }
+
+        @Override
+        public boolean equals(Object obj) {
+            if (this == obj) {
+                return true;
+            }
+            if (obj == null) {
+                return false;
+            }
+            if (getClass() != obj.getClass()) {
+                return false;
+            }
+            MethodParameter other = (MethodParameter) obj;
+            if (md == null) {
+                if (other.md != null) {
+                    return false;
+                }
+            } else if (!md.equals(other.md)) {
+                return false;
+            }
+            if (parameterNumber != other.parameterNumber) {
+                return false;
+            }
+            return true;
+        }
+    }
+
+    public static class StringPassthruDatabase {
+        private static final List<MethodDescriptor> FILENAME_STRING_METHODS = Arrays.asList(
+                new MethodDescriptor("java/io/File", "<init>", "(Ljava/lang/String;)V"),
+                new MethodDescriptor("java/io/File", "<init>", "(Ljava/lang/String;Ljava/lang/String;)V"),
+                new MethodDescriptor("java/io/RandomAccessFile", "<init>", "(Ljava/lang/String;Ljava/lang/String;)V"),
+                new MethodDescriptor("java/nio/file/Paths", "get", "(Ljava/lang/String;[Ljava/lang/String;)Ljava/nio/file/Path;", true),
+                new MethodDescriptor("java/io/FileReader", "<init>", "(Ljava/lang/String;)V"),
+                new MethodDescriptor("java/io/FileWriter", "<init>", "(Ljava/lang/String;)V"),
+                new MethodDescriptor("java/io/FileWriter", "<init>", "(Ljava/lang/String;Z)V"),
+                new MethodDescriptor("java/io/FileInputStream", "<init>", "(Ljava/lang/String;)V"),
+                new MethodDescriptor("java/io/FileOutputStream", "<init>", "(Ljava/lang/String;)V"),
+                new MethodDescriptor("java/io/FileOutputStream", "<init>", "(Ljava/lang/String;Z)V"),
+                new MethodDescriptor("java/util/Formatter", "<init>", "(Ljava/lang/String;)V"),
+                new MethodDescriptor("java/util/Formatter", "<init>", "(Ljava/lang/String;Ljava/lang/String;)V"),
+                new MethodDescriptor("java/util/Formatter", "<init>", "(Ljava/lang/String;Ljava/lang/String;Ljava/util/Locale;)V"),
+                new MethodDescriptor("java/util/jar/JarFile", "<init>", "(Ljava/lang/String;)V"),
+                new MethodDescriptor("java/util/jar/JarFile", "<init>", "(Ljava/lang/String;Z)V"),
+                new MethodDescriptor("java/util/zip/ZipFile", "<init>", "(Ljava/lang/String;)V"),
+                new MethodDescriptor("java/util/zip/ZipFile", "<init>", "(Ljava/lang/String;Ljava/nio/charset/Charset;)V"),
+                new MethodDescriptor("java/io/PrintStream", "<init>", "(Ljava/lang/String;)V"),
+                new MethodDescriptor("java/io/PrintStream", "<init>", "(Ljava/lang/String;Ljava/lang/String;)V"),
+                new MethodDescriptor("java/io/PrintWriter", "<init>", "(Ljava/lang/String;)V"),
+                new MethodDescriptor("java/io/PrintWriter", "<init>", "(Ljava/lang/String;Ljava/lang/String;)V")
+                );
+
+        private final Map<MethodParameter, Set<MethodParameter>> graph = new HashMap<>();
+
+        /**
+         * Adds edge to the string passthru graph
+         * @param in callee
+         * @param out caller
+         */
+        void addEdge(MethodParameter in, MethodParameter out) {
+            Set<MethodParameter> outs = graph.get(in);
+            if (outs == null) {
+                outs = new HashSet<>();
+                graph.put(in, outs);
+            }
+            outs.add(out);
+        }
+
+        Set<MethodParameter> findLinked(Set<MethodParameter> inputs) {
+            Set<MethodParameter> result = new HashSet<>(inputs);
+            Queue<MethodParameter> toCheck = new ArrayDeque<>(inputs);
+            while (!toCheck.isEmpty()) {
+                MethodParameter in = toCheck.poll();
+                Set<MethodParameter> outs = graph.get(in);
+                if (outs != null) {
+                    for (MethodParameter out : outs) {
+                        if (!result.contains(out)) {
+                            result.add(out);
+                            toCheck.add(out);
+                        }
+                    }
+                }
+            }
+            return result;
+        }
+
+        /**
+         * Returns methods which call directly or indirectly methods from inputs
+         * passing the parameter unchanged
+         *
+         * @param inputs
+         *            input methods with parameter
+         * @return Map where keys are methods and values are parameter indexes which can be passed to requested methods unchanged
+         */
+        public Map<MethodDescriptor, int[]> findLinkedMethods(Set<MethodParameter> inputs) {
+            Map<MethodDescriptor, int[]> result = new HashMap<>();
+            for (MethodParameter found : findLinked(inputs)) {
+                int[] params = result.get(found.getMethodDescriptor());
+                if(params == null) {
+                    params = new int[] {found.getParameterNumber()};
+                    result.put(found.getMethodDescriptor(), params);
+                } else {
+                    int[] newParams = new int[params.length+1];
+                    System.arraycopy(params, 0, newParams, 0, params.length);
+                    newParams[params.length] = found.getParameterNumber();
+                    result.put(found.getMethodDescriptor(), newParams);
+                }
+            }
+            return result;
+        }
+
+        /**
+         * Returns methods which parameter is the file name
+         * @return Map where keys are methods and values are parameter indexes which are used as file names
+         */
+        public Map<MethodDescriptor, int[]> getFileNameStringMethods() {
+            Set<MethodParameter> fileNameStringMethods = new HashSet<>();
+            for(MethodDescriptor md : FILENAME_STRING_METHODS) {
+                fileNameStringMethods.add(new MethodParameter(md, 0));
+            }
+            return findLinkedMethods(fileNameStringMethods);
+        }
+    }
+
+    private final StringPassthruDatabase cache = new StringPassthruDatabase();
+
+    private int nArgs;
+
+    private int shift;
+
+    private boolean[] argEnabled;
+
+    private List<MethodParameter>[] passedParameters;
+
+    public BuildStringPassthruGraph(BugReporter bugReporter) {
+        Global.getAnalysisCache().eagerlyPutDatabase(StringPassthruDatabase.class, cache);
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public void visitMethod(Method obj) {
+        argEnabled = null;
+        org.apache.bcel.generic.Type[] argumentTypes = obj.getArgumentTypes();
+        if(argumentTypes.length == 0) {
+            return;
+        }
+        nArgs = argumentTypes.length;
+        for(int i=0; i<nArgs; i++) {
+            if(argumentTypes[i].getSignature().equals("Ljava/lang/String;")) {
+                if(argEnabled == null) {
+                    argEnabled = new boolean[nArgs];
+                }
+                argEnabled[i] = true;
+            }
+        }
+        if(argEnabled != null) {
+            shift = obj.isStatic() ? 0 : -1;
+            passedParameters = new List[nArgs];
+        }
+        super.visitMethod(obj);
+    }
+
+    @Override
+    public boolean shouldVisitCode(Code obj) {
+        return argEnabled != null;
+    }
+
+    @Override
+    public void visitAfter(Code obj) {
+        super.visitAfter(obj);
+        for (int i = 0; i < nArgs; i++) {
+            List<MethodParameter> list = passedParameters[i];
+            if (list != null) {
+                MethodParameter cur = new MethodParameter(getMethodDescriptor(), i);
+                for (MethodParameter mp : list) {
+                    cache.addEdge(mp, cur);
+                }
+            }
+        }
+    }
+
+    @Override
+    public void sawOpcode(int seen) {
+        if (isRegisterStore()) {
+            int param = getRegisterOperand() + shift;
+            if (param >= 0 && param < nArgs) {
+                argEnabled[param] = false;
+                passedParameters[param] = null;
+            }
+        }
+        switch (seen) {
+        case INVOKESPECIAL:
+        case INVOKESTATIC:
+        case INVOKEINTERFACE:
+        case INVOKEVIRTUAL:
+            MethodDescriptor md = getMethodDescriptorOperand();
+            int callArgs = getNumberArguments(md.getSignature());
+            for (int i = 0; i < callArgs; i++) {
+                Item item = getStack().getStackItem(callArgs - 1 - i);
+                int param = item.getRegisterNumber() + shift;
+                if (param >= 0 && param < nArgs && argEnabled[param]) {
+                    List<MethodParameter> list = passedParameters[param];
+                    if (list == null) {
+                        passedParameters[param] = list = new ArrayList<>();
+                    }
+                    list.add(new MethodParameter(md, i));
+                }
+            }
+            break;
+        default:
+            break;
+        }
+    }
+}
diff --git a/BuildUnconditionalParamDerefDatabase.java b/BuildUnconditionalParamDerefDatabase.java
index 5fd902212fc52c57939bce435cd34f4ad104348f..b5bc35eb412587ec117cb83fb0c83309129e0848 100644
--- a/BuildUnconditionalParamDerefDatabase.java
+++ b/BuildUnconditionalParamDerefDatabase.java
@@ -136,8 +136,8 @@ public abstract class BuildUnconditionalParamDerefDatabase implements Detector {
                     TypeQualifierAnnotation typeQualifierAnnotation = TypeQualifierApplications
                             .getEffectiveTypeQualifierAnnotation(xmethod, i, nonnullTypeQualifierValue);
                     boolean implicitNullCheckForEquals = false;
-                    if (directTypeQualifierAnnotation == null && method.getName().equals("equals")
-                            && method.getSignature().equals("(Ljava/lang/Object;)Z") && !method.isStatic()) {
+                    if (directTypeQualifierAnnotation == null && "equals".equals(method.getName())
+                            && "(Ljava/lang/Object;)Z".equals(method.getSignature()) && !method.isStatic()) {
                         implicitNullCheckForEquals = true;
                         Code code = method.getCode();
                         ConstantPool cp = jclass.getConstantPool();
@@ -170,7 +170,7 @@ public abstract class BuildUnconditionalParamDerefDatabase implements Detector {
                         if (typeQualifierAnnotation.when != When.UNKNOWN) {
                             priority--;
                         }
-                        if (xmethod.isStatic() || xmethod.isFinal() || xmethod.isPrivate() || xmethod.getName().equals("<init>")
+                        if (xmethod.isStatic() || xmethod.isFinal() || xmethod.isPrivate() || "<init>".equals(xmethod.getName())
                                 || jclass.isFinal()) {
                             priority--;
                         }
@@ -184,7 +184,7 @@ public abstract class BuildUnconditionalParamDerefDatabase implements Detector {
                     }
                 }
                 i++;
-                if (paramSig.equals("D") || paramSig.equals("J")) {
+                if ("D".equals(paramSig) || "J".equals(paramSig)) {
                     paramLocalOffset += 2;
                 } else {
                     paramLocalOffset += 1;
diff --git a/CallToUnsupportedMethod.java b/CallToUnsupportedMethod.java
index d0670ca0784d8eb16d85be8937dd1229e1f88f14..cdb16535611e3c1dcd7cd6e8a83ef6ba4a1dc790 100644
--- a/CallToUnsupportedMethod.java
+++ b/CallToUnsupportedMethod.java
@@ -119,7 +119,7 @@ public class CallToUnsupportedMethod implements Detector {
                 continue;
             }
             String methodSig = inv.getSignature(constantPoolGen);
-            if (methodSig.equals("()Ljava/lang/UnsupportedOperationException;")) {
+            if ("()Ljava/lang/UnsupportedOperationException;".equals(methodSig)) {
                 continue;
             }
 
diff --git a/CheckAnalysisContextContainedAnnotation.java b/CheckAnalysisContextContainedAnnotation.java
index 5a98caaa1513a58a4618e6466c4322f9592a25d7..1f8aa57b98525f8d2333cbcef22515539b7b8448 100644
--- a/CheckAnalysisContextContainedAnnotation.java
+++ b/CheckAnalysisContextContainedAnnotation.java
@@ -75,10 +75,10 @@ public class CheckAnalysisContextContainedAnnotation extends OpcodeStackDetector
             return;
         }
         String signature = field.getSignature();
-        if (signature.startsWith("Ljava/util/") && !signature.equals("Ljava/util/regex/Pattern;")
-                && !signature.equals("Ljava/util/logging/Logger;") && !signature.equals("Ljava/util/BitSet;")
-                && !signature.equals("Ljava/util/ResourceBundle;")
-                && !signature.equals("Ljava/util/Comparator;")
+        if (signature.startsWith("Ljava/util/") && !"Ljava/util/regex/Pattern;".equals(signature)
+                && !"Ljava/util/logging/Logger;".equals(signature) && !"Ljava/util/BitSet;".equals(signature)
+                && !"Ljava/util/ResourceBundle;".equals(signature)
+                && !"Ljava/util/Comparator;".equals(signature)
                 && getXField().getAnnotation(ConstantAnnotation) == null) {
             boolean flagged = analysisContextContained(getXClass());
 
@@ -129,10 +129,10 @@ public class CheckAnalysisContextContainedAnnotation extends OpcodeStackDetector
             return false;
         }
 
-        if (m.getName().equals("compareTo") && m.getSignature().equals("(Ljava/lang/Object;)I")) {
+        if ("compareTo".equals(m.getName()) && "(Ljava/lang/Object;)I".equals(m.getSignature())) {
             return true;
         }
-        if (m.getName().equals("compare") && m.getSignature().equals("(Ljava/lang/Object;Ljava/lang/Object;)I")) {
+        if ("compare".equals(m.getName()) && "(Ljava/lang/Object;Ljava/lang/Object;)I".equals(m.getSignature())) {
             return true;
         }
 
diff --git a/CheckExpectedWarnings.java b/CheckExpectedWarnings.java
index a8752cfd9665dd99f1a420de7cbd9695494fcdd7..d70161183583ee91e64bd338267b32ec1bc8a9c3 100644
--- a/CheckExpectedWarnings.java
+++ b/CheckExpectedWarnings.java
@@ -181,6 +181,12 @@ public class CheckExpectedWarnings implements Detector2, NonReportingDetector {
         if (DEBUG) {
             System.out.println("CEW: checking " + xclass.toString());
         }
+        if (xclass.isSynthetic()) {
+            if (DEBUG) {
+                System.out.println("Skipping synthetic classxclass " + xclass.toString());
+            }
+            return;
+        }
         check(xclass, expectWarning, true, HIGH_PRIORITY);
         check(xclass, desireWarning, true, NORMAL_PRIORITY);
         check(xclass, noWarning, false, HIGH_PRIORITY);
@@ -190,6 +196,12 @@ public class CheckExpectedWarnings implements Detector2, NonReportingDetector {
             if (DEBUG) {
                 System.out.println("CEW: checking " + xmethod.toString());
             }
+            if (xmethod.isSynthetic()) {
+                if (DEBUG) {
+                    System.out.println("Skipping synthetic method " + xmethod.toString());
+                }
+                continue;
+            }
             check(xmethod, expectWarning, true, HIGH_PRIORITY);
             check(xmethod, desireWarning, true, NORMAL_PRIORITY);
             check(xmethod, noWarning, false, HIGH_PRIORITY);
@@ -199,6 +211,12 @@ public class CheckExpectedWarnings implements Detector2, NonReportingDetector {
             if (DEBUG) {
                 System.out.println("CEW: checking " + xfield.toString());
             }
+            if (xfield.isSynthetic()) {
+                if (DEBUG) {
+                    System.out.println("Skipping synthetic field " + xfield.toString());
+                }
+                continue;
+            }
             check(xfield, expectWarning, true, HIGH_PRIORITY);
             check(xfield, desireWarning, true, NORMAL_PRIORITY);
             check(xfield, noWarning, false, HIGH_PRIORITY);
@@ -300,6 +318,9 @@ public class CheckExpectedWarnings implements Detector2, NonReportingDetector {
         Collection<SourceLineAnnotation> bugs = countWarnings(warnings, bugCode, minPriority,
                 rank);
         if (expectWarnings && bugs.size() < num) {
+            if (DetectorFactoryCollection.instance().isDisabledByDefault(bugCode)) {
+                return;
+            }
             BugInstance bug = makeWarning("FB_MISSING_EXPECTED_WARNING", methodDescriptor, priority, cd).addString(bugCodeMessage);
             if (!bugs.isEmpty()) {
                 bug.addString(String.format("Expected %d bugs, saw %d", num, bugs.size()));
@@ -342,6 +363,7 @@ public class CheckExpectedWarnings implements Detector2, NonReportingDetector {
     private static Collection<SourceLineAnnotation> countWarnings( Collection<BugInstance> warnings,
             @CheckForNull String bugCode,
             int desiredPriority, int rank) {
+
         Collection<SourceLineAnnotation> matching = new HashSet<SourceLineAnnotation>();
         DetectorFactoryCollection i18n = DetectorFactoryCollection.instance();
         boolean matchPattern = false;
@@ -389,7 +411,7 @@ public class CheckExpectedWarnings implements Detector2, NonReportingDetector {
         }
         for (BugPattern b : DetectorFactoryCollection.instance().getBugPatterns()) {
             String category = b.getCategory();
-            if (!b.isDeprecated() && !category.equals("EXPERIMENTAL") && !claimedReported.contains(b)) {
+            if (!b.isDeprecated() && !"EXPERIMENTAL".equals(category) && !claimedReported.contains(b)) {
                 AnalysisContext.logError("No detector claims " + b.getType());
             }
         }
diff --git a/CheckRelaxingNullnessAnnotation.java b/CheckRelaxingNullnessAnnotation.java
index 378acae00bd712277b1b21a51891292758f6ab22..3e72f2fa6ec514906bc9303d9f82513504a76cd9 100644
--- a/CheckRelaxingNullnessAnnotation.java
+++ b/CheckRelaxingNullnessAnnotation.java
@@ -123,23 +123,22 @@ public class CheckRelaxingNullnessAnnotation extends ClassNodeDetector {
 
         private Map<Integer, NullnessAnnotation> nonNullParameter;
 
-        private boolean checkForNullReturn;
+        private boolean relaxedNullReturn;
 
         DetectorNode(int access, String name, String desc, String signature, String[] exceptions, XMethod xmethod) {
             super(FindBugsASM.ASM_VERSION, access, name, desc, signature, exceptions);
             this.xmethod = xmethod;
         }
 
-        @SuppressWarnings("unchecked")
         @Override
         public void visitEnd() {
             super.visitEnd();
             // 1 test if we have suspicious annotations on method or parameters
-            checkForNullReturn = containsCheckForNull(visibleAnnotations);
-            if(!checkForNullReturn){
-                checkForNullReturn = containsCheckForNull(invisibleAnnotations);
+            relaxedNullReturn = containsRelaxedNonNull(visibleAnnotations);
+            if(!relaxedNullReturn){
+                relaxedNullReturn = containsRelaxedNonNull(invisibleAnnotations);
             }
-            boolean needsCheck = checkForNullReturn;
+            boolean needsCheck = relaxedNullReturn;
             if (invisibleParameterAnnotations != null || visibleParameterAnnotations != null) {
                 nonNullParameter = getNonnullOrNullableParams(visibleParameterAnnotations);
                 Map<Integer, NullnessAnnotation> nnp = getNonnullOrNullableParams(invisibleParameterAnnotations);
@@ -186,7 +185,7 @@ public class CheckRelaxingNullnessAnnotation extends ClassNodeDetector {
 
         private final boolean checkMethod(@Nonnull XMethod method) {
             boolean foundAny = false;
-            if (checkForNullReturn && containsNullness(method.getAnnotations(), NONNULL)) {
+            if (relaxedNullReturn && containsNullness(method.getAnnotations(), NONNULL)) {
                 BugInstance bug = new BugInstance(CheckRelaxingNullnessAnnotation.this, "NP_METHOD_RETURN_RELAXING_ANNOTATION",
                         HIGH_PRIORITY);
                 bug.addClassAndMethod(xmethod);
@@ -262,13 +261,13 @@ public class CheckRelaxingNullnessAnnotation extends ClassNodeDetector {
         }
     }
 
-    static boolean containsCheckForNull(@CheckForNull List<AnnotationNode> methodAnnotations) {
+    static boolean containsRelaxedNonNull(@CheckForNull List<AnnotationNode> methodAnnotations) {
         if (methodAnnotations == null) {
             return false;
         }
         for (AnnotationNode annotation : methodAnnotations) {
             NullnessAnnotation nullness = getNullness(annotation.desc);
-            if (nullness == CHECK_FOR_NULL) {
+            if (nullness == CHECK_FOR_NULL || nullness == NULLABLE) {
                 return true;
             }
         }
diff --git a/CheckTypeQualifiers.java b/CheckTypeQualifiers.java
index 47617ac9b5c59947954d2bcf70b636009c5b9286..7c9d5742d82134445901f350cc9d4eae4f762d8e 100644
--- a/CheckTypeQualifiers.java
+++ b/CheckTypeQualifiers.java
@@ -236,7 +236,7 @@ public class CheckTypeQualifiers extends CFGDetector {
 
         ForwardTypeQualifierDataflow forwardDataflow = forwardDataflowFactory.getDataflow(typeQualifierValue);
 
-        if (DEBUG_DATAFLOW && (DEBUG_DATAFLOW_MODE.startsWith("forward") || DEBUG_DATAFLOW_MODE.equals("both"))) {
+        if (DEBUG_DATAFLOW && (DEBUG_DATAFLOW_MODE.startsWith("forward") || "both".equals(DEBUG_DATAFLOW_MODE))) {
             System.out.println("********* Forwards analysis *********");
             DataflowCFGPrinter<TypeQualifierValueSet, ForwardTypeQualifierDataflowAnalysis> p = new DataflowCFGPrinter<TypeQualifierValueSet, ForwardTypeQualifierDataflowAnalysis>(
                     forwardDataflow);
@@ -245,7 +245,7 @@ public class CheckTypeQualifiers extends CFGDetector {
 
         BackwardTypeQualifierDataflow backwardDataflow = backwardDataflowFactory.getDataflow(typeQualifierValue);
 
-        if (DEBUG_DATAFLOW && (DEBUG_DATAFLOW_MODE.startsWith("backward") || DEBUG_DATAFLOW_MODE.equals("both"))) {
+        if (DEBUG_DATAFLOW && (DEBUG_DATAFLOW_MODE.startsWith("backward") || "both".equals(DEBUG_DATAFLOW_MODE))) {
             System.out.println("********* Backwards analysis *********");
             DataflowCFGPrinter<TypeQualifierValueSet, BackwardTypeQualifierDataflowAnalysis> p = new DataflowCFGPrinter<TypeQualifierValueSet, BackwardTypeQualifierDataflowAnalysis>(
                     backwardDataflow);
@@ -328,7 +328,7 @@ public class CheckTypeQualifiers extends CFGDetector {
             isTest = true;
         }  else if (ins instanceof InvokeInstruction && ins.consumeStack(cpg) == 2) {
             InvokeInstruction invoke = (InvokeInstruction) ins;
-            isTest = invoke.getMethodName(cpg).equals("equals") &&invoke.getSignature(cpg).equals("(Ljava/lang/Object;)Z") ;
+            isTest = "equals".equals(invoke.getMethodName(cpg)) &&"(Ljava/lang/Object;)Z".equals(invoke.getSignature(cpg)) ;
         }
         if (isTest) {
             ValueNumber top = factAtLocation.getStackValue(0);
@@ -484,8 +484,6 @@ public class CheckTypeQualifiers extends CFGDetector {
 
             if (DEBUG) {
                 System.out.println("Check " + vn + ": forward=" + forward + ", backward=" + backward + " at " + checkLocation);
-                forwardsFact.getValue(vn);
-                backwardsFact.getValue(vn);
             }
 
             emitDataflowWarning(xMethod, typeQualifierValue, forwardsFact, backwardsFact, vn, forward, backward,
diff --git a/CloneIdiom.java b/CloneIdiom.java
index 18df5c9de275c60ae6357f8ce28d5166689c0dfd..3452cbbcda5bf3006916b6572a9f6bdb134af069 100644
--- a/CloneIdiom.java
+++ b/CloneIdiom.java
@@ -79,14 +79,14 @@ public class CloneIdiom extends DismantleBytecode implements Detector, Stateless
 
     @Override
     public void visit(Code obj) {
-        if (getMethodName().equals("clone") && getMethodSig().startsWith("()")) {
+        if ("clone".equals(getMethodName()) && getMethodSig().startsWith("()")) {
             super.visit(obj);
         }
     }
 
     @Override
     public void sawOpcode(int seen) {
-        if (seen == INVOKESPECIAL && getNameConstantOperand().equals("clone") && getSigConstantOperand().startsWith("()")) {
+        if (seen == INVOKESPECIAL && "clone".equals(getNameConstantOperand()) && getSigConstantOperand().startsWith("()")) {
             /*
              * System.out.println("Saw call to " + nameConstant + ":" +
              * sigConstant + " in " + betterMethodName);
@@ -112,7 +112,7 @@ public class CloneIdiom extends DismantleBytecode implements Detector, Stateless
         // Does this class directly implement Cloneable?
         String[] interface_names = obj.getInterfaceNames();
         for (String interface_name : interface_names) {
-            if (interface_name.equals("java.lang.Cloneable")) {
+            if ("java.lang.Cloneable".equals(interface_name)) {
                 implementsCloneableDirectly = true;
                 isCloneable = true;
                 break;
@@ -190,7 +190,7 @@ public class CloneIdiom extends DismantleBytecode implements Detector, Stateless
     public void visit(ConstantNameAndType obj) {
         String methodName = obj.getName(getConstantPool());
         String methodSig = obj.getSignature(getConstantPool());
-        if (!methodName.equals("clone")) {
+        if (!"clone".equals(methodName)) {
             return;
         }
         if (!methodSig.startsWith("()")) {
@@ -207,7 +207,7 @@ public class CloneIdiom extends DismantleBytecode implements Detector, Stateless
         if (!obj.isPublic()) {
             return;
         }
-        if (!getMethodName().equals("clone")) {
+        if (!"clone".equals(getMethodName())) {
             return;
         }
         if (!getMethodSig().startsWith("()")) {
diff --git a/ConfusionBetweenInheritedAndOuterMethod.java b/ConfusionBetweenInheritedAndOuterMethod.java
index 6d9829968ac701b7b43a47a917fa8b6f7eb786c8..73d3ef81b9408392d77e6a901b69ff8ffa0058ad 100644
--- a/ConfusionBetweenInheritedAndOuterMethod.java
+++ b/ConfusionBetweenInheritedAndOuterMethod.java
@@ -22,19 +22,24 @@ package edu.umd.cs.findbugs.detect;
 import org.apache.bcel.classfile.Code;
 import org.apache.bcel.classfile.Field;
 import org.apache.bcel.classfile.JavaClass;
+import org.apache.bcel.classfile.LocalVariable;
+import org.apache.bcel.classfile.LocalVariableTable;
 
 import edu.umd.cs.findbugs.BugAccumulator;
 import edu.umd.cs.findbugs.BugInstance;
 import edu.umd.cs.findbugs.BugReporter;
-import edu.umd.cs.findbugs.BytecodeScanningDetector;
 import edu.umd.cs.findbugs.ba.XFactory;
 import edu.umd.cs.findbugs.ba.XMethod;
+import edu.umd.cs.findbugs.ba.ch.Subtypes2;
 import edu.umd.cs.findbugs.bcel.BCELUtil;
+import edu.umd.cs.findbugs.bcel.OpcodeStackDetector;
 
-public class ConfusionBetweenInheritedAndOuterMethod extends BytecodeScanningDetector {
+public class ConfusionBetweenInheritedAndOuterMethod extends OpcodeStackDetector {
 
     BugAccumulator bugAccumulator;
 
+    BugInstance iteratorBug;
+
     public ConfusionBetweenInheritedAndOuterMethod(BugReporter bugReporter) {
         this.bugAccumulator = new BugAccumulator(bugReporter);
     }
@@ -62,14 +67,31 @@ public class ConfusionBetweenInheritedAndOuterMethod extends BytecodeScanningDet
     @Override
     public void visit(Code obj) {
         if (isInnerClass  && !BCELUtil.isSynthetic(getMethod())) {
-            //            System.out.println(getFullyQualifiedMethodName());
             super.visit(obj);
+            iteratorBug = null;
         }
     }
 
     @Override
     public void sawOpcode(int seen) {
-        //        System.out.printf("%3d : %s%n", getPC(), OPCODE_NAMES[seen]);
+        if (iteratorBug != null) {
+            if (isRegisterStore()) {
+                LocalVariableTable lvt = getMethod().getLocalVariableTable();
+                if (lvt != null) {
+                    LocalVariable localVariable = lvt.getLocalVariable(getRegisterOperand(), getNextPC());
+                    if(localVariable == null || localVariable.getName().endsWith("$")) {
+                        // iterator() result is stored to the synthetic variable which has no name in LVT or name is suffixed with '$'
+                        // Looks like it's for-each cycle like for(Object obj : this)
+                        // Do not report such case
+                        iteratorBug = null;
+                    }
+                }
+            }
+            if(iteratorBug != null) {
+                bugAccumulator.accumulateBug(iteratorBug, this);
+            }
+            iteratorBug = null;
+        }
         if (seen != INVOKEVIRTUAL) {
             return;
         }
@@ -82,6 +104,10 @@ public class ConfusionBetweenInheritedAndOuterMethod extends BytecodeScanningDet
                 || invokedMethod.isSynthetic()) {
             return;
         }
+        if(getStack().getStackItem(getNumberArguments(getSigConstantOperand())).getRegisterNumber() != 0) {
+            // called not for this object
+            return;
+        }
         // method is inherited
         String possibleTargetClass = getDottedClassName();
         String superClassName = getDottedSuperclassName();
@@ -110,15 +136,17 @@ public class ConfusionBetweenInheritedAndOuterMethod extends BytecodeScanningDet
                     priority++;
                 }
 
-                //                System.out.println("Found it");
-                bugAccumulator.accumulateBug(
-                        new BugInstance(this, "IA_AMBIGUOUS_INVOCATION_OF_INHERITED_OR_OUTER_METHOD", priority)
-                        .addClassAndMethod(this).addMethod(invokedMethod).describe("METHOD_INHERITED")
-                        .addMethod(alternativeMethod).describe("METHOD_ALTERNATIVE_TARGET"), this);
+                BugInstance bug = new BugInstance(this, "IA_AMBIGUOUS_INVOCATION_OF_INHERITED_OR_OUTER_METHOD", priority)
+                .addClassAndMethod(this).addMethod(invokedMethod).describe("METHOD_INHERITED")
+                .addMethod(alternativeMethod).describe("METHOD_ALTERNATIVE_TARGET");
+                if(invokedMethod.getName().equals("iterator") && invokedMethod.getSignature().equals("()Ljava/util/Iterator;")
+                        && Subtypes2.instanceOf(getDottedClassName(), "java.lang.Iterable")) {
+                    iteratorBug = bug;
+                } else {
+                    bugAccumulator.accumulateBug(bug, this);
+                }
                 break;
             }
         }
-
     }
-
 }
diff --git a/CovariantArrayAssignment.java b/CovariantArrayAssignment.java
new file mode 100644
index 0000000000000000000000000000000000000000..0a2383689042bf21d3a119a323dcf002f8b75722
--- /dev/null
+++ b/CovariantArrayAssignment.java
@@ -0,0 +1,190 @@
+/*
+ * FindBugs - Find Bugs in Java programs
+ * Copyright (C) 2003-2008 University of Maryland
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+package edu.umd.cs.findbugs.detect;
+
+import org.apache.bcel.classfile.Code;
+import org.apache.bcel.classfile.LocalVariable;
+import org.apache.bcel.classfile.LocalVariableTable;
+
+import edu.umd.cs.findbugs.BugAccumulator;
+import edu.umd.cs.findbugs.BugInstance;
+import edu.umd.cs.findbugs.BugReporter;
+import edu.umd.cs.findbugs.OpcodeStack.Item;
+import edu.umd.cs.findbugs.ba.AnalysisContext;
+import edu.umd.cs.findbugs.ba.SignatureParser;
+import edu.umd.cs.findbugs.ba.XClass;
+import edu.umd.cs.findbugs.ba.XField;
+import edu.umd.cs.findbugs.ba.ch.Subtypes2;
+import edu.umd.cs.findbugs.bcel.OpcodeStackDetector;
+import edu.umd.cs.findbugs.classfile.ClassDescriptor;
+import edu.umd.cs.findbugs.classfile.DescriptorFactory;
+import edu.umd.cs.findbugs.classfile.FieldDescriptor;
+import edu.umd.cs.findbugs.internalAnnotations.SlashedClassName;
+
+/**
+ * @author Tagir Valeev
+ */
+public class CovariantArrayAssignment extends OpcodeStackDetector {
+    private final BugAccumulator accumulator;
+
+    public CovariantArrayAssignment(BugReporter bugReporter) {
+        accumulator = new BugAccumulator(bugReporter);
+    }
+
+    @Override
+    public void visit(Code obj) {
+        super.visit(obj);
+        accumulator.reportAccumulatedBugs();
+    }
+
+    /**
+     * @param superClass
+     * @param subClass
+     * @return true if superClass is abstract or interface and all known non-abstract implementations
+     * are derived from given subClass
+     */
+    private static boolean allImplementationsDerivedFromSubclass(@SlashedClassName String superClass, @SlashedClassName String subClass) {
+        ClassDescriptor superDescriptor = DescriptorFactory.createClassDescriptor(superClass);
+        XClass xClass = AnalysisContext.currentXFactory().getXClass(superDescriptor);
+        if(xClass == null || (!xClass.isInterface() && !xClass.isAbstract())) {
+            return false;
+        }
+        try {
+            ClassDescriptor wantedDescriptor = DescriptorFactory.createClassDescriptor(subClass);
+            Subtypes2 subtypes2 = AnalysisContext.currentAnalysisContext().getSubtypes2();
+            for (ClassDescriptor subDescriptor : subtypes2.getSubtypes(superDescriptor)) {
+                if (subDescriptor.equals(superDescriptor) || subDescriptor.equals(wantedDescriptor)) {
+                    continue;
+                }
+                XClass xSubClass = AnalysisContext.currentXFactory().getXClass(subDescriptor);
+                if (xSubClass == null
+                        || (!xSubClass.isAbstract() && !xSubClass.isInterface() && !subtypes2.isSubtype(subDescriptor,
+                                wantedDescriptor))) {
+                    return false;
+                }
+            }
+            return true;
+        } catch (ClassNotFoundException e) {
+            // unresolved class
+        }
+        return false;
+    }
+
+    @Override
+    public void sawOpcode(int seen) {
+        if ((isRegisterStore() && !isRegisterLoad()) || seen == PUTFIELD || seen == PUTSTATIC || seen == ARETURN) {
+            Item valueItem = getStack().getStackItem(0);
+            if(!valueItem.isNull() && valueItem.isNewlyAllocated() && valueItem.getSignature().startsWith("[L")
+                    && !((Integer)0).equals(valueItem.getConstant())) {
+                String valueClass = valueItem.getSignature().substring(2, valueItem.getSignature().length()-1);
+                String arraySignature = null;
+                int priority = LOW_PRIORITY;
+                String pattern = null;
+                FieldDescriptor field = null;
+                if(seen == PUTFIELD || seen == PUTSTATIC) {
+                    arraySignature = getSigConstantOperand();
+                    pattern = "CAA_COVARIANT_ARRAY_FIELD";
+                    field = getFieldDescriptorOperand();
+                    if(field instanceof XField) {
+                        XField xField = (XField)field;
+                        if((xField.isPublic() || xField.isProtected())) {
+                            XClass xClass = AnalysisContext.currentXFactory().getXClass(xField.getClassDescriptor());
+                            if(xClass != null && xClass.isPublic()) {
+                                priority = NORMAL_PRIORITY;
+                            }
+                        }
+                    }
+                } else if(seen == ARETURN) {
+                    if(getXMethod().bridgeFrom() == null) {
+                        pattern = "CAA_COVARIANT_ARRAY_RETURN";
+                        arraySignature = new SignatureParser(getMethodSig()).getReturnTypeSignature();
+                        if (!arraySignature.equals("[Ljava/lang/Object;")
+                                && (getXMethod().isPublic() || getXMethod().isProtected()) && getXClass().isPublic()) {
+                            priority = NORMAL_PRIORITY;
+                        }
+                    }
+                } else {
+                    LocalVariableTable lvt = getMethod().getLocalVariableTable();
+                    if(lvt != null) {
+                        LocalVariable localVariable = lvt.getLocalVariable(getRegisterOperand(), getNextPC());
+                        if(localVariable != null) {
+                            pattern = "CAA_COVARIANT_ARRAY_LOCAL";
+                            arraySignature = localVariable.getSignature();
+                        }
+                    }
+                }
+                if(arraySignature != null && arraySignature.startsWith("[L")) {
+                    String arrayClass = arraySignature.substring(2, arraySignature.length()-1);
+                    if(!valueClass.equals(arrayClass)) {
+                        if(priority == NORMAL_PRIORITY && allImplementationsDerivedFromSubclass(arrayClass, valueClass)) {
+                            priority = LOW_PRIORITY;
+                        }
+                        BugInstance bug = new BugInstance(this, pattern, priority).addClassAndMethod(this)
+                                .addFoundAndExpectedType(valueItem.getSignature(), arraySignature)
+                                .addSourceLine(this).addValueSource(valueItem, this);
+                        if(field != null) {
+                            bug.addField(field);
+                        }
+                        accumulator.accumulateBug(bug, this);
+                    }
+                }
+            }
+        }
+
+        if (seen == AASTORE) {
+            Item valueItem = getStack().getStackItem(0);
+            if(!valueItem.isNull()) {
+                Item arrayItem = getStack().getStackItem(2);
+                String arraySignature = arrayItem.getSignature();
+                String valueSignature = valueItem.getSignature();
+                // if valueSignature is "Ljava/lang/Object;" then OpcodeStack probably could not define actual type at all: skip this case
+                if(arraySignature.startsWith("[L") && valueSignature.startsWith("L") && !valueSignature.equals("Ljava/lang/Object;")) {
+                    String arrayClass = arraySignature.substring(2, arraySignature.length()-1);
+                    String valueClass = valueSignature.substring(1, valueSignature.length()-1);
+                    try {
+                        ClassDescriptor valueClassDescriptor = DescriptorFactory.createClassDescriptor(valueClass);
+                        ClassDescriptor arrayClassDescriptor = DescriptorFactory.createClassDescriptor(arrayClass);
+                        if (!AnalysisContext.currentAnalysisContext().getSubtypes2()
+                                .isSubtype(valueClassDescriptor, arrayClassDescriptor)) {
+                            int priority = HIGH_PRIORITY;   // in this case we may be pretty sure that if this line is executed ArrayStoreException will happen
+                            if(AnalysisContext.currentAnalysisContext().getSubtypes2().isSubtype(arrayClassDescriptor, valueClassDescriptor)) {
+                                priority = NORMAL_PRIORITY;
+                                if(allImplementationsDerivedFromSubclass(valueClass, arrayClass)) {
+                                    // Every implementation of valueClass also extends arrayClass
+                                    // In this case ArrayStoreException will never occur in current project
+                                    // So it's enough that we reported a bug when this array was created
+                                    priority = IGNORE_PRIORITY;
+                                }
+                            }
+                            BugInstance bug = new BugInstance(this, "CAA_COVARIANT_ARRAY_ELEMENT_STORE", priority).addClassAndMethod(this)
+                                    .addFoundAndExpectedType(valueSignature, 'L'+arrayClass+';')
+                                    .addSourceLine(this)
+                                    .addValueSource(valueItem, this)
+                                    .addValueSource(arrayItem, this);
+                            accumulator.accumulateBug(bug, this);
+                        }
+                    } catch (ClassNotFoundException e) {
+                        // Probably class was not supplied to the analysis: assume that everything is correct
+                    }
+                }
+            }
+        }
+    }
+}
diff --git a/CrossSiteScripting.java b/CrossSiteScripting.java
index 6407532e20f993634357cc3d92a15f843ca42a05..4932ce37bb9a06719c717034cd7ddc5a1ca6d843 100644
--- a/CrossSiteScripting.java
+++ b/CrossSiteScripting.java
@@ -34,6 +34,9 @@ import edu.umd.cs.findbugs.SourceLineAnnotation;
 import edu.umd.cs.findbugs.StringAnnotation;
 import edu.umd.cs.findbugs.ba.XMethod;
 import edu.umd.cs.findbugs.bcel.OpcodeStackDetector;
+import edu.umd.cs.findbugs.classfile.Global;
+import edu.umd.cs.findbugs.classfile.MethodDescriptor;
+import edu.umd.cs.findbugs.detect.BuildStringPassthruGraph.StringPassthruDatabase;
 
 public class CrossSiteScripting extends OpcodeStackDetector {
 
@@ -41,9 +44,13 @@ public class CrossSiteScripting extends OpcodeStackDetector {
 
     final BugAccumulator accumulator;
 
+    private final Map<MethodDescriptor, int[]> allFileNameStringMethods;
+
     public CrossSiteScripting(BugReporter bugReporter) {
         this.bugReporter = bugReporter;
         this.accumulator = new BugAccumulator(bugReporter);
+        StringPassthruDatabase database = Global.getAnalysisCache().getDatabase(StringPassthruDatabase.class);
+        allFileNameStringMethods = database.getFileNameStringMethods();
     }
 
     Map<String, OpcodeStack.Item> map = new HashMap<String, OpcodeStack.Item>();
@@ -92,25 +99,28 @@ public class CrossSiteScripting extends OpcodeStackDetector {
 
         OpcodeStack.Item oldTop = top;
         top = null;
+        if (seen == INVOKESPECIAL || seen == INVOKESTATIC || seen == INVOKEINTERFACE || seen == INVOKEVIRTUAL) {
+            int[] params = allFileNameStringMethods.get(getMethodDescriptorOperand());
+            if(params != null) {
+                int numArgs = getNumberArguments(getSigConstantOperand());
+                for(int param : params) {
+                    OpcodeStack.Item path = stack.getStackItem(numArgs-1-param);
+                    if (isTainted(path)) {
+                        String bugPattern = taintPriority(path) == Priorities.HIGH_PRIORITY ? "PT_ABSOLUTE_PATH_TRAVERSAL"
+                                : "PT_RELATIVE_PATH_TRAVERSAL";
+                        annotateAndReport(new BugInstance(this, bugPattern, Priorities.NORMAL_PRIORITY).addClassAndMethod(this)
+                                .addCalledMethod(this), path);
+                    }
+                }
+            }
+        }
         if (seen == INVOKESPECIAL) {
             String calledClassName = getClassConstantOperand();
             String calledMethodName = getNameConstantOperand();
             String calledMethodSig = getSigConstantOperand();
 
-            if (calledClassName.startsWith("java/io/File") && calledMethodSig.equals("(Ljava/lang/String;)V")) {
-                OpcodeStack.Item path = stack.getStackItem(0);
-                if (isTainted(path)) {
-                    String bugPattern = taintPriority(path) == Priorities.HIGH_PRIORITY ? "PT_ABSOLUTE_PATH_TRAVERSAL"
-                            : "PT_RELATIVE_PATH_TRAVERSAL";
-                    annotateAndReport(new BugInstance(this, bugPattern, Priorities.NORMAL_PRIORITY).addClassAndMethod(this)
-                            .addCalledMethod(this), path);
-                }
-
-            }
-
-
-            if (calledClassName.equals("javax/servlet/http/Cookie") && calledMethodName.equals("<init>")
-                    && calledMethodSig.equals("(Ljava/lang/String;Ljava/lang/String;)V")) {
+            if ("javax/servlet/http/Cookie".equals(calledClassName) && "<init>".equals(calledMethodName)
+                    && "(Ljava/lang/String;Ljava/lang/String;)V".equals(calledMethodSig)) {
                 OpcodeStack.Item value = stack.getStackItem(0);
                 OpcodeStack.Item name = stack.getStackItem(1);
                 if (value.isServletParameterTainted() || name.isServletParameterTainted()) {
@@ -125,12 +135,12 @@ public class CrossSiteScripting extends OpcodeStackDetector {
             String calledClassName = getClassConstantOperand();
             String calledMethodName = getNameConstantOperand();
             String calledMethodSig = getSigConstantOperand();
-            if (calledClassName.equals("javax/servlet/http/HttpServletResponse") && calledMethodName.equals("setContentType")) {
+            if ("javax/servlet/http/HttpServletResponse".equals(calledClassName) && "setContentType".equals(calledMethodName)) {
                 OpcodeStack.Item writing = stack.getStackItem(0);
                 if ("text/plain".equals(writing.getConstant())) {
                     isPlainText = true;
                 }
-            } else if (calledClassName.equals("javax/servlet/http/HttpSession") && calledMethodName.equals("setAttribute")) {
+            } else if ("javax/servlet/http/HttpSession".equals(calledClassName) && "setAttribute".equals(calledMethodName)) {
 
                 OpcodeStack.Item value = stack.getStackItem(0);
                 OpcodeStack.Item name = stack.getStackItem(1);
@@ -138,7 +148,7 @@ public class CrossSiteScripting extends OpcodeStackDetector {
                 if (nameConstant instanceof String) {
                     map.put((String) nameConstant, value);
                 }
-            } else if (calledClassName.equals("javax/servlet/http/HttpSession") && calledMethodName.equals("getAttribute")) {
+            } else if ("javax/servlet/http/HttpSession".equals(calledClassName) && "getAttribute".equals(calledMethodName)) {
                 OpcodeStack.Item name = stack.getStackItem(0);
                 Object nameConstant = name.getConstant();
                 if (nameConstant instanceof String) {
@@ -148,13 +158,13 @@ public class CrossSiteScripting extends OpcodeStackDetector {
                         replaceTop = top;
                     }
                 }
-            } else if (calledClassName.equals("javax/servlet/http/HttpServletResponse")
+            } else if ("javax/servlet/http/HttpServletResponse".equals(calledClassName)
                     && (calledMethodName.startsWith("send") || calledMethodName.endsWith("Header"))
                     && calledMethodSig.endsWith("Ljava/lang/String;)V")) {
 
                 OpcodeStack.Item writing = stack.getStackItem(0);
                 if (isTainted(writing)) {
-                    if (calledMethodName.equals("sendError")) {
+                    if ("sendError".equals(calledMethodName)) {
                         annotateAndReport(
                                 new BugInstance(this, "XSS_REQUEST_PARAMETER_TO_SEND_ERROR", taintPriority(writing))
                                 .addClassAndMethod(this),
@@ -173,9 +183,9 @@ public class CrossSiteScripting extends OpcodeStackDetector {
             String calledMethodName = getNameConstantOperand();
             String calledMethodSig = getSigConstantOperand();
 
-            if ((calledMethodName.startsWith("print") || calledMethodName.equals("write"))
-                    && calledClassName.equals("javax/servlet/jsp/JspWriter")
-                    && (calledMethodSig.equals("(Ljava/lang/Object;)V") || calledMethodSig.equals("(Ljava/lang/String;)V"))) {
+            if ((calledMethodName.startsWith("print") || "write".equals(calledMethodName))
+                    && "javax/servlet/jsp/JspWriter".equals(calledClassName)
+                    && ("(Ljava/lang/Object;)V".equals(calledMethodSig) || "(Ljava/lang/String;)V".equals(calledMethodSig))) {
                 OpcodeStack.Item writing = stack.getStackItem(0);
                 // System.out.println(SourceLineAnnotation.fromVisitedInstruction(this)
                 // + " writing " + writing);
@@ -192,7 +202,7 @@ public class CrossSiteScripting extends OpcodeStackDetector {
                 }
             } else if (calledClassName.startsWith("java/io/") && calledClassName.endsWith("Writer")
                     && (calledMethodName.startsWith("print") || calledMethodName.startsWith("write"))
-                    && (calledMethodSig.equals("(Ljava/lang/Object;)V") || calledMethodSig.equals("(Ljava/lang/String;)V"))) {
+                    && ("(Ljava/lang/Object;)V".equals(calledMethodSig) || "(Ljava/lang/String;)V".equals(calledMethodSig))) {
                 OpcodeStack.Item writing = stack.getStackItem(0);
                 OpcodeStack.Item writingTo = stack.getStackItem(1);
                 if (isTainted(writing) && writingTo.isServletWriter()) {
@@ -239,8 +249,8 @@ public class CrossSiteScripting extends OpcodeStackDetector {
             return Priorities.NORMAL_PRIORITY;
         }
         XMethod method = writing.getReturnValueOf();
-        if (method != null && method.getName().equals("getParameter")
-                && method.getClassName().equals("javax.servlet.http.HttpServletRequest")) {
+        if (method != null && "getParameter".equals(method.getName())
+                && "javax.servlet.http.HttpServletRequest".equals(method.getClassName())) {
             return Priorities.HIGH_PRIORITY;
         }
         return Priorities.NORMAL_PRIORITY;
diff --git a/DoInsideDoPrivileged.java b/DoInsideDoPrivileged.java
index edbd260714be92bdeba8217d0a72d73d76378609..95e42ec325580278df16f78cba43fc16af15f985 100644
--- a/DoInsideDoPrivileged.java
+++ b/DoInsideDoPrivileged.java
@@ -50,7 +50,7 @@ public class DoInsideDoPrivileged extends BytecodeScanningDetector {
 
     @Override
     public void visit(Code obj) {
-        if (isDoPrivileged && getMethodName().equals("run")) {
+        if (isDoPrivileged && "run".equals(getMethodName())) {
             return;
         }
         if (getMethod().isPrivate()) {
@@ -65,10 +65,10 @@ public class DoInsideDoPrivileged extends BytecodeScanningDetector {
 
     @Override
     public void sawOpcode(int seen) {
-        if (seen == INVOKEVIRTUAL && getNameConstantOperand().equals("setAccessible")) {
+        if (seen == INVOKEVIRTUAL && "setAccessible".equals(getNameConstantOperand())) {
             @DottedClassName
             String className = getDottedClassConstantOperand();
-            if (className.equals("java.lang.reflect.Field") || className.equals("java.lang.reflect.Method")) {
+            if ("java.lang.reflect.Field".equals(className) || "java.lang.reflect.Method".equals(className)) {
                 bugAccumulator.accumulateBug(
                         new BugInstance(this, "DP_DO_INSIDE_DO_PRIVILEGED", LOW_PRIORITY).addClassAndMethod(this)
                         .addCalledMethod(this), this);
@@ -79,7 +79,7 @@ public class DoInsideDoPrivileged extends BytecodeScanningDetector {
             @DottedClassName
             String classOfConstructedClass = getDottedClassConstantOperand();
             if (Subtypes2.instanceOf(classOfConstructedClass, "java.lang.ClassLoader")
-                    && !(getMethodName().equals("main") && getMethodSig().equals("([Ljava/lang/String;)V") && getMethod()
+                    && !("main".equals(getMethodName()) && "([Ljava/lang/String;)V".equals(getMethodSig()) && getMethod()
                             .isStatic())) {
                 bugAccumulator.accumulateBug(new BugInstance(this, "DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED", NORMAL_PRIORITY)
                 .addClassAndMethod(this).addClass(classOfConstructedClass), this);
diff --git a/DontCatchIllegalMonitorStateException.java b/DontCatchIllegalMonitorStateException.java
index f1fb85a36d2dd23061503f03d7a146b38f68c8a5..93bcbb7c7be308ffb03a51b6e2033f994842a9a9 100644
--- a/DontCatchIllegalMonitorStateException.java
+++ b/DontCatchIllegalMonitorStateException.java
@@ -54,7 +54,7 @@ public class DontCatchIllegalMonitorStateException extends PreorderVisitor imple
         if (DEBUG) {
             String names[] = obj.getExceptionNames();
             for (String name : names) {
-                if (name.equals("java.lang.Exception") || name.equals("java.lang.Throwable")) {
+                if ("java.lang.Exception".equals(name) || "java.lang.Throwable".equals(name)) {
                     System.out.println(name + " thrown by " + getFullyQualifiedMethodName());
                 }
             }
@@ -74,7 +74,7 @@ public class DontCatchIllegalMonitorStateException extends PreorderVisitor imple
                 System.out.println(msg);
             }
         }
-        if (name.equals("java.lang.IllegalMonitorStateException")) {
+        if ("java.lang.IllegalMonitorStateException".equals(name)) {
             bugReporter.reportBug(new BugInstance(this, "IMSE_DONT_CATCH_IMSE", HIGH_PRIORITY).addClassAndMethod(this)
                     .addSourceLine(this.classContext, this, obj.getHandlerPC()));
         }
diff --git a/DontIgnoreResultOfPutIfAbsent.java b/DontIgnoreResultOfPutIfAbsent.java
index 215e4ad100551d859dfd5131e744d9ec283944c3..9d1d3c8241b2356c20ce1366dda6f0a6e3ea7a9a 100644
--- a/DontIgnoreResultOfPutIfAbsent.java
+++ b/DontIgnoreResultOfPutIfAbsent.java
@@ -61,6 +61,7 @@ import edu.umd.cs.findbugs.ba.XClass;
 import edu.umd.cs.findbugs.ba.XField;
 import edu.umd.cs.findbugs.ba.ch.Subtypes2;
 import edu.umd.cs.findbugs.ba.type.TypeDataflow;
+import edu.umd.cs.findbugs.ba.type.TypeFrame;
 import edu.umd.cs.findbugs.ba.vna.ValueNumber;
 import edu.umd.cs.findbugs.ba.vna.ValueNumberDataflow;
 import edu.umd.cs.findbugs.ba.vna.ValueNumberFrame;
@@ -70,6 +71,7 @@ import edu.umd.cs.findbugs.classfile.ClassDescriptor;
 import edu.umd.cs.findbugs.classfile.DescriptorFactory;
 import edu.umd.cs.findbugs.internalAnnotations.DottedClassName;
 import edu.umd.cs.findbugs.internalAnnotations.SlashedClassName;
+import edu.umd.cs.findbugs.util.ClassName;
 
 public class DontIgnoreResultOfPutIfAbsent implements Detector {
 
@@ -103,7 +105,7 @@ public class DontIgnoreResultOfPutIfAbsent implements Detector {
         for (Constant constantEntry : pool.getConstantPool()) {
             if (constantEntry instanceof ConstantNameAndType) {
                 ConstantNameAndType nt = (ConstantNameAndType) constantEntry;
-                if (nt.getName(pool).equals("putIfAbsent")) {
+                if ("putIfAbsent".equals(nt.getName(pool))) {
                     found = true;
                     break;
                 }
@@ -163,7 +165,7 @@ public class DontIgnoreResultOfPutIfAbsent implements Detector {
             if (superclassDescriptor != null) {
                 @SlashedClassName
                 String superClassName = superclassDescriptor.getClassName();
-                if (superClassName.equals("java/lang/Enum")) {
+                if ("java/lang/Enum".equals(superClassName)) {
                     return Priorities.LOW_PRIORITY;
                 }
             }
@@ -229,44 +231,46 @@ public class DontIgnoreResultOfPutIfAbsent implements Detector {
 
             if (ins instanceof InvokeInstruction) {
                 InvokeInstruction invoke = (InvokeInstruction) ins;
-                String className = invoke.getClassName(cpg);
-
-                if (invoke.getMethodName(cpg).equals("putIfAbsent")) {
+                if ("putIfAbsent".equals(invoke.getMethodName(cpg))) {
                     String signature = invoke.getSignature(cpg);
-                    if (signature.equals("(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;")
-                            && !(invoke instanceof INVOKESTATIC) && extendsConcurrentMap(className)) {
-                        InstructionHandle next = handle.getNext();
-                        boolean isIgnored = next != null && next.getInstruction() instanceof POP;
-                        //                        boolean isImmediateNullTest = next != null
-                        //                                && (next.getInstruction() instanceof IFNULL || next.getInstruction() instanceof IFNONNULL);
-                        if (countOtherCalls || isIgnored) {
-                            BitSet live = llsaDataflow.getAnalysis().getFactAtLocation(location);
-                            ValueNumberFrame vna = vnaDataflow.getAnalysis().getFactAtLocation(location);
-                            ValueNumber vn = vna.getTopValue();
-
-                            int locals = vna.getNumLocals();
-                            //                            boolean isRetained = false;
-                            for (int pos = 0; pos < locals; pos++) {
-                                if (vna.getValue(pos).equals(vn) && live.get(pos)) {
-                                    BugAnnotation ba = ValueNumberSourceInfo.findAnnotationFromValueNumber(method, location, vn,
-                                            vnaDataflow.getFactAtLocation(location), "VALUE_OF");
-                                    if (ba == null) {
-                                        continue;
-                                    }
-                                    String pattern = "RV_RETURN_VALUE_OF_PUTIFABSENT_IGNORED";
-                                    if (!isIgnored) {
-                                        pattern = "UNKNOWN";
+                    if ("(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;".equals(signature)
+                            && !(invoke instanceof INVOKESTATIC)) {
+                        TypeFrame typeFrame = typeDataflow.getFactAtLocation(location);
+                        Type objType = typeFrame.getStackValue(2);
+                        if(extendsConcurrentMap(ClassName.toDottedClassName(ClassName.fromFieldSignature(objType.getSignature())))) {
+                            InstructionHandle next = handle.getNext();
+                            boolean isIgnored = next != null && next.getInstruction() instanceof POP;
+                            //                        boolean isImmediateNullTest = next != null
+                            //                                && (next.getInstruction() instanceof IFNULL || next.getInstruction() instanceof IFNONNULL);
+                            if (countOtherCalls || isIgnored) {
+                                BitSet live = llsaDataflow.getAnalysis().getFactAtLocation(location);
+                                ValueNumberFrame vna = vnaDataflow.getAnalysis().getFactAtLocation(location);
+                                ValueNumber vn = vna.getTopValue();
+
+                                int locals = vna.getNumLocals();
+                                //                            boolean isRetained = false;
+                                for (int pos = 0; pos < locals; pos++) {
+                                    if (vna.getValue(pos).equals(vn) && live.get(pos)) {
+                                        BugAnnotation ba = ValueNumberSourceInfo.findAnnotationFromValueNumber(method, location, vn,
+                                                vnaDataflow.getFactAtLocation(location), "VALUE_OF");
+                                        if (ba == null) {
+                                            continue;
+                                        }
+                                        String pattern = "RV_RETURN_VALUE_OF_PUTIFABSENT_IGNORED";
+                                        if (!isIgnored) {
+                                            pattern = "UNKNOWN";
+                                        }
+                                        Type type = typeFrame.getTopValue();
+                                        int priority = getPriorityForBeingMutable(type);
+                                        BugInstance bugInstance = new BugInstance(this, pattern, priority)
+                                        .addClassAndMethod(methodGen, sourceFileName).addCalledMethod(methodGen, invoke)
+                                        .add(new TypeAnnotation(type)).add(ba);
+                                        SourceLineAnnotation where = SourceLineAnnotation.fromVisitedInstruction(classContext,
+                                                method, location);
+                                        accumulator.accumulateBug(bugInstance, where);
+                                        //                                    isRetained = true;
+                                        break;
                                     }
-                                    Type type = typeDataflow.getAnalysis().getFactAtLocation(location).getTopValue();
-                                    int priority = getPriorityForBeingMutable(type);
-                                    BugInstance bugInstance = new BugInstance(this, pattern, priority)
-                                    .addClassAndMethod(methodGen, sourceFileName).addCalledMethod(methodGen, invoke)
-                                    .add(new TypeAnnotation(type)).add(ba);
-                                    SourceLineAnnotation where = SourceLineAnnotation.fromVisitedInstruction(classContext,
-                                            method, location);
-                                    accumulator.accumulateBug(bugInstance, where);
-                                    //                                    isRetained = true;
-                                    break;
                                 }
                             }
                             /*
@@ -305,7 +309,7 @@ public class DontIgnoreResultOfPutIfAbsent implements Detector {
     }
 
     private boolean extendsConcurrentMap(@DottedClassName String className) {
-        if (className.equals("java.util.concurrent.ConcurrentHashMap")
+        if ("java.util.concurrent.ConcurrentHashMap".equals(className)
                 || className.equals(concurrentMapDescriptor.getDottedClassName())) {
             return true;
         }
diff --git a/DontUseEnum.java b/DontUseEnum.java
index 3c2592566c6c0f5394a6f6bf436076088a970e21..45b3914e7aad1ae1bf630c405c4705fa25811dd6 100644
--- a/DontUseEnum.java
+++ b/DontUseEnum.java
@@ -52,7 +52,7 @@ public class DontUseEnum extends PreorderDetector {
     }
 
     private boolean isReservedName(String name) {
-        return name.equals("enum") || name.equals("assert");
+        return "enum".equals(name) || "assert".equals(name);
     }
 
     @Override
diff --git a/DroppedException.java b/DroppedException.java
index 67df8d0dc5a3901d3be021da4025561dcb607901..1d44deaf7cfbce745cef8f8bf97f22ea0344916f 100644
--- a/DroppedException.java
+++ b/DroppedException.java
@@ -263,8 +263,8 @@ public class DroppedException extends PreorderVisitor implements Detector {
                 }
             }
 
-            if (end - start >= 4 && drops && !causeName.equals("java.lang.InterruptedException")
-                    && !causeName.equals("java.lang.CloneNotSupportedException")) {
+            if (end - start >= 4 && drops && !"java.lang.InterruptedException".equals(causeName)
+                    && !"java.lang.CloneNotSupportedException".equals(causeName)) {
                 int priority = NORMAL_PRIORITY;
                 if (exitInTryBlock) {
                     priority++;
@@ -285,8 +285,8 @@ public class DroppedException extends PreorderVisitor implements Detector {
                         priority += 2;
                     }
                 }
-                if (causeName.equals("java.lang.Error") || causeName.equals("java.lang.Exception") || causeName.equals("java.lang.Throwable")
-                        || causeName.equals("java.lang.RuntimeException")) {
+                if ("java.lang.Error".equals(causeName) || "java.lang.Exception".equals(causeName) || "java.lang.Throwable".equals(causeName)
+                        || "java.lang.RuntimeException".equals(causeName)) {
                     priority--;
                     if (end - start > 30) {
                         priority--;
@@ -447,7 +447,7 @@ public class DroppedException extends PreorderVisitor implements Detector {
 
             while (iter.hasPrevious()) {
                 Token token = iter.previous();
-                if (token.getKind() == Token.WORD && token.getLexeme().equals("catch")) {
+                if (token.getKind() == Token.WORD && "catch".equals(token.getLexeme())) {
                     foundCatch = true;
                     break;
                 }
@@ -492,33 +492,33 @@ public class DroppedException extends PreorderVisitor implements Detector {
                     }
                     switch (state) {
                     case START:
-                        if (value.equals("catch")) {
+                        if ("catch".equals(value)) {
                             state = CATCH;
                         }
                         break;
                     case CATCH:
-                        if (value.equals("(")) {
+                        if ("(".equals(value)) {
                             state = OPEN_PAREN;
                         }
                         break;
                     case OPEN_PAREN:
-                        if (value.equals(")")) {
+                        if (")".equals(value)) {
                             if (level == 0) {
                                 state = CLOSE_PAREN;
                             } else {
                                 --level;
                             }
-                        } else if (value.equals("(")) {
+                        } else if ("(".equals(value)) {
                             ++level;
                         }
                         break;
                     case CLOSE_PAREN:
-                        if (value.equals("{")) {
+                        if ("{".equals(value)) {
                             state = OPEN_BRACE;
                         }
                         break;
                     case OPEN_BRACE:
-                        boolean closeBrace = value.equals("}");
+                        boolean closeBrace = "}".equals(value);
                         if (DEBUG && !closeBrace) {
                             System.out.println("Found a comment in catch block: " + value);
                         }
diff --git a/DumbMethodInvocations.java b/DumbMethodInvocations.java
index da092926b6b7d5565973a6761d4fcfee90739467..22fb516838cf46077f5a17e601be609522f19be2 100644
--- a/DumbMethodInvocations.java
+++ b/DumbMethodInvocations.java
@@ -1,7 +1,9 @@
 package edu.umd.cs.findbugs.detect;
 
 import java.io.File;
+import java.util.Collections;
 import java.util.Iterator;
+import java.util.Map;
 
 import org.apache.bcel.classfile.Method;
 import org.apache.bcel.generic.ConstantPoolGen;
@@ -23,16 +25,32 @@ import edu.umd.cs.findbugs.ba.MethodUnprofitableException;
 import edu.umd.cs.findbugs.ba.constant.Constant;
 import edu.umd.cs.findbugs.ba.constant.ConstantDataflow;
 import edu.umd.cs.findbugs.ba.constant.ConstantFrame;
+import edu.umd.cs.findbugs.classfile.Global;
+import edu.umd.cs.findbugs.classfile.MethodDescriptor;
+import edu.umd.cs.findbugs.detect.BuildStringPassthruGraph.MethodParameter;
+import edu.umd.cs.findbugs.detect.BuildStringPassthruGraph.StringPassthruDatabase;
 
 public class DumbMethodInvocations implements Detector {
+    private static final MethodDescriptor STRING_SUBSTRING =
+            new MethodDescriptor("java/lang/String", "substring", "(I)Ljava/lang/String;");
+
 
     private final BugReporter bugReporter;
 
     private final BugAccumulator bugAccumulator;
 
+    private final Map<MethodDescriptor, int[]> allFileNameStringMethods;
+    private final Map<MethodDescriptor, int[]> allDatabasePasswordMethods;
+
     public DumbMethodInvocations(BugReporter bugReporter) {
         this.bugReporter = bugReporter;
         this.bugAccumulator = new BugAccumulator(bugReporter);
+
+        StringPassthruDatabase database = Global.getAnalysisCache().getDatabase(StringPassthruDatabase.class);
+        allFileNameStringMethods = database.getFileNameStringMethods();
+        allDatabasePasswordMethods = database.findLinkedMethods(Collections.singleton(new MethodParameter(new MethodDescriptor(
+                "java/sql/DriverManager", "getConnection",
+                "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/sql/Connection;", true), 2)));
     }
 
     @Override
@@ -83,26 +101,25 @@ public class DumbMethodInvocations implements Detector {
                 continue;
             }
 
-            if (iins.getName(cpg).equals("getConnection")
-                    && iins.getSignature(cpg).equals(
-                            "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/sql/Connection;")
-                            && iins.getClassName(cpg).equals("java.sql.DriverManager")) {
-                Constant operandValue = frame.getTopValue();
-                if (operandValue.isConstantString()) {
-                    String password = operandValue.getConstantString();
-                    if (password.length() == 0) {
-                        bugAccumulator.accumulateBug(new BugInstance(this, "DMI_EMPTY_DB_PASSWORD", NORMAL_PRIORITY)
-                        .addClassAndMethod(methodGen, sourceFile), classContext, methodGen, sourceFile, location);
-                    } else {
-                        bugAccumulator.accumulateBug(new BugInstance(this, "DMI_CONSTANT_DB_PASSWORD", NORMAL_PRIORITY)
-                        .addClassAndMethod(methodGen, sourceFile), classContext, methodGen, sourceFile, location);
-                    }
+            MethodDescriptor md = new MethodDescriptor(iins, cpg);
+            if (allDatabasePasswordMethods.containsKey(md)) {
+                for(int paramNumber : allDatabasePasswordMethods.get(md)) {
+                    Constant operandValue = frame.getStackValue(iins.getArgumentTypes(cpg).length-1-paramNumber);
+                    if (operandValue.isConstantString()) {
+                        String password = operandValue.getConstantString();
+                        if (password.length() == 0) {
+                            bugAccumulator.accumulateBug(new BugInstance(this, "DMI_EMPTY_DB_PASSWORD", NORMAL_PRIORITY)
+                            .addClassAndMethod(methodGen, sourceFile), classContext, methodGen, sourceFile, location);
+                        } else {
+                            bugAccumulator.accumulateBug(new BugInstance(this, "DMI_CONSTANT_DB_PASSWORD", NORMAL_PRIORITY)
+                            .addClassAndMethod(methodGen, sourceFile), classContext, methodGen, sourceFile, location);
+                        }
 
+                    }
                 }
             }
 
-            if (iins.getName(cpg).equals("substring") && iins.getSignature(cpg).equals("(I)Ljava/lang/String;")
-                    && iins.getClassName(cpg).equals("java.lang.String")) {
+            if (md.equals(STRING_SUBSTRING)) {
 
                 Constant operandValue = frame.getTopValue();
                 if (!operandValue.isConstantInteger()) {
@@ -114,25 +131,26 @@ public class DumbMethodInvocations implements Detector {
                     .addClassAndMethod(methodGen, sourceFile), classContext, methodGen, sourceFile, location);
                 }
 
-            } else if (iins.getName(cpg).equals("<init>") && iins.getSignature(cpg).equals("(Ljava/lang/String;)V")
-                    && iins.getClassName(cpg).equals("java.io.File")) {
+            } else if (allFileNameStringMethods.containsKey(md)) {
 
-                Constant operandValue = frame.getTopValue();
-                if (!operandValue.isConstantString()) {
-                    continue;
-                }
-                String v = operandValue.getConstantString();
-                if (isAbsoluteFileName(v) && !v.startsWith("/etc/") && !v.startsWith("/dev/")
-                        && !v.startsWith("/proc")) {
-                    int priority = NORMAL_PRIORITY;
-                    if (v.startsWith("/tmp")) {
-                        priority = LOW_PRIORITY;
-                    } else if (v.indexOf("/home") >= 0) {
-                        priority = HIGH_PRIORITY;
+                for(int paramNumber : allFileNameStringMethods.get(md)) {
+                    Constant operandValue = frame.getStackValue(iins.getArgumentTypes(cpg).length-1-paramNumber);
+                    if (!operandValue.isConstantString()) {
+                        continue;
+                    }
+                    String v = operandValue.getConstantString();
+                    if (isAbsoluteFileName(v) && !v.startsWith("/etc/") && !v.startsWith("/dev/")
+                            && !v.startsWith("/proc")) {
+                        int priority = NORMAL_PRIORITY;
+                        if (v.startsWith("/tmp")) {
+                            priority = LOW_PRIORITY;
+                        } else if (v.indexOf("/home") >= 0) {
+                            priority = HIGH_PRIORITY;
+                        }
+                        bugAccumulator.accumulateBug(new BugInstance(this, "DMI_HARDCODED_ABSOLUTE_FILENAME", priority)
+                        .addClassAndMethod(methodGen, sourceFile).addString(v).describe("FILE_NAME"), classContext,
+                        methodGen, sourceFile, location);
                     }
-                    bugAccumulator.accumulateBug(new BugInstance(this, "DMI_HARDCODED_ABSOLUTE_FILENAME", priority)
-                    .addClassAndMethod(methodGen, sourceFile).addString(v).describe("FILE_NAME"), classContext,
-                    methodGen, sourceFile, location);
                 }
 
             }
@@ -147,11 +165,15 @@ public class DumbMethodInvocations implements Detector {
         if (v.startsWith("/")) {
             return true;
         }
-        if (v.startsWith("C:")) {
+        if (v.startsWith("\\\\")) {
+            // UNC pathname like \\Server\share\...
             return true;
         }
-        if (v.startsWith("c:")) {
-            return true;
+        if (v.length() >= 2 && v.charAt(1) == ':') {
+            char driveletter = v.charAt(0);
+            if((driveletter >= 'A' && driveletter <= 'Z') || (driveletter >= 'a' && driveletter <= 'z')) {
+                return true;
+            }
         }
         try {
             File f = new File(v);
diff --git a/DumbMethods.java b/DumbMethods.java
index 75031679136e4584a3534440151c80dd7183b0ad..2ec03286ac5bf0c3a1ff806eda5a5417e62fd7c3 100644
--- a/DumbMethods.java
+++ b/DumbMethods.java
@@ -59,6 +59,7 @@ import edu.umd.cs.findbugs.ba.DataflowAnalysisException;
 import edu.umd.cs.findbugs.ba.Hierarchy;
 import edu.umd.cs.findbugs.ba.ObjectTypeFactory;
 import edu.umd.cs.findbugs.ba.SignatureParser;
+import edu.umd.cs.findbugs.ba.XField;
 import edu.umd.cs.findbugs.ba.XMethod;
 import edu.umd.cs.findbugs.ba.ch.Subtypes2;
 import edu.umd.cs.findbugs.ba.type.TypeDataflow;
@@ -72,6 +73,440 @@ import edu.umd.cs.findbugs.visitclass.PreorderVisitor;
 
 public class DumbMethods extends OpcodeStackDetector {
 
+    private abstract class SubDetector {
+        public void initMethod(Method method) {}
+
+        abstract public void sawOpcode(int seen);
+    }
+
+    private class InvalidMinMaxSubDetector extends SubDetector {
+        Number lowerBound, upperBound;
+
+        @Override
+        public void initMethod(Method method) {
+            lowerBound = upperBound = null;
+        }
+
+        @Override
+        public void sawOpcode(int seen) {
+            if(seen == INVOKESTATIC && getClassConstantOperand().equals("java/lang/Math") && (getMethodDescriptorOperand().getName().equals("max")
+                    || getMethodDescriptorOperand().getName().equals("min"))) {
+                Object const1 = stack.getStackItem(0).getConstant();
+                Object const2 = stack.getStackItem(1).getConstant();
+                Number n = null;
+                if(const1 != null ^ const2 != null) {
+                    n = (const1 instanceof Number) ? (Number)const1 : (Number)const2;
+                    if(getMethodDescriptorOperand().getName().equals("min")) {
+                        upperBound = n;
+                    } else {
+                        lowerBound = n;
+                    }
+                } else {
+                    upperBound = lowerBound = null;
+                }
+                XMethod rvo1 = stack.getStackItem(0).getReturnValueOf();
+                XMethod rvo2 = stack.getStackItem(1).getReturnValueOf();
+                if(rvo1 != null ^ rvo2 != null) {
+                    XMethod rvo = rvo1 == null ? rvo2 : rvo1;
+                    if (lowerBound instanceof Comparable && upperBound != null && upperBound.getClass() == lowerBound.getClass()
+                            && rvo.getClassDescriptor().getClassName().equals("java/lang/Math")
+                            && (rvo.getName().equals("max") || rvo.getName().equals("min"))) {
+                        @SuppressWarnings("unchecked")
+                        int result = ((Comparable<Number>)lowerBound).compareTo(upperBound);
+                        if(result > 0) {
+                            accumulator.accumulateBug(
+                                    new BugInstance("DM_INVALID_MIN_MAX", HIGH_PRIORITY).addClassAndMethod(DumbMethods.this)
+                                    .addString(String.valueOf(n)),
+                                    DumbMethods.this);
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    private class NullMethodsSubDetector extends SubDetector {
+
+        @Override
+        public void sawOpcode(int seen) {
+            if (seen == INVOKESTATIC && ("com/google/common/base/Preconditions".equals(getClassConstantOperand())
+                    && "checkNotNull".equals(getNameConstantOperand())
+                    || "com/google/common/base/Strings".equals(getClassConstantOperand())
+                    && ("nullToEmpty".equals(getNameConstantOperand()) ||
+                            "emptyToNull".equals(getNameConstantOperand()) ||
+                            "isNullOrEmpty".equals(getNameConstantOperand())))
+                    ) {
+                int args = PreorderVisitor.getNumberArguments(getSigConstantOperand());
+
+                OpcodeStack.Item item = stack.getStackItem(args - 1);
+                Object o = item.getConstant();
+                if (o instanceof String) {
+
+                    OpcodeStack.Item secondArgument = null;
+                    String bugPattern = "DMI_DOH";
+                    if (args > 1) {
+                        secondArgument = stack.getStackItem(args - 2);
+                        Object secondConstant = secondArgument.getConstant();
+                        if (!(secondConstant instanceof String)) {
+                            bugPattern = "DMI_ARGUMENTS_WRONG_ORDER";
+                        }
+                    }
+
+                    BugInstance bug = new BugInstance(DumbMethods.this, bugPattern, NORMAL_PRIORITY).addClassAndMethod(DumbMethods.this)
+                            .addCalledMethod(DumbMethods.this)
+                            .addString("Passing String constant as value that should be null checked").describe(StringAnnotation.STRING_MESSAGE)
+                            .addString((String) o).describe(StringAnnotation.STRING_CONSTANT_ROLE);
+                    if (secondArgument != null) {
+                        bug.addValueSource(secondArgument, DumbMethods.this);
+                    }
+
+                    accumulator.accumulateBug(bug, DumbMethods.this);
+                }
+            }
+
+            if (seen == INVOKESTATIC && ("junit/framework/Assert".equals(getClassConstantOperand()) || "org/junit/Assert".equals(getClassConstantOperand()))
+                    && "assertNotNull".equals(getNameConstantOperand())) {
+                int args = PreorderVisitor.getNumberArguments(getSigConstantOperand());
+
+                OpcodeStack.Item item = stack.getStackItem(0);
+                Object o = item.getConstant();
+                if (o instanceof String) {
+
+                    OpcodeStack.Item secondArgument = null;
+                    String bugPattern = "DMI_DOH";
+                    if (args == 2) {
+                        secondArgument = stack.getStackItem(1);
+                        Object secondConstant = secondArgument.getConstant();
+                        if (!(secondConstant instanceof String)) {
+                            bugPattern = "DMI_ARGUMENTS_WRONG_ORDER";
+                        }
+                    }
+
+                    BugInstance bug = new BugInstance(DumbMethods.this, bugPattern, NORMAL_PRIORITY).addClassAndMethod(DumbMethods.this)
+                            .addCalledMethod(DumbMethods.this).addString("Passing String constant as value that should be null checked").describe(StringAnnotation.STRING_MESSAGE)
+                            .addString((String) o).describe(StringAnnotation.STRING_CONSTANT_ROLE);
+                    if (secondArgument != null) {
+                        bug.addValueSource(secondArgument, DumbMethods.this);
+                    }
+
+                    accumulator.accumulateBug(bug, DumbMethods.this);
+                }
+            }
+        }
+    }
+
+    private class FutilePoolSizeSubDetector extends SubDetector {
+        @Override
+        public void sawOpcode(int seen) {
+            if (seen == INVOKEVIRTUAL && "java/util/concurrent/ScheduledThreadPoolExecutor".equals(getClassConstantOperand())
+                    && "setMaximumPoolSize".equals(getNameConstantOperand())) {
+                accumulator.accumulateBug(new BugInstance(DumbMethods.this,
+                        "DMI_FUTILE_ATTEMPT_TO_CHANGE_MAXPOOL_SIZE_OF_SCHEDULED_THREAD_POOL_EXECUTOR", HIGH_PRIORITY)
+                .addClassAndMethod(DumbMethods.this), DumbMethods.this);
+            }
+        }
+    }
+
+    static int saturatingIncrement(int value) {
+        if (value == Integer.MAX_VALUE) {
+            return Integer.MAX_VALUE;
+        }
+        return value+1;
+    }
+
+    private class RangeCheckSubDetector extends SubDetector {
+
+
+
+        private void checkRange(Item item, Object minValue, Object maxValue, String pattern) {
+            if(!(item.getConstant() instanceof Number)) {
+                return;
+            }
+            int value = ((Number)item.getConstant()).intValue();
+            int intMin = Integer.MIN_VALUE;
+            int intMax = Integer.MAX_VALUE;
+            if(minValue instanceof Number) {
+                intMin = ((Number)minValue).intValue();
+            }
+            if(maxValue instanceof Number) {
+                intMax = ((Number)maxValue).intValue();
+            } else if(maxValue instanceof String) {
+                intMax = ((String)maxValue).length()-1;
+            } else if (maxValue instanceof OpcodeStack.Item){
+                OpcodeStack.Item maxItem = (OpcodeStack.Item ) maxValue;
+                if (maxItem.getSignature().charAt(0) == '[' && maxItem.getConstant() instanceof Integer) {
+                    intMax = ((Integer)maxItem.getConstant())-1;
+
+                }
+            }
+
+            if(value < intMin || value > intMax) {
+                BugInstance bug = new BugInstance(pattern, NORMAL_PRIORITY ).addClassAndMethod(DumbMethods.this).addSourceLine(DumbMethods.this)
+                        .addInt(value).describe(IntAnnotation.INT_VALUE);
+
+                if (intMin <= intMax) {
+                    if (value < intMin) {
+                        bug.addInt(intMin).describe(IntAnnotation.INT_MIN_VALUE);
+                    }
+                    if (value > intMax) {
+                        bug.addInt(intMax) .describe(IntAnnotation.INT_MAX_VALUE);
+                    }
+                }
+
+
+                if (isMethodCall()) {
+                    bug.addCalledMethod(DumbMethods.this);
+                }
+
+
+
+                accumulator.accumulateBug(bug, DumbMethods.this);
+            }
+        }
+
+
+        @Override
+        public void sawOpcode(int seen) {
+            // System.out.printf("%4d %s%n", getPC(), OPCODE_NAMES[seen]);
+            switch(seen) {
+            case IALOAD:
+            case AALOAD:
+            case SALOAD:
+            case CALOAD:
+            case BALOAD:
+            case LALOAD:
+            case DALOAD:
+            case FALOAD: {
+                checkRange(stack.getStackItem(0), 0, stack.getStackItem(1), "RANGE_ARRAY_INDEX");
+                break;
+            }
+            case IASTORE:
+            case AASTORE:
+            case SASTORE:
+            case CASTORE:
+            case BASTORE:
+            case LASTORE:
+            case DASTORE:
+            case FASTORE: {
+
+                checkRange(stack.getStackItem(1), 0,  stack.getStackItem(2), "RANGE_ARRAY_INDEX");
+                break;
+            }
+            case INVOKESTATIC: {
+                MethodDescriptor m = getMethodDescriptorOperand();
+                if(m.getSlashedClassName().equals("java/lang/System") && m.getName().equals("arraycopy")) {
+                    // void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)
+                    Item length = stack.getStackItem(0);
+                    Object constantLength = length.getConstant();
+                    //                    if (constantLength instanceof Number && constantLength.equals(0)) {
+                    //                        break;
+                    //                    }
+                    Item srcPos = stack.getStackItem(3);
+                    Item src = stack.getStackItem(4);
+                    checkRange(srcPos, 0, src, "RANGE_ARRAY_OFFSET");
+                    Item dest =  stack.getStackItem(2);
+                    Item destPos = stack.getStackItem(1);
+                    checkRange(destPos, 0, dest, "RANGE_ARRAY_OFFSET");
+
+                    if(constantLength instanceof Number) {
+                        int length1 = Integer.MAX_VALUE;
+                        if(src.getConstant() instanceof Integer) {
+                            length1 = (int) src.getConstant();
+                        }
+                        if(srcPos.getConstant() instanceof Integer) {
+                            length1 -= (int) srcPos.getConstant();
+                        }
+                        int length2 = Integer.MAX_VALUE;
+                        if(dest.getConstant() instanceof Integer) {
+                            length2 = (int) stack.getStackItem(2).getConstant();
+                        }
+                        if(destPos.getConstant() instanceof Integer) {
+                            length2 -= (int) stack.getStackItem(1).getConstant();
+                        }
+                        checkRange(length, 0, Math.min(length1, length2), "RANGE_ARRAY_LENGTH");
+                    }
+                }
+                break;
+            }
+            case INVOKEVIRTUAL:
+            case INVOKESPECIAL: {
+                MethodDescriptor m = getMethodDescriptorOperand();
+                if(m.getSlashedClassName().equals("java/lang/String")) {
+                    if((m.getName().equals("charAt") || m.getName().equals("codePointAt")) && m.getSignature().startsWith("(I)")) {
+                        checkRange(stack.getStackItem(0), 0, stack.getStackItem(1).getConstant(), "RANGE_STRING_INDEX");
+                    }
+                    if(m.getName().equals("substring") || m.getName().equals("subSequence")) {
+                        int nArgs = getNumberArguments(m.getSignature());
+                        Item thisArg = stack.getStackItem(nArgs);
+                        Item firstArg = stack.getStackItem(nArgs-1);
+                        Object thisConstantValue = thisArg.getConstant();
+                        int maxLength = thisConstantValue instanceof String ? ((String)thisConstantValue).length() : Integer.MAX_VALUE;
+                        checkRange(firstArg, 0,maxLength, "RANGE_STRING_INDEX");
+                        if(nArgs == 2) {
+                            Item secondArg = stack.getStackItem(0);
+                            checkRange(secondArg, firstArg.getConstant() == null ? 0 : firstArg.getConstant(),
+                                    maxLength,
+                                    "RANGE_STRING_INDEX");
+                        }
+                    }
+                }
+                if ((m.getSignature().startsWith("([BII)") || m.getSignature().startsWith("([CII)") || m.getSignature().startsWith("([III)"))
+                        && (((m.getName().equals("write") || m.getName().equals("read")) && m.getSlashedClassName().startsWith(
+                                "java/io/")) || (m.getName().equals("<init>") && m.getSlashedClassName().equals("java/lang/String")))) {
+                    Item arrayArg = stack.getStackItem(2);
+                    Item offsetArg = stack.getStackItem(1);
+                    Item lengthArg = stack.getStackItem(0);
+                    int length = Integer.MAX_VALUE;
+                    if(arrayArg.getConstant() instanceof Integer) {
+                        length = (int) arrayArg.getConstant();
+                    }
+                    if(offsetArg.getConstant() instanceof Integer) {
+                        checkRange(offsetArg, 0, saturatingIncrement(length), "RANGE_ARRAY_OFFSET");
+                        length -= (int) offsetArg.getConstant();
+                    }
+                    checkRange(lengthArg, 0, saturatingIncrement(length), "RANGE_ARRAY_LENGTH");
+                }
+                break;
+            }
+            default:
+                break;
+            }
+        }
+    }
+
+    private class UrlCollectionSubDetector extends SubDetector {
+        @Override
+        public void sawOpcode(int seen) {
+            if ((seen == INVOKEVIRTUAL && "java/util/HashMap".equals(getClassConstantOperand()) && "get".equals(getNameConstantOperand()))
+                    || (seen == INVOKEINTERFACE && "java/util/Map".equals(getClassConstantOperand()) && "get".equals(getNameConstantOperand()))
+                    || (seen == INVOKEVIRTUAL && "java/util/HashSet".equals(getClassConstantOperand()) && "contains".equals(getNameConstantOperand()))
+                    || (seen == INVOKEINTERFACE && "java/util/Set".equals(getClassConstantOperand()) && "contains".equals(getNameConstantOperand()))) {
+                OpcodeStack.Item top = stack.getStackItem(0);
+                if ("Ljava/net/URL;".equals(top.getSignature())) {
+                    accumulator.accumulateBug(new BugInstance(DumbMethods.this, "DMI_COLLECTION_OF_URLS", HIGH_PRIORITY)
+                    .addClassAndMethod(DumbMethods.this), DumbMethods.this);
+                }
+            }
+        }
+    }
+
+    private class VacuousComparisonSubDetector extends SubDetector {
+        @Override
+        public void sawOpcode(int seen) {
+            boolean foundVacuousComparison = false;
+            if (seen == IF_ICMPGT || seen == IF_ICMPLE) {
+                OpcodeStack.Item rhs = stack.getStackItem(0);
+                Object rhsConstant = rhs.getConstant();
+                if (rhsConstant instanceof Integer && ((Integer) rhsConstant).intValue() == Integer.MAX_VALUE) {
+                    foundVacuousComparison = true;
+                }
+                OpcodeStack.Item lhs = stack.getStackItem(1);
+                Object lhsConstant = lhs.getConstant();
+                if (lhsConstant instanceof Integer && ((Integer) lhsConstant).intValue() == Integer.MIN_VALUE) {
+                    foundVacuousComparison = true;
+                }
+
+            }
+            if (seen == IF_ICMPLT || seen == IF_ICMPGE) {
+                OpcodeStack.Item rhs = stack.getStackItem(0);
+                Object rhsConstant = rhs.getConstant();
+                if (rhsConstant instanceof Integer && ((Integer) rhsConstant).intValue() == Integer.MIN_VALUE) {
+                    foundVacuousComparison = true;
+                }
+                OpcodeStack.Item lhs = stack.getStackItem(1);
+                Object lhsConstant = lhs.getConstant();
+                if (lhsConstant instanceof Integer && ((Integer) lhsConstant).intValue() == Integer.MAX_VALUE) {
+                    foundVacuousComparison = true;
+                }
+
+            }
+            if (foundVacuousComparison) {
+                accumulator.accumulateBug(new BugInstance(DumbMethods.this, "INT_VACUOUS_COMPARISON", getBranchOffset() < 0 ? HIGH_PRIORITY
+                        : NORMAL_PRIORITY).addClassAndMethod(DumbMethods.this), DumbMethods.this);
+            }
+        }
+    }
+
+    private class BadCastInEqualsSubDetector extends SubDetector {
+        private boolean isEqualsObject;
+
+        private boolean sawInstanceofCheck;
+
+        private boolean reportedBadCastInEquals;
+
+        @Override
+        public void initMethod(Method method) {
+            isEqualsObject = "equals".equals(getMethodName()) && "(Ljava/lang/Object;)Z".equals(getMethodSig()) && !method.isStatic();
+            sawInstanceofCheck = false;
+            reportedBadCastInEquals = false;
+        }
+
+        @Override
+        public void sawOpcode(int seen) {
+            if (isEqualsObject && !reportedBadCastInEquals) {
+                if (seen == INVOKEVIRTUAL && "isInstance".equals(getNameConstantOperand())
+                        && "java/lang/Class".equals(getClassConstantOperand())) {
+                    OpcodeStack.Item item = stack.getStackItem(0);
+                    if (item.getRegisterNumber() == 1) {
+                        sawInstanceofCheck = true;
+                    }
+                } else if (seen == INSTANCEOF || seen == INVOKEVIRTUAL && "getClass".equals(getNameConstantOperand())
+                        && "()Ljava/lang/Class;".equals(getSigConstantOperand())) {
+                    OpcodeStack.Item item = stack.getStackItem(0);
+                    if (item.getRegisterNumber() == 1) {
+                        sawInstanceofCheck = true;
+                    }
+                } else if (seen == INVOKESPECIAL && "equals".equals(getNameConstantOperand())
+                        && "(Ljava/lang/Object;)Z".equals(getSigConstantOperand())) {
+                    OpcodeStack.Item item0 = stack.getStackItem(0);
+                    OpcodeStack.Item item1 = stack.getStackItem(1);
+                    if (item1.getRegisterNumber() + item0.getRegisterNumber() == 1) {
+                        sawInstanceofCheck = true;
+                    }
+                } else if (seen == CHECKCAST && !sawInstanceofCheck) {
+                    OpcodeStack.Item item = stack.getStackItem(0);
+                    if (item.getRegisterNumber() == 1) {
+                        if (getSizeOfSurroundingTryBlock(getPC()) == Integer.MAX_VALUE) {
+                            accumulator.accumulateBug(new BugInstance(DumbMethods.this, "BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS",
+                                    NORMAL_PRIORITY).addClassAndMethod(DumbMethods.this), DumbMethods.this);
+                        }
+
+                        reportedBadCastInEquals = true;
+                    }
+                }
+            }
+        }
+    }
+
+    private class RandomOnceSubDetector extends SubDetector {
+        private boolean freshRandomOnTos = false;
+
+        private boolean freshRandomOneBelowTos = false;
+
+        @Override
+        public void initMethod(Method method) {
+            freshRandomOnTos = false;
+        }
+
+        @Override
+        public void sawOpcode(int seen) {
+            if (seen == INVOKEVIRTUAL && "java/util/Random".equals(getClassConstantOperand())
+                    && (freshRandomOnTos || freshRandomOneBelowTos)) {
+                accumulator.accumulateBug(new BugInstance(DumbMethods.this, "DMI_RANDOM_USED_ONLY_ONCE", HIGH_PRIORITY)
+                .addClassAndMethod(DumbMethods.this).addCalledMethod(DumbMethods.this), DumbMethods.this);
+
+            }
+            freshRandomOneBelowTos = freshRandomOnTos && isRegisterLoad();
+            freshRandomOnTos = seen == INVOKESPECIAL && "java/util/Random".equals(getClassConstantOperand())
+                    && "<init>".equals(getNameConstantOperand());
+        }
+    }
+
+    private final SubDetector[] subDetectors = new SubDetector[] { new VacuousComparisonSubDetector(),
+            new RangeCheckSubDetector(), new BadCastInEqualsSubDetector(), new FutilePoolSizeSubDetector(),
+            new UrlCollectionSubDetector(), new RandomOnceSubDetector(), new NullMethodsSubDetector(),
+            new InvalidMinMaxSubDetector()};
+
     private static final ObjectType CONDITION_TYPE = ObjectTypeFactory.getInstance("java.util.concurrent.locks.Condition");
 
     private final BugReporter bugReporter;
@@ -97,12 +532,6 @@ public class DumbMethods extends OpcodeStackDetector {
 
     private boolean isPublicStaticVoidMain;
 
-    private boolean isEqualsObject;
-
-    private boolean sawInstanceofCheck;
-
-    private boolean reportedBadCastInEquals;
-
     private int sawCheckForNonNegativeSignedByte;
 
     private int sinceBufferedInputStreamReady;
@@ -136,7 +565,7 @@ public class DumbMethods extends OpcodeStackDetector {
     @Override
     public void visit(JavaClass obj) {
         String superclassName = obj.getSuperclassName();
-        isSynthetic = superclassName.equals("java.rmi.server.RemoteStub");
+        isSynthetic = "java.rmi.server.RemoteStub".equals(superclassName);
         Attribute[] attributes = obj.getAttributes();
         if (attributes != null) {
             for (Attribute a : attributes) {
@@ -177,8 +606,12 @@ public class DumbMethods extends OpcodeStackDetector {
     public void visit(Method method) {
         String cName = getDottedClassName();
 
+        for(SubDetector subDetector : subDetectors) {
+            subDetector.initMethod(method);
+        }
+
         // System.out.println(getFullyQualifiedMethodName());
-        isPublicStaticVoidMain = method.isPublic() && method.isStatic() && getMethodName().equals("main")
+        isPublicStaticVoidMain = method.isPublic() && method.isStatic() && "main".equals(getMethodName())
                 || cName.toLowerCase().indexOf("benchmark") >= 0;
                 prevOpcodeWasReadLine = false;
                 Code code = method.getCode();
@@ -192,10 +625,6 @@ public class DumbMethods extends OpcodeStackDetector {
                 ctorSeen = false;
                 randomNextIntState = 0;
                 checkForBitIorofSignedByte = false;
-                isEqualsObject = getMethodName().equals("equals") && getMethodSig().equals("(Ljava/lang/Object;)Z") && !method.isStatic();
-                sawInstanceofCheck = false;
-                reportedBadCastInEquals = false;
-                freshRandomOnTos = false;
                 sinceBufferedInputStreamReady = 100000;
                 sawCheckForNonNegativeSignedByte = -1000;
                 sawLoadOfMinValue = false;
@@ -209,10 +638,6 @@ public class DumbMethods extends OpcodeStackDetector {
 
     SourceLineAnnotation pendingAbsoluteValueBugSourceLine;
 
-    boolean freshRandomOnTos = false;
-
-    boolean freshRandomOneBelowTos = false;
-
     boolean sawLoadOfMinValue = false;
 
     MethodDescriptor previousMethodCall = null;
@@ -224,23 +649,23 @@ public class DumbMethods extends OpcodeStackDetector {
             MethodDescriptor called = getMethodDescriptorOperand();
 
             if (previousMethodCall != null && !stack.isJumpTarget(getPC())) {
-                if (called.getName().equals("toString")
-                        && called.getClassDescriptor().getClassName().equals("java/lang/Integer")
-                        && previousMethodCall.getName().equals("valueOf")
-                        && previousMethodCall.getSignature().equals("(I)Ljava/lang/Integer;")
+                if ("toString".equals(called.getName())
+                        && "java/lang/Integer".equals(called.getClassDescriptor().getClassName())
+                        && "valueOf".equals(previousMethodCall.getName())
+                        && "(I)Ljava/lang/Integer;".equals(previousMethodCall.getSignature())
                         ) {
                     MethodAnnotation preferred = new MethodAnnotation("java.lang.Integer", "toString", "(I)Ljava/lang/String;", true);
                     BugInstance bug = new BugInstance(this, "DM_BOXED_PRIMITIVE_TOSTRING", HIGH_PRIORITY).addClassAndMethod(this)
                             .addCalledMethod(this).addMethod(preferred).describe(MethodAnnotation.SHOULD_CALL);
                     accumulator.accumulateBug(bug, this);
 
-                }  else if (called.getName().equals("intValue")
-                        && called.getClassDescriptor().getClassName().equals("java/lang/Integer")
-                        && previousMethodCall.getSlashedClassName().equals("java/lang/Integer")
-                        && (previousMethodCall.getName().equals("<init>")
-                                && previousMethodCall.getSignature().equals("(Ljava/lang/String;)V")
-                                || previousMethodCall.getName().equals("valueOf")
-                                && previousMethodCall.getSignature().equals("(Ljava/lang/String;)Ljava/lang/Integer;")
+                }  else if ("intValue".equals(called.getName())
+                        && "java/lang/Integer".equals(called.getClassDescriptor().getClassName())
+                        && "java/lang/Integer".equals(previousMethodCall.getSlashedClassName())
+                        && ("<init>".equals(previousMethodCall.getName())
+                                && "(Ljava/lang/String;)V".equals(previousMethodCall.getSignature())
+                                || "valueOf".equals(previousMethodCall.getName())
+                                && "(Ljava/lang/String;)Ljava/lang/Integer;".equals(previousMethodCall.getSignature())
                                 )) {
 
                     MethodAnnotation preferred = new MethodAnnotation("java.lang.Integer", "parseInt", "(Ljava/lang/String;)I", true);
@@ -248,19 +673,46 @@ public class DumbMethods extends OpcodeStackDetector {
                     BugInstance bug = new BugInstance(this, "DM_BOXED_PRIMITIVE_FOR_PARSING", HIGH_PRIORITY).addClassAndMethod(this)
                             .addCalledMethod(this).addMethod(preferred).describe(MethodAnnotation.SHOULD_CALL);
                     accumulator.accumulateBug(bug, this);
-                }  else if (called.getName().equals("longValue")
-                        && called.getClassDescriptor().getClassName().equals("java/lang/Long")
-                        && previousMethodCall.getSlashedClassName().equals("java/lang/Long")
-                        && ( previousMethodCall.getName().equals("<init>")
-                                && previousMethodCall.getSignature().equals("(Ljava/lang/String;)V")
-                                ||  previousMethodCall.getName().equals("valueOf")
-                                && previousMethodCall.getSignature().equals("(Ljava/lang/String;)Ljava/lang/Long;"))
+                }  else if ("longValue".equals(called.getName())
+                        && "java/lang/Long".equals(called.getClassDescriptor().getClassName())
+                        && "java/lang/Long".equals(previousMethodCall.getSlashedClassName())
+                        && ( "<init>".equals(previousMethodCall.getName())
+                                && "(Ljava/lang/String;)V".equals(previousMethodCall.getSignature())
+                                ||  "valueOf".equals(previousMethodCall.getName())
+                                && "(Ljava/lang/String;)Ljava/lang/Long;".equals(previousMethodCall.getSignature()))
                         ) {
                     MethodAnnotation preferred = new MethodAnnotation("java.lang.Long", "parseLong", "(Ljava/lang/String;)J", true);
 
                     BugInstance bug = new BugInstance(this, "DM_BOXED_PRIMITIVE_FOR_PARSING", HIGH_PRIORITY).addClassAndMethod(this)
                             .addCalledMethod(this).addMethod(preferred).describe(MethodAnnotation.SHOULD_CALL);
                     accumulator.accumulateBug(bug, this);
+                } else if("compareTo".equals(called.getName())
+                        && "valueOf".equals(previousMethodCall.getName())
+                        && called.getClassDescriptor().equals(previousMethodCall.getClassDescriptor()) && !previousMethodCall.getSignature().startsWith("(Ljava/lang/String;")
+                        ) {
+                    String primitiveType = ClassName.getPrimitiveType(called.getClassDescriptor().getClassName());
+                    XMethod rvo = stack.getStackItem(1).getReturnValueOf();
+                    XField field = stack.getStackItem(1).getXField();
+                    String signature;
+                    if (rvo != null) {
+                        signature = new SignatureParser(rvo.getSignature()).getReturnTypeSignature();
+                    } else if (field != null) {
+                        signature = field.getSignature();
+                    } else {
+                        signature = "";
+                    }
+                    if (primitiveType != null
+                            && (previousMethodCall.equals(rvo) || signature.equals(primitiveType))
+                            && (getThisClass().getMajor() >= MAJOR_1_7 || getThisClass().getMajor() >= MAJOR_1_4
+                            && (primitiveType.equals("D") || primitiveType.equals("F")))) {
+                        MethodDescriptor shouldCall = new MethodDescriptor(called.getClassDescriptor().getClassName(), "compare",
+                                "(" + primitiveType + primitiveType + ")I", true);
+                        BugInstance bug = new BugInstance(this, "DM_BOXED_PRIMITIVE_FOR_COMPARE",
+                                primitiveType.equals("Z") ? LOW_PRIORITY : primitiveType.equals("B") ? NORMAL_PRIORITY
+                                        : HIGH_PRIORITY).addClassAndMethod(this).addCalledMethod(this).addMethod(shouldCall)
+                                        .describe(MethodAnnotation.SHOULD_CALL);
+                        accumulator.accumulateBug(bug, this);
+                    }
                 }
             }
             previousMethodCall = called;
@@ -314,9 +766,8 @@ public class DumbMethods extends OpcodeStackDetector {
                 XMethod returnValueOf = item0.getReturnValueOf();
                 if (constant1 instanceof Integer
                         && returnValueOf != null
-                        && returnValueOf.getName().equals("getYear")
-                        && (returnValueOf.getClassName().equals("java.util.Date") || returnValueOf.getClassName().equals(
-                                "java.sql.Date"))) {
+                        && "getYear".equals(returnValueOf.getName())
+                        && ("java.util.Date".equals(returnValueOf.getClassName()) || "java.sql.Date".equals(returnValueOf.getClassName()))) {
                     int year = (Integer) constant1;
                     if (testingEnabled && year > 1900) {
                         accumulator.accumulateBug(
@@ -366,84 +817,21 @@ public class DumbMethods extends OpcodeStackDetector {
         }
 
         if (seen == INVOKESTATIC
-                && getClassConstantOperand().equals("org/easymock/EasyMock")
-                && (getNameConstantOperand().equals("replay") || getNameConstantOperand().equals("verify") || getNameConstantOperand()
-                        .startsWith("reset")) && getSigConstantOperand().equals("([Ljava/lang/Object;)V")
+                && "org/easymock/EasyMock".equals(getClassConstantOperand())
+                && ("replay".equals(getNameConstantOperand()) || "verify".equals(getNameConstantOperand()) || getNameConstantOperand()
+                        .startsWith("reset")) && "([Ljava/lang/Object;)V".equals(getSigConstantOperand())
                         && getPrevOpcode(1) == ANEWARRAY && getPrevOpcode(2) == ICONST_0) {
             accumulator.accumulateBug(new BugInstance(this, "DMI_VACUOUS_CALL_TO_EASYMOCK_METHOD", NORMAL_PRIORITY)
             .addClassAndMethod(this).addCalledMethod(this), this);
         }
 
-        if (seen == INVOKESTATIC && (getClassConstantOperand().equals("com/google/common/base/Preconditions")
-                && getNameConstantOperand().equals("checkNotNull")
-                || getClassConstantOperand().equals("com/google/common/base/Strings")
-                && (getNameConstantOperand().equals("nullToEmpty") ||
-                        getNameConstantOperand().equals("emptyToNull") ||
-                        getNameConstantOperand().equals("isNullOrEmpty")))
-                ) {
-            int args = PreorderVisitor.getNumberArguments(getSigConstantOperand());
-
-            OpcodeStack.Item item = stack.getStackItem(args - 1);
-            Object o = item.getConstant();
-            if (o instanceof String) {
-
-                OpcodeStack.Item secondArgument = null;
-                String bugPattern = "DMI_DOH";
-                if (args > 1) {
-                    secondArgument = stack.getStackItem(args - 2);
-                    Object secondConstant = secondArgument.getConstant();
-                    if (!(secondConstant instanceof String)) {
-                        bugPattern = "DMI_ARGUMENTS_WRONG_ORDER";
-                    }
-                }
-
-                BugInstance bug = new BugInstance(this, bugPattern, NORMAL_PRIORITY).addClassAndMethod(this)
-                        .addCalledMethod(this)
-                        .addString("Passing String constant as value that should be null checked").describe(StringAnnotation.STRING_MESSAGE)
-                        .addString((String) o).describe(StringAnnotation.STRING_CONSTANT_ROLE);
-                if (secondArgument != null) {
-                    bug.addValueSource(secondArgument, this);
-                }
-
-                accumulator.accumulateBug(bug, this);
-            }
-        }
-
-        if (seen == INVOKESTATIC && getClassConstantOperand().equals("junit/framework/Assert")
-                && getNameConstantOperand().equals("assertNotNull")) {
-            int args = PreorderVisitor.getNumberArguments(getSigConstantOperand());
-
-            OpcodeStack.Item item = stack.getStackItem(0);
-            Object o = item.getConstant();
-            if (o instanceof String) {
-
-                OpcodeStack.Item secondArgument = null;
-                String bugPattern = "DMI_DOH";
-                if (args == 2) {
-                    secondArgument = stack.getStackItem(1);
-                    Object secondConstant = secondArgument.getConstant();
-                    if (!(secondConstant instanceof String)) {
-                        bugPattern = "DMI_ARGUMENTS_WRONG_ORDER";
-                    }
-                }
-
-                BugInstance bug = new BugInstance(this, bugPattern, NORMAL_PRIORITY).addClassAndMethod(this)
-                        .addCalledMethod(this).addString("Passing String constant as value that should be null checked").describe(StringAnnotation.STRING_MESSAGE)
-                        .addString((String) o).describe(StringAnnotation.STRING_CONSTANT_ROLE);
-                if (secondArgument != null) {
-                    bug.addValueSource(secondArgument, this);
-                }
-
-                accumulator.accumulateBug(bug, this);
-            }
-        }
         if ((seen == INVOKESTATIC || seen == INVOKEVIRTUAL || seen == INVOKESPECIAL || seen == INVOKEINTERFACE)
                 && getSigConstantOperand().indexOf("Ljava/lang/Runnable;") >= 0) {
             SignatureParser parser = new SignatureParser(getSigConstantOperand());
             int count = 0;
             for (Iterator<String> i = parser.parameterSignatureIterator(); i.hasNext(); count++) {
                 String parameter = i.next();
-                if (parameter.equals("Ljava/lang/Runnable;")) {
+                if ("Ljava/lang/Runnable;".equals(parameter)) {
                     OpcodeStack.Item item = stack.getStackItem(parser.getNumParameters() - 1 - count);
                     if ("Ljava/lang/Thread;".equals(item.getSignature())) {
                         accumulator.accumulateBug(new BugInstance(this, "DMI_THREAD_PASSED_WHERE_RUNNABLE_EXPECTED",
@@ -455,39 +843,12 @@ public class DumbMethods extends OpcodeStackDetector {
 
         }
 
-        if (prevOpcode == I2L && seen == INVOKESTATIC && getClassConstantOperand().equals("java/lang/Double")
-                && getNameConstantOperand().equals("longBitsToDouble")) {
+        if (prevOpcode == I2L && seen == INVOKESTATIC && "java/lang/Double".equals(getClassConstantOperand())
+                && "longBitsToDouble".equals(getNameConstantOperand())) {
             accumulator.accumulateBug(new BugInstance(this, "DMI_LONG_BITS_TO_DOUBLE_INVOKED_ON_INT", HIGH_PRIORITY)
             .addClassAndMethod(this).addCalledMethod(this), this);
         }
 
-        if (seen == INVOKEVIRTUAL && getClassConstantOperand().equals("java/util/Random")
-                && (freshRandomOnTos || freshRandomOneBelowTos)) {
-            accumulator.accumulateBug(new BugInstance(this, "DMI_RANDOM_USED_ONLY_ONCE", HIGH_PRIORITY).addClassAndMethod(this)
-                    .addCalledMethod(this), this);
-
-        }
-
-        freshRandomOneBelowTos = freshRandomOnTos && isRegisterLoad();
-        freshRandomOnTos = seen == INVOKESPECIAL && getClassConstantOperand().equals("java/util/Random")
-                && getNameConstantOperand().equals("<init>");
-
-        if ((seen == INVOKEVIRTUAL && getClassConstantOperand().equals("java/util/HashMap") && getNameConstantOperand().equals(
-                "get"))
-                || (seen == INVOKEINTERFACE && getClassConstantOperand().equals("java/util/Map") && getNameConstantOperand()
-                .equals("get"))
-                || (seen == INVOKEVIRTUAL && getClassConstantOperand().equals("java/util/HashSet") && getNameConstantOperand()
-                .equals("contains"))
-                || (seen == INVOKEINTERFACE && getClassConstantOperand().equals("java/util/Set") && getNameConstantOperand()
-                .equals("contains"))) {
-            OpcodeStack.Item top = stack.getStackItem(0);
-            if (top.getSignature().equals("Ljava/net/URL;")) {
-                accumulator.accumulateBug(new BugInstance(this, "DMI_COLLECTION_OF_URLS", HIGH_PRIORITY).addClassAndMethod(this),
-                        this);
-            }
-
-        }
-
         /**
          * Since you can change the number of core threads for a scheduled
          * thread pool executor, disabling this for now
@@ -505,81 +866,12 @@ public class DumbMethods extends OpcodeStackDetector {
 
         }
          */
-        if (seen == INVOKEVIRTUAL && getClassConstantOperand().equals("java/util/concurrent/ScheduledThreadPoolExecutor")
-                && getNameConstantOperand().equals("setMaximumPoolSize")) {
-            accumulator.accumulateBug(new BugInstance(this,
-                    "DMI_FUTILE_ATTEMPT_TO_CHANGE_MAXPOOL_SIZE_OF_SCHEDULED_THREAD_POOL_EXECUTOR", HIGH_PRIORITY)
-            .addClassAndMethod(this), this);
-        }
-        if (isEqualsObject && !reportedBadCastInEquals) {
-            if (seen == INVOKEVIRTUAL && getNameConstantOperand().equals("isInstance")
-                    && getClassConstantOperand().equals("java/lang/Class")) {
-                OpcodeStack.Item item = stack.getStackItem(0);
-                if (item.getRegisterNumber() == 1) {
-                    sawInstanceofCheck = true;
-                }
-            } else if (seen == INSTANCEOF || seen == INVOKEVIRTUAL && getNameConstantOperand().equals("getClass")
-                    && getSigConstantOperand().equals("()Ljava/lang/Class;")) {
-                OpcodeStack.Item item = stack.getStackItem(0);
-                if (item.getRegisterNumber() == 1) {
-                    sawInstanceofCheck = true;
-                }
-            } else if (seen == INVOKESPECIAL && getNameConstantOperand().equals("equals")
-                    && getSigConstantOperand().equals("(Ljava/lang/Object;)Z")) {
-                OpcodeStack.Item item0 = stack.getStackItem(0);
-                OpcodeStack.Item item1 = stack.getStackItem(1);
-                if (item1.getRegisterNumber() + item0.getRegisterNumber() == 1) {
-                    sawInstanceofCheck = true;
-                }
-            } else if (seen == CHECKCAST && !sawInstanceofCheck) {
-                OpcodeStack.Item item = stack.getStackItem(0);
-                if (item.getRegisterNumber() == 1) {
-                    if (getSizeOfSurroundingTryBlock(getPC()) == Integer.MAX_VALUE) {
-                        accumulator.accumulateBug(new BugInstance(this, "BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS",
-                                NORMAL_PRIORITY).addClassAndMethod(this), this);
-                    }
-
-                    reportedBadCastInEquals = true;
-                }
-            }
-        }
-        {
-            boolean foundVacuousComparison = false;
-            if (seen == IF_ICMPGT || seen == IF_ICMPLE) {
-                OpcodeStack.Item rhs = stack.getStackItem(0);
-                Object rhsConstant = rhs.getConstant();
-                if (rhsConstant instanceof Integer && ((Integer) rhsConstant).intValue() == Integer.MAX_VALUE) {
-                    foundVacuousComparison = true;
-                }
-                OpcodeStack.Item lhs = stack.getStackItem(1);
-                Object lhsConstant = lhs.getConstant();
-                if (lhsConstant instanceof Integer && ((Integer) lhsConstant).intValue() == Integer.MIN_VALUE) {
-                    foundVacuousComparison = true;
-                }
-
-            }
-            if (seen == IF_ICMPLT || seen == IF_ICMPGE) {
-                OpcodeStack.Item rhs = stack.getStackItem(0);
-                Object rhsConstant = rhs.getConstant();
-                if (rhsConstant instanceof Integer && ((Integer) rhsConstant).intValue() == Integer.MIN_VALUE) {
-                    foundVacuousComparison = true;
-                }
-                OpcodeStack.Item lhs = stack.getStackItem(1);
-                Object lhsConstant = lhs.getConstant();
-                if (lhsConstant instanceof Integer && ((Integer) lhsConstant).intValue() == Integer.MAX_VALUE) {
-                    foundVacuousComparison = true;
-                }
-
-            }
-            if (foundVacuousComparison) {
-                accumulator.accumulateBug(new BugInstance(this, "INT_VACUOUS_COMPARISON", getBranchOffset() < 0 ? HIGH_PRIORITY
-                        : NORMAL_PRIORITY).addClassAndMethod(this), this);
-            }
-
+        for(SubDetector subDetector : subDetectors) {
+            subDetector.sawOpcode(seen);
         }
 
         if (!sawLoadOfMinValue && seen == INVOKESTATIC &&
-                ClassName.isMathClass(getClassConstantOperand()) && getNameConstantOperand().equals("abs")
+                ClassName.isMathClass(getClassConstantOperand()) && "abs".equals(getNameConstantOperand())
                 ) {
             OpcodeStack.Item item0 = stack.getStackItem(0);
             int special = item0.getSpecialKind();
@@ -725,14 +1017,14 @@ public class DumbMethods extends OpcodeStackDetector {
                             }
 
                             accumulator.accumulateBug(new BugInstance(this, "INT_BAD_COMPARISON_WITH_SIGNED_BYTE", priority)
-                            .addClassAndMethod(this).addInt(v1).describe(IntAnnotation.INT_VALUE), this);
+                            .addClassAndMethod(this).addInt(v1).describe(IntAnnotation.INT_VALUE).addValueSource(item0, this), this);
 
                         }
                     } else if (item0.getSpecialKind() == OpcodeStack.Item.NON_NEGATIVE && constant1 instanceof Number) {
                         int v1 = ((Number) constant1).intValue();
                         if (v1 < 0) {
                             accumulator.accumulateBug(new BugInstance(this, "INT_BAD_COMPARISON_WITH_NONNEGATIVE_VALUE",
-                                    HIGH_PRIORITY).addClassAndMethod(this).addInt(v1).describe(IntAnnotation.INT_VALUE), this);
+                                    HIGH_PRIORITY).addClassAndMethod(this).addInt(v1).describe(IntAnnotation.INT_VALUE).addValueSource(item0, this), this);
                         }
 
                     }
@@ -741,6 +1033,54 @@ public class DumbMethods extends OpcodeStackDetector {
             }
 
             switch (seen) {
+            case IFGE:
+            case IFLT:
+                if(stack.getStackDepth() > 0 && stack.getStackItem(0).getSpecialKind() == OpcodeStack.Item.NON_NEGATIVE) {
+                    OpcodeStack.Item top = stack.getStackItem(0);
+                    if (top.getRegisterNumber() != -1 && getMaxPC() > getNextPC() + 6) {
+                        if (false) {
+                            for(int i = -2; i <= 0; i++) {
+                                int o = getPrevOpcode(-i);
+                                System.out.printf("%2d %3d  %2x %s%n",  i, o, o, OPCODE_NAMES[o]);
+                            }
+                            for(int i = 0; i < 7; i++) {
+                                int o = getNextCodeByte(i);
+                                System.out.printf("%2d %3d %2x %s%n",  i, o, o, OPCODE_NAMES[o]);
+
+                            }
+                        }
+                        int jump1, jump2;
+                        if (seen == IFGE) {
+                            jump1 = IF_ICMPLT;
+                            jump2 = IF_ICMPLE;
+                        } else {
+                            jump1 = IF_ICMPGE;
+                            jump2 = IF_ICMPGT;
+                        }
+                        int nextCodeByte0 = getNextCodeByte(0);
+                        int loadConstant = 1;
+                        if (nextCodeByte0 == ILOAD) {
+                            loadConstant = 2;
+                        }
+                        int nextCodeByte1 = getNextCodeByte(loadConstant);
+                        int nextCodeByte2 = getNextCodeByte(loadConstant+1);
+                        int nextJumpOffset = loadConstant+2;
+                        if (nextCodeByte1 == SIPUSH) {
+                            nextJumpOffset++;
+                        }
+                        int nextCodeByteJump = getNextCodeByte(nextJumpOffset);
+
+                        if (nextCodeByte0 == getPrevOpcode(1)
+                                && (nextCodeByte1 == BIPUSH || nextCodeByte1 == SIPUSH)
+                                && (IF_ICMPLT <= nextCodeByteJump && nextCodeByteJump <= IF_ICMPLE))
+                        {
+                            break;
+                        }
+                    }
+                    accumulator.accumulateBug(new BugInstance(this, "INT_BAD_COMPARISON_WITH_NONNEGATIVE_VALUE",
+                            NORMAL_PRIORITY).addClassAndMethod(this).addInt(0).describe(IntAnnotation.INT_VALUE).addValueSource(top, this), this);
+                }
+                break;
             case IAND:
             case LAND:
             case IOR:
@@ -784,29 +1124,29 @@ public class DumbMethods extends OpcodeStackDetector {
             }
 
             if (prevOpcodeWasReadLine && sinceBufferedInputStreamReady >= 100 && seen == INVOKEVIRTUAL
-                    && getClassConstantOperand().equals("java/lang/String") && getSigConstantOperand().startsWith("()")) {
+                    && "java/lang/String".equals(getClassConstantOperand()) && getSigConstantOperand().startsWith("()")) {
                 accumulator.accumulateBug(
                         new BugInstance(this, "NP_IMMEDIATE_DEREFERENCE_OF_READLINE", NORMAL_PRIORITY).addClassAndMethod(this),
                         this);
             }
 
-            if (seen == INVOKEVIRTUAL && getClassConstantOperand().equals("java/io/BufferedReader")
-                    && getNameConstantOperand().equals("ready") && getSigConstantOperand().equals("()Z")) {
+            if (seen == INVOKEVIRTUAL && "java/io/BufferedReader".equals(getClassConstantOperand())
+                    && "ready".equals(getNameConstantOperand()) && "()Z".equals(getSigConstantOperand())) {
                 sinceBufferedInputStreamReady = 0;
             } else {
                 sinceBufferedInputStreamReady++;
             }
 
             prevOpcodeWasReadLine = (seen == INVOKEVIRTUAL || seen == INVOKEINTERFACE)
-                    && getNameConstantOperand().equals("readLine") && getSigConstantOperand().equals("()Ljava/lang/String;");
+                    && "readLine".equals(getNameConstantOperand()) && "()Ljava/lang/String;".equals(getSigConstantOperand());
 
             // System.out.println(randomNextIntState + " " + OPCODE_NAMES[seen]
             // + " " + getMethodName());
             switch (randomNextIntState) {
             case 0:
-                if (seen == INVOKEVIRTUAL && getClassConstantOperand().equals("java/util/Random")
-                && getNameConstantOperand().equals("nextDouble") || seen == INVOKESTATIC
-                && ClassName.isMathClass(getClassConstantOperand()) && getNameConstantOperand().equals("random")) {
+                if (seen == INVOKEVIRTUAL && "java/util/Random".equals(getClassConstantOperand())
+                && "nextDouble".equals(getNameConstantOperand()) || seen == INVOKESTATIC
+                && ClassName.isMathClass(getClassConstantOperand()) && "random".equals(getNameConstantOperand())) {
                     randomNextIntState = 1;
                 }
                 break;
@@ -853,9 +1193,8 @@ public class DumbMethods extends OpcodeStackDetector {
             if (isPublicStaticVoidMain
                     && seen == INVOKEVIRTUAL
                     && getClassConstantOperand().startsWith("javax/swing/")
-                    && (getNameConstantOperand().equals("show") && getSigConstantOperand().equals("()V")
-                            || getNameConstantOperand().equals("pack") && getSigConstantOperand().equals("()V") || getNameConstantOperand()
-                            .equals("setVisible") && getSigConstantOperand().equals("(Z)V"))) {
+                    && ("show".equals(getNameConstantOperand()) && "()V".equals(getSigConstantOperand())
+                            || "pack".equals(getNameConstantOperand()) && "()V".equals(getSigConstantOperand()) || "setVisible".equals(getNameConstantOperand()) && "(Z)V".equals(getSigConstantOperand()))) {
                 accumulator.accumulateBug(
                         new BugInstance(this, "SW_SWING_METHODS_INVOKED_IN_SWING_THREAD", LOW_PRIORITY).addClassAndMethod(this),
                         this);
@@ -878,8 +1217,8 @@ public class DumbMethods extends OpcodeStackDetector {
             // }
             // }
 
-            if ((seen == INVOKEVIRTUAL) && getNameConstantOperand().equals("isAnnotationPresent")
-                    && getSigConstantOperand().equals("(Ljava/lang/Class;)Z") && stack.getStackDepth() > 0) {
+            if ((seen == INVOKEVIRTUAL) && "isAnnotationPresent".equals(getNameConstantOperand())
+                    && "(Ljava/lang/Class;)Z".equals(getSigConstantOperand()) && stack.getStackDepth() > 0) {
                 OpcodeStack.Item item = stack.getStackItem(0);
                 Object value = item.getConstant();
                 if (value instanceof String) {
@@ -897,9 +1236,9 @@ public class DumbMethods extends OpcodeStackDetector {
                 }
 
             }
-            if ((seen == INVOKEVIRTUAL) && getNameConstantOperand().equals("next")
-                    && getSigConstantOperand().equals("()Ljava/lang/Object;") && getMethodName().equals("hasNext")
-                    && getMethodSig().equals("()Z") && stack.getStackDepth() > 0) {
+            if ((seen == INVOKEVIRTUAL) && "next".equals(getNameConstantOperand())
+                    && "()Ljava/lang/Object;".equals(getSigConstantOperand()) && "hasNext".equals(getMethodName())
+                    && "()Z".equals(getMethodSig()) && stack.getStackDepth() > 0) {
                 OpcodeStack.Item item = stack.getStackItem(0);
 
                 accumulator.accumulateBug(new BugInstance(this, "DMI_CALLING_NEXT_FROM_HASNEXT", item.isInitialParameter()
@@ -908,32 +1247,32 @@ public class DumbMethods extends OpcodeStackDetector {
 
             }
 
-            if ((seen == INVOKESPECIAL) && getClassConstantOperand().equals("java/lang/String")
-                    && getNameConstantOperand().equals("<init>") && getSigConstantOperand().equals("(Ljava/lang/String;)V")
+            if ((seen == INVOKESPECIAL) && "java/lang/String".equals(getClassConstantOperand())
+                    && "<init>".equals(getNameConstantOperand()) && "(Ljava/lang/String;)V".equals(getSigConstantOperand())
                     && !Subtypes2.isJSP(getThisClass())) {
 
                 accumulator.accumulateBug(new BugInstance(this, "DM_STRING_CTOR", NORMAL_PRIORITY).addClassAndMethod(this), this);
 
             }
 
-            if (seen == INVOKESTATIC && getClassConstantOperand().equals("java/lang/System")
-                    && getNameConstantOperand().equals("runFinalizersOnExit") || seen == INVOKEVIRTUAL
-                    && getClassConstantOperand().equals("java/lang/Runtime")
-                    && getNameConstantOperand().equals("runFinalizersOnExit")) {
+            if (seen == INVOKESTATIC && "java/lang/System".equals(getClassConstantOperand())
+                    && "runFinalizersOnExit".equals(getNameConstantOperand()) || seen == INVOKEVIRTUAL
+                    && "java/lang/Runtime".equals(getClassConstantOperand())
+                    && "runFinalizersOnExit".equals(getNameConstantOperand())) {
                 accumulator.accumulateBug(
                         new BugInstance(this, "DM_RUN_FINALIZERS_ON_EXIT", HIGH_PRIORITY).addClassAndMethod(this), this);
             }
 
-            if ((seen == INVOKESPECIAL) && getClassConstantOperand().equals("java/lang/String")
-                    && getNameConstantOperand().equals("<init>") && getSigConstantOperand().equals("()V")) {
+            if ((seen == INVOKESPECIAL) && "java/lang/String".equals(getClassConstantOperand())
+                    && "<init>".equals(getNameConstantOperand()) && "()V".equals(getSigConstantOperand())) {
 
                 accumulator.accumulateBug(new BugInstance(this, "DM_STRING_VOID_CTOR", NORMAL_PRIORITY).addClassAndMethod(this),
                         this);
 
             }
 
-            if (!isPublicStaticVoidMain && seen == INVOKESTATIC && getClassConstantOperand().equals("java/lang/System")
-                    && getNameConstantOperand().equals("exit") && !getMethodName().equals("processWindowEvent")
+            if (!isPublicStaticVoidMain && seen == INVOKESTATIC && "java/lang/System".equals(getClassConstantOperand())
+                    && "exit".equals(getNameConstantOperand()) && !"processWindowEvent".equals(getMethodName())
                     && !getMethodName().startsWith("windowClos") && getMethodName().indexOf("exit") == -1
                     && getMethodName().indexOf("Exit") == -1 && getMethodName().indexOf("crash") == -1
                     && getMethodName().indexOf("Crash") == -1 && getMethodName().indexOf("die") == -1
@@ -941,10 +1280,9 @@ public class DumbMethods extends OpcodeStackDetector {
                 accumulator.accumulateBug(new BugInstance(this, "DM_EXIT", getMethod().isStatic() ? LOW_PRIORITY
                         : NORMAL_PRIORITY).addClassAndMethod(this), SourceLineAnnotation.fromVisitedInstruction(this));
             }
-            if (((seen == INVOKESTATIC && getClassConstantOperand().equals("java/lang/System")) || (seen == INVOKEVIRTUAL && getClassConstantOperand()
-                    .equals("java/lang/Runtime")))
-                    && getNameConstantOperand().equals("gc")
-                    && getSigConstantOperand().equals("()V")
+            if (((seen == INVOKESTATIC && "java/lang/System".equals(getClassConstantOperand())) || (seen == INVOKEVIRTUAL && "java/lang/Runtime".equals(getClassConstantOperand())))
+                    && "gc".equals(getNameConstantOperand())
+                    && "()V".equals(getSigConstantOperand())
                     && !getDottedClassName().startsWith("java.lang")
                     && !getMethodName().startsWith("gc") && !getMethodName().endsWith("gc")) {
                 if (gcInvocationBugReport == null) {
@@ -965,8 +1303,8 @@ public class DumbMethods extends OpcodeStackDetector {
                     // System.out.println("GC invocation at pc " + PC);
                 }
             }
-            if (!isSynthetic && (seen == INVOKESPECIAL) && getClassConstantOperand().equals("java/lang/Boolean")
-                    && getNameConstantOperand().equals("<init>") && !getClassName().equals("java/lang/Boolean")) {
+            if (!isSynthetic && (seen == INVOKESPECIAL) && "java/lang/Boolean".equals(getClassConstantOperand())
+                    && "<init>".equals(getNameConstantOperand()) && !"java/lang/Boolean".equals(getClassName())) {
                 int majorVersion = getThisClass().getMajor();
                 if (majorVersion >= MAJOR_1_4) {
                     accumulator.accumulateBug(new BugInstance(this, "DM_BOOLEAN_CTOR", NORMAL_PRIORITY).addClassAndMethod(this),
@@ -974,27 +1312,27 @@ public class DumbMethods extends OpcodeStackDetector {
                 }
 
             }
-            if ((seen == INVOKESTATIC) && getClassConstantOperand().equals("java/lang/System")
-                    && (getNameConstantOperand().equals("currentTimeMillis") || getNameConstantOperand().equals("nanoTime"))) {
+            if ((seen == INVOKESTATIC) && "java/lang/System".equals(getClassConstantOperand())
+                    && ("currentTimeMillis".equals(getNameConstantOperand()) || "nanoTime".equals(getNameConstantOperand()))) {
                 sawCurrentTimeMillis = true;
             }
-            if ((seen == INVOKEVIRTUAL) && getClassConstantOperand().equals("java/lang/String")
-                    && getNameConstantOperand().equals("toString") && getSigConstantOperand().equals("()Ljava/lang/String;")) {
+            if ((seen == INVOKEVIRTUAL) && "java/lang/String".equals(getClassConstantOperand())
+                    && "toString".equals(getNameConstantOperand()) && "()Ljava/lang/String;".equals(getSigConstantOperand())) {
 
                 accumulator
                 .accumulateBug(new BugInstance(this, "DM_STRING_TOSTRING", LOW_PRIORITY).addClassAndMethod(this), this);
 
             }
 
-            if ((seen == INVOKEVIRTUAL) && getClassConstantOperand().equals("java/lang/String")
-                    && (getNameConstantOperand().equals("toUpperCase") || getNameConstantOperand().equals("toLowerCase"))
-                    && getSigConstantOperand().equals("()Ljava/lang/String;")) {
+            if ((seen == INVOKEVIRTUAL) && "java/lang/String".equals(getClassConstantOperand())
+                    && ("toUpperCase".equals(getNameConstantOperand()) || "toLowerCase".equals(getNameConstantOperand()))
+                    && "()Ljava/lang/String;".equals(getSigConstantOperand())) {
 
                 accumulator.accumulateBug(new BugInstance(this, "DM_CONVERT_CASE", LOW_PRIORITY).addClassAndMethod(this), this);
 
             }
 
-            if ((seen == INVOKESPECIAL) && getNameConstantOperand().equals("<init>")) {
+            if ((seen == INVOKESPECIAL) && "<init>".equals(getNameConstantOperand())) {
                 String cls = getClassConstantOperand();
                 String sig = getSigConstantOperand();
                 String primitiveType = ClassName.getPrimitiveType(cls);
@@ -1003,9 +1341,9 @@ public class DumbMethods extends OpcodeStackDetector {
                 } else {
                     primitiveObjCtorSeen = null;
                 }
-            } else if ((primitiveObjCtorSeen != null) && (seen == INVOKEVIRTUAL) && getNameConstantOperand().equals("toString")
+            } else if ((primitiveObjCtorSeen != null) && (seen == INVOKEVIRTUAL) && "toString".equals(getNameConstantOperand())
                     && getClassConstantOperand().equals(primitiveObjCtorSeen)
-                    && getSigConstantOperand().equals("()Ljava/lang/String;")) {
+                    && "()Ljava/lang/String;".equals(getSigConstantOperand())) {
                 BugInstance bug = new BugInstance(this, "DM_BOXED_PRIMITIVE_TOSTRING", NORMAL_PRIORITY).addClassAndMethod(this).addCalledMethod(this);
                 MethodAnnotation preferred = new MethodAnnotation(ClassName.toDottedClassName(primitiveObjCtorSeen),
                         "toString", "("+ClassName.getPrimitiveType(primitiveObjCtorSeen)+")Ljava/lang/String;", true);
@@ -1018,10 +1356,10 @@ public class DumbMethods extends OpcodeStackDetector {
                 primitiveObjCtorSeen = null;
             }
 
-            if ((seen == INVOKESPECIAL) && getNameConstantOperand().equals("<init>")) {
+            if ((seen == INVOKESPECIAL) && "<init>".equals(getNameConstantOperand())) {
                 ctorSeen = true;
-            } else if (ctorSeen && (seen == INVOKEVIRTUAL) && getClassConstantOperand().equals("java/lang/Object")
-                    && getNameConstantOperand().equals("getClass") && getSigConstantOperand().equals("()Ljava/lang/Class;")) {
+            } else if (ctorSeen && (seen == INVOKEVIRTUAL) && "java/lang/Object".equals(getClassConstantOperand())
+                    && "getClass".equals(getNameConstantOperand()) && "()Ljava/lang/Class;".equals(getSigConstantOperand())) {
                 accumulator.accumulateBug(new BugInstance(this, "DM_NEW_FOR_GETCLASS", NORMAL_PRIORITY).addClassAndMethod(this),
                         this);
                 ctorSeen = false;
@@ -1033,13 +1371,13 @@ public class DumbMethods extends OpcodeStackDetector {
                 checkMonitorWait();
             }
 
-            if ((seen == INVOKESPECIAL) && getNameConstantOperand().equals("<init>")
-                    && getClassConstantOperand().equals("java/lang/Thread")) {
+            if ((seen == INVOKESPECIAL) && "<init>".equals(getNameConstantOperand())
+                    && "java/lang/Thread".equals(getClassConstantOperand())) {
                 String sig = getSigConstantOperand();
-                if (sig.equals("()V") || sig.equals("(Ljava/lang/String;)V")
-                        || sig.equals("(Ljava/lang/ThreadGroup;Ljava/lang/String;)V")) {
+                if ("()V".equals(sig) || "(Ljava/lang/String;)V".equals(sig)
+                        || "(Ljava/lang/ThreadGroup;Ljava/lang/String;)V".equals(sig)) {
                     OpcodeStack.Item invokedOn = stack.getItemMethodInvokedOn(this);
-                    if (!getMethodName().equals("<init>") || invokedOn.getRegisterNumber() != 0) {
+                    if (!"<init>".equals(getMethodName()) || invokedOn.getRegisterNumber() != 0) {
                         accumulator.accumulateBug(
                                 new BugInstance(this, "DM_USELESS_THREAD", LOW_PRIORITY).addClassAndMethod(this), this);
 
@@ -1047,8 +1385,8 @@ public class DumbMethods extends OpcodeStackDetector {
                 }
             }
 
-            if (seen == INVOKESPECIAL && getClassConstantOperand().equals("java/math/BigDecimal")
-                    && getNameConstantOperand().equals("<init>") && getSigConstantOperand().equals("(D)V")) {
+            if (seen == INVOKESPECIAL && "java/math/BigDecimal".equals(getClassConstantOperand())
+                    && "<init>".equals(getNameConstantOperand()) && "(D)V".equals(getSigConstantOperand())) {
                 OpcodeStack.Item top = stack.getStackItem(0);
                 Object value = top.getConstant();
                 if (value instanceof Double && !((Double)value).isInfinite() && !((Double)value).isNaN()) {
@@ -1080,7 +1418,7 @@ public class DumbMethods extends OpcodeStackDetector {
             long value = ((Number) right.getConstant()).longValue();
             if ( (value > Integer.MAX_VALUE || value < Integer.MIN_VALUE)) {
                 int priority  = Priorities.HIGH_PRIORITY;
-                if (value == Integer.MAX_VALUE+1 || value == Integer.MIN_VALUE -1) {
+                if (value == Integer.MAX_VALUE+1L || value == Integer.MIN_VALUE-1L) {
                     priority = Priorities.NORMAL_PRIORITY;
                 }
                 String stringValue = IntAnnotation.getShortInteger(value)+"L";
@@ -1120,13 +1458,13 @@ public class DumbMethods extends OpcodeStackDetector {
     private int stackEntryThatMustBeNonnegative(int seen) {
         switch (seen) {
         case INVOKEINTERFACE:
-            if (getClassConstantOperand().equals("java/util/List")) {
+            if ("java/util/List".equals(getClassConstantOperand())) {
                 return getStackEntryOfListCallThatMustBeNonnegative();
             }
             break;
         case INVOKEVIRTUAL:
-            if (getClassConstantOperand().equals("java/util/LinkedList")
-                    || getClassConstantOperand().equals("java/util/ArrayList")) {
+            if ("java/util/LinkedList".equals(getClassConstantOperand())
+                    || "java/util/ArrayList".equals(getClassConstantOperand())) {
                 return getStackEntryOfListCallThatMustBeNonnegative();
             }
             break;
@@ -1155,10 +1493,10 @@ public class DumbMethods extends OpcodeStackDetector {
 
     private int getStackEntryOfListCallThatMustBeNonnegative() {
         String name = getNameConstantOperand();
-        if ((name.equals("add") || name.equals("set")) && getSigConstantOperand().startsWith("(I")) {
+        if (("add".equals(name) || "set".equals(name)) && getSigConstantOperand().startsWith("(I")) {
             return 1;
         }
-        if ((name.equals("get") || name.equals("remove")) && getSigConstantOperand().startsWith("(I)")) {
+        if (("get".equals(name) || "remove".equals(name)) && getSigConstantOperand().startsWith("(I)")) {
             return 0;
         }
         return -1;
@@ -1196,7 +1534,7 @@ public class DumbMethods extends OpcodeStackDetector {
 
     private boolean isMonitorWait(String name, String sig) {
         // System.out.println("Check call " + name + "," + sig);
-        return name.equals("wait") && (sig.equals("()V") || sig.equals("(J)V") || sig.equals("(JI)V"));
+        return "wait".equals(name) && ("()V".equals(sig) || "(J)V".equals(sig) || "(JI)V".equals(sig));
     }
 
     @Override
@@ -1236,7 +1574,7 @@ public class DumbMethods extends OpcodeStackDetector {
                     Constant constant = cp.getConstant(catchTypeIndex);
                     if (constant instanceof ConstantClass) {
                         String exClassName = (String) ((ConstantClass) constant).getConstantValue(cp);
-                        if (exClassName.equals("java/lang/OutOfMemoryError")) {
+                        if ("java/lang/OutOfMemoryError".equals(exClassName)) {
                             outOfMemoryHandler = true;
                             break;
                         }
diff --git a/EmptyZipFileEntry.java b/EmptyZipFileEntry.java
index 8c943dec8a4f59448858ad4cacbfc3d4774f55d0..e58c8e1cc4656d56b79c666aaeab5baaddb76c52 100644
--- a/EmptyZipFileEntry.java
+++ b/EmptyZipFileEntry.java
@@ -56,19 +56,19 @@ public class EmptyZipFileEntry extends BytecodeScanningDetector implements State
 
     @Override
     public void sawOpcode(int seen) {
-        if (seen == INVOKEVIRTUAL && getNameConstantOperand().equals("putNextEntry")) {
+        if (seen == INVOKEVIRTUAL && "putNextEntry".equals(getNameConstantOperand())) {
             streamType = getClassConstantOperand();
-            if (streamType.equals("java/util/zip/ZipOutputStream") || streamType.equals("java/util/jar/JarOutputStream")) {
+            if ("java/util/zip/ZipOutputStream".equals(streamType) || "java/util/jar/JarOutputStream".equals(streamType)) {
                 sawPutEntry = getPC();
             } else {
                 streamType = "";
             }
         } else {
-            if (getPC() - sawPutEntry <= 7 && seen == INVOKEVIRTUAL && getNameConstantOperand().equals("closeEntry")
+            if (getPC() - sawPutEntry <= 7 && seen == INVOKEVIRTUAL && "closeEntry".equals(getNameConstantOperand())
                     && getClassConstantOperand().equals(streamType)) {
                 bugReporter
                 .reportBug(new BugInstance(this,
-                        streamType.equals("java/util/zip/ZipOutputStream") ? "AM_CREATES_EMPTY_ZIP_FILE_ENTRY"
+                        "java/util/zip/ZipOutputStream".equals(streamType) ? "AM_CREATES_EMPTY_ZIP_FILE_ENTRY"
                                 : "AM_CREATES_EMPTY_JAR_FILE_ENTRY", NORMAL_PRIORITY).addClassAndMethod(this)
                                 .addSourceLine(this));
             }
diff --git a/EqualsOperandShouldHaveClassCompatibleWithThis.java b/EqualsOperandShouldHaveClassCompatibleWithThis.java
index a1d814735e34bb3103a239d68ca3be467c7b373c..611af62bb90066c43ea465b0e14278dc984714d2 100644
--- a/EqualsOperandShouldHaveClassCompatibleWithThis.java
+++ b/EqualsOperandShouldHaveClassCompatibleWithThis.java
@@ -54,7 +54,7 @@ public class EqualsOperandShouldHaveClassCompatibleWithThis extends OpcodeStackD
 
     @Override
     public void visit(Code obj) {
-        if (getMethodName().equals("equals") && getMethodSig().equals("(Ljava/lang/Object;)Z")) {
+        if ("equals".equals(getMethodName()) && "(Ljava/lang/Object;)Z".equals(getMethodSig())) {
             super.visit(obj);
             if (AnalysisContext.currentAnalysisContext().isApplicationClass(getThisClass())) {
                 bugAccumulator.reportAccumulatedBugs();
@@ -72,15 +72,15 @@ public class EqualsOperandShouldHaveClassCompatibleWithThis extends OpcodeStackD
     @Override
     public void sawOpcode(int seen) {
         if (seen == INVOKEVIRTUAL) {
-            if (getNameConstantOperand().equals("equals") && getSigConstantOperand().equals("(Ljava/lang/Object;)Z")) {
+            if ("equals".equals(getNameConstantOperand()) && "(Ljava/lang/Object;)Z".equals(getSigConstantOperand())) {
                 OpcodeStack.Item item = stack.getStackItem(1);
                 ClassDescriptor c = DescriptorFactory.createClassDescriptorFromSignature(item.getSignature());
                 check(c);
 
-            } else if (getClassConstantOperand().equals("java/lang/Class")
-                    && (getNameConstantOperand().equals("isInstance") || getNameConstantOperand().equals("cast"))) {
+            } else if ("java/lang/Class".equals(getClassConstantOperand())
+                    && ("isInstance".equals(getNameConstantOperand()) || "cast".equals(getNameConstantOperand()))) {
                 OpcodeStack.Item item = stack.getStackItem(1);
-                if (item.getSignature().equals("Ljava/lang/Class;")) {
+                if ("Ljava/lang/Class;".equals(item.getSignature())) {
                     Object value = item.getConstant();
                     if (value instanceof String) {
                         ClassDescriptor c = DescriptorFactory.createClassDescriptor((String) value);
diff --git a/FieldItemSummary.java b/FieldItemSummary.java
index bd7e83e259e7d31af7ccf1e703407db69f9305ec..adfbb6228648f098b4ac0810a2a52487b3099abe 100644
--- a/FieldItemSummary.java
+++ b/FieldItemSummary.java
@@ -59,7 +59,7 @@ public class FieldItemSummary extends OpcodeStackDetector implements NonReportin
 
     @Override
     public void sawOpcode(int seen) {
-        if (getMethodName().equals("<init>") && seen == INVOKEVIRTUAL) {
+        if ("<init>".equals(getMethodName()) && seen == INVOKEVIRTUAL) {
             XMethod m = getXMethodOperand();
             if (m != null && !m.isPrivate() && !m.isFinal()) {
                 int args = PreorderVisitor.getNumberArguments(m.getSignature());
@@ -85,7 +85,7 @@ public class FieldItemSummary extends OpcodeStackDetector implements NonReportin
 
         }
 
-        if (seen == INVOKESPECIAL && getMethodName().equals("<init>") && getNameConstantOperand().equals("<init>")) {
+        if (seen == INVOKESPECIAL && "<init>".equals(getMethodName()) && "<init>".equals(getNameConstantOperand())) {
 
             String classOperand = getClassConstantOperand();
             OpcodeStack.Item invokedOn = stack.getItemMethodInvokedOn(this);
@@ -110,11 +110,11 @@ public class FieldItemSummary extends OpcodeStackDetector implements NonReportin
             } else if (seen == PUTFIELD) {
                 OpcodeStack.Item addr = stack.getStackItem(1);
                 {
-                    if (addr.getRegisterNumber() != 0 || !getMethodName().equals("<init>")) {
+                    if (addr.getRegisterNumber() != 0 || !"<init>".equals(getMethodName())) {
                         fieldSummary.addWrittenOutsideOfConstructor(fieldOperand);
                     }
                 }
-            } else if (seen == PUTSTATIC && !getMethodName().equals("<clinit>")) {
+            } else if (seen == PUTSTATIC && !"<clinit>".equals(getMethodName())) {
                 fieldSummary.addWrittenOutsideOfConstructor(fieldOperand);
             }
             OpcodeStack.Item top = stack.getStackItem(0);
@@ -128,7 +128,7 @@ public class FieldItemSummary extends OpcodeStackDetector implements NonReportin
         sawInitializeSuper = false;
         super.visit(obj);
         fieldSummary.setFieldsWritten(getXMethod(), touched);
-        if (getMethodName().equals("<init>") && sawInitializeSuper) {
+        if ("<init>".equals(getMethodName()) && sawInitializeSuper) {
             XClass thisClass = getXClass();
             for (XField f : thisClass.getXFields()) {
                 if (!f.isStatic() && !f.isFinal() && !touched.contains(f)) {
diff --git a/FinalizerNullsFields.java b/FinalizerNullsFields.java
index d37907ab7b545a1daab586030497e69195c89583..3b5e9f2005c44c109fb229549b4e4cbe6e7f99ff 100644
--- a/FinalizerNullsFields.java
+++ b/FinalizerNullsFields.java
@@ -52,7 +52,7 @@ public class FinalizerNullsFields extends BytecodeScanningDetector {
 
     @Override
     public void visit(Method obj) {
-        if (obj.getName().equals("finalize")) {
+        if ("finalize".equals(obj.getName())) {
             inFinalize = true;
         } else {
             inFinalize = false;
diff --git a/FindBadCast2.java b/FindBadCast2.java
index fa4a3bb74fced554db0f81de87ad69197bac981a..a9d91056436aaf4403eae04d88cf645f988bef8b 100644
--- a/FindBadCast2.java
+++ b/FindBadCast2.java
@@ -327,13 +327,11 @@ public class FindBadCast2 implements Detector {
 
             if (refSig2.charAt(0) != 'L' || castSig2.charAt(0) != 'L') {
                 if (castSig2.charAt(0) == '['
-                        && (refSig2.equals("Ljava/io/Serializable;") || refSig2.equals("Ljava/lang/Object;") || refSig2
-                                .equals("Ljava/lang/Cloneable;"))) {
+                        && ("Ljava/io/Serializable;".equals(refSig2) || "Ljava/lang/Object;".equals(refSig2) || "Ljava/lang/Cloneable;".equals(refSig2))) {
                     continue;
                 }
                 if (refSig2.charAt(0) == '['
-                        && (castSig2.equals("Ljava/io/Serializable;") || castSig2.equals("Ljava/lang/Object;") || castSig2
-                                .equals("Ljava/lang/Cloneable;"))) {
+                        && ("Ljava/io/Serializable;".equals(castSig2) || "Ljava/lang/Object;".equals(castSig2) || "Ljava/lang/Cloneable;".equals(castSig2))) {
                     continue;
                 }
                 int priority = HIGH_PRIORITY;
@@ -349,7 +347,7 @@ public class FindBadCast2 implements Detector {
                 continue;
             }
 
-            if (!operandTypeIsExact && refSig2.equals("Ljava/lang/Object;")) {
+            if (!operandTypeIsExact && "Ljava/lang/Object;".equals(refSig2)) {
                 continue;
             }
             /*
@@ -390,7 +388,7 @@ public class FindBadCast2 implements Detector {
                     boolean castMayThrow = !Repository.instanceOf(refJavaClass, castJavaClass);
                     boolean downCast = Repository.instanceOf(castJavaClass, refJavaClass);
 
-                    if (!operandTypeIsExact && refName.equals("java.lang.Object")) {
+                    if (!operandTypeIsExact && "java.lang.Object".equals(refName)) {
                         continue;
                     }
                     double rank = 0.0;
@@ -455,9 +453,9 @@ public class FindBadCast2 implements Detector {
                         String bugPattern;
                         if (isCast) {
                             if (downCast && operandTypeIsExact) {
-                                if (refSig.equals("[Ljava/lang/Object;") && source instanceof MethodAnnotation
-                                        && ((MethodAnnotation) source).getMethodName().equals("toArray")
-                                        && ((MethodAnnotation) source).getMethodSignature().equals("()[Ljava/lang/Object;")) {
+                                if ("[Ljava/lang/Object;".equals(refSig) && source instanceof MethodAnnotation
+                                        && "toArray".equals(((MethodAnnotation) source).getMethodName())
+                                        && "()[Ljava/lang/Object;".equals(((MethodAnnotation) source).getMethodSignature())) {
                                     bugPattern = "BC_IMPOSSIBLE_DOWNCAST_OF_TOARRAY";
                                 } else {
                                     bugPattern = "BC_IMPOSSIBLE_DOWNCAST";
@@ -534,7 +532,7 @@ public class FindBadCast2 implements Detector {
                         if (DEBUG) {
                             System.out.println(" ref name: " + refName);
                         }
-                        if (methodGen.getName().equals("compareTo")) {
+                        if ("compareTo".equals(methodGen.getName())) {
                             priority++;
                         } else if (methodGen.isPublic() && isParameter && !castName.equals(oldCheck)) {
                             priority--;
@@ -606,10 +604,10 @@ public class FindBadCast2 implements Detector {
                 if (DEBUG) {
                     e.printStackTrace(System.out);
                 }
-                if (isCast && refSig.equals("[Ljava/lang/Object;") && source instanceof MethodAnnotation
-                        && ((MethodAnnotation) source).getMethodName().equals("toArray")
-                        && ((MethodAnnotation) source).getMethodSignature().equals("()[Ljava/lang/Object;")) {
-                    bugReporter.reportBug(new BugInstance(this,  "BC_IMPOSSIBLE_DOWNCAST_OF_TOARRAY", isCast ? HIGH_PRIORITY : NORMAL_PRIORITY)
+                if (isCast && "[Ljava/lang/Object;".equals(refSig) && source instanceof MethodAnnotation
+                        && "toArray".equals(((MethodAnnotation) source).getMethodName())
+                        && "()[Ljava/lang/Object;".equals(((MethodAnnotation) source).getMethodSignature())) {
+                    bugReporter.reportBug(new BugInstance(this,  "BC_IMPOSSIBLE_DOWNCAST_OF_TOARRAY", HIGH_PRIORITY)
                     .addClassAndMethod(methodGen, sourceFile)
                     .addFoundAndExpectedType(refType, castType).addOptionalUniqueAnnotations(valueSource, source)
                     .addSourceLine(sourceLineAnnotation));
diff --git a/FindComparatorProblems.java b/FindComparatorProblems.java
new file mode 100644
index 0000000000000000000000000000000000000000..d31c75bb71d11dec07eec3452a91b486e1fda366
--- /dev/null
+++ b/FindComparatorProblems.java
@@ -0,0 +1,134 @@
+/*
+ * FindBugs - Find Bugs in Java programs
+ * Copyright (C) 2003-2008 University of Maryland
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+package edu.umd.cs.findbugs.detect;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+import org.apache.bcel.classfile.Code;
+
+import edu.umd.cs.findbugs.BugAccumulator;
+import edu.umd.cs.findbugs.BugInstance;
+import edu.umd.cs.findbugs.BugReporter;
+import edu.umd.cs.findbugs.MethodAnnotation;
+import edu.umd.cs.findbugs.OpcodeStack;
+import edu.umd.cs.findbugs.OpcodeStack.Item;
+import edu.umd.cs.findbugs.ba.ClassContext;
+import edu.umd.cs.findbugs.ba.ch.Subtypes2;
+import edu.umd.cs.findbugs.bcel.OpcodeStackDetector;
+import edu.umd.cs.findbugs.classfile.MethodDescriptor;
+
+/**
+ * @author Tagir Valeev
+ */
+public class FindComparatorProblems extends OpcodeStackDetector {
+    private static final MethodDescriptor FLOAT_DESCRIPTOR = new MethodDescriptor("java/lang/Float", "compare", "(FF)I", true);
+    private static final MethodDescriptor DOUBLE_DESCRIPTOR = new MethodDescriptor("java/lang/Double", "compare", "(DD)I", true);
+
+    private boolean isComparator;
+    private int lastEmptyStackPC;
+    private List<int[]> twoDoublesInStack;
+    private final BugAccumulator accumulator;
+
+    public FindComparatorProblems(BugReporter reporter) {
+        this.accumulator = new BugAccumulator(reporter);
+    }
+
+    @Override
+    public void visitClassContext(ClassContext classContext) {
+        boolean comparator = Subtypes2.instanceOf(classContext.getClassDescriptor(), "java.util.Comparator");
+        boolean comparable = Subtypes2.instanceOf(classContext.getClassDescriptor(), "java.lang.Comparable");
+        isComparator = comparator;
+        if (comparator || comparable) {
+            super.visitClassContext(classContext);
+        }
+    }
+
+    @Override
+    public boolean shouldVisitCode(Code obj) {
+        return !getMethodDescriptor().isStatic()
+                && ((isComparator && getMethodName().equals("compare") && getMethodSig().endsWith(")I")) || ((getMethodName()
+                        .equals("compareTo") && getMethodSig().equals("(L"+getClassName()+";)I"))));
+    }
+
+    @Override
+    public void visit(Code obj) {
+        this.twoDoublesInStack = new ArrayList<>();
+        this.lastEmptyStackPC = 0;
+        super.visit(obj);
+        this.accumulator.reportAccumulatedBugs();
+    }
+
+    @Override
+    public void sawOpcode(int seen) {
+        if(getStack().getStackDepth() == 0) {
+            this.lastEmptyStackPC = getPC();
+        }
+        if((seen == DCMPG || seen == DCMPL || seen == FCMPL || seen == FCMPG) && getStack().getStackDepth() == 2) {
+            int[] startEnd = new int[] {this.lastEmptyStackPC, getPC()};
+            for(Iterator<int[]> iterator = twoDoublesInStack.iterator(); iterator.hasNext(); ) {
+                int[] oldStartEnd = iterator.next();
+                if(codeEquals(oldStartEnd, startEnd)) {
+                    Item item1 = getStack().getStackItem(0);
+                    Item item2 = getStack().getStackItem(1);
+                    accumulator.accumulateBug(
+                            new BugInstance("CO_COMPARETO_INCORRECT_FLOATING", NORMAL_PRIORITY).addClassAndMethod(this)
+                            .addType(item1.getSignature())
+                            .addMethod(item1.getSignature().equals("D")?DOUBLE_DESCRIPTOR:FLOAT_DESCRIPTOR).describe(MethodAnnotation.SHOULD_CALL)
+                            .addValueSource(item1, this)
+                            .addValueSource(item2, this), this);
+                    iterator.remove();
+                    return;
+                }
+            }
+            twoDoublesInStack.add(startEnd);
+        }
+        if (seen == IRETURN) {
+            OpcodeStack.Item top = stack.getStackItem(0);
+            Object o = top.getConstant();
+            if (o instanceof Integer && ((Integer)o).intValue() == Integer.MIN_VALUE) {
+                accumulator.accumulateBug(
+                        new BugInstance(this, "CO_COMPARETO_RESULTS_MIN_VALUE", NORMAL_PRIORITY).addClassAndMethod(this), this);
+            }
+        }
+    }
+
+    /**
+     * @param oldStartEnd - int[] {oldStart, oldEnd}
+     * @param startEnd - int[] {start, end}
+     * @return true if code slices are the same
+     */
+    private boolean codeEquals(int[] oldStartEnd, int[] startEnd) {
+        int oldStart = oldStartEnd[0];
+        int oldEnd = oldStartEnd[1];
+        int start = startEnd[0];
+        int end = startEnd[1];
+        if(end-start != oldEnd - oldStart) {
+            return false;
+        }
+        for(int i=start; i<end; i++) {
+            if(getCodeByte(i) != getCodeByte(i-start+oldStart)) {
+                return false;
+            }
+        }
+        return true;
+    }
+}
diff --git a/FindDeadLocalStores.java b/FindDeadLocalStores.java
index ecd42aa6bd08b94173274cb334d76cb5296c63b6..9e0dfb8155bba61f1c0f2a81666d6a472613d3f3 100644
--- a/FindDeadLocalStores.java
+++ b/FindDeadLocalStores.java
@@ -281,7 +281,7 @@ public class FindDeadLocalStores implements Detector {
                 LocalVariableAnnotation lvAnnotation = LocalVariableAnnotation.getLocalVariableAnnotation(method, location, ins);
 
                 String sourceFileName = javaClass.getSourceFileName();
-                if (lvAnnotation.getName().equals("?")) {
+                if ("?".equals(lvAnnotation.getName())) {
                     if (sourceFileName.endsWith(".groovy")) {
                         continue;
                     }
@@ -374,7 +374,7 @@ public class FindDeadLocalStores implements Detector {
                         GETSTATIC getStatic = (GETSTATIC) prevIns;
                         ConstantPoolGen cpg = methodGen.getConstantPool();
                         foundDeadClassInitialization = getStatic.getFieldName(cpg).startsWith("class$")
-                                && getStatic.getSignature(cpg).equals("Ljava/lang/Class;");
+                                && "Ljava/lang/Class;".equals(getStatic.getSignature(cpg));
                         for (Iterator<Location> j = cfg.locationIterator(); j.hasNext();) {
                             Location location2 = j.next();
                             if (location2.getHandle().getPosition() + 15 == location.getHandle().getPosition()) {
@@ -394,7 +394,7 @@ public class FindDeadLocalStores implements Detector {
                     } else if (prevIns instanceof LDC) {
                         LDC ldc = (LDC) prevIns;
                         Type t = ldc.getType(methodGen.getConstantPool());
-                        if (t.getSignature().equals("Ljava/lang/Class;")) {
+                        if ("Ljava/lang/Class;".equals(t.getSignature())) {
                             Object value = ldc.getValue(methodGen.getConstantPool());
                             if (value instanceof ConstantClass) {
                                 ConstantClass v = (ConstantClass) value;
@@ -425,7 +425,7 @@ public class FindDeadLocalStores implements Detector {
                         }
                     }
                     if (foundDeadClassInitialization) {
-                        if (classContext.getJavaClass().getSuperclassName().equals("org.apache.axis.client.Stub")) {
+                        if ("org.apache.axis.client.Stub".equals(classContext.getJavaClass().getSuperclassName())) {
                             continue;
                         }
                         BugInstance bugInstance = new BugInstance(this, "DLS_DEAD_STORE_OF_CLASS_LITERAL",
@@ -487,8 +487,8 @@ public class FindDeadLocalStores implements Detector {
                 if (ins instanceof IINC) {
                     // special handling of IINC
 
-                    if (method.getName().equals("main") && method.isStatic()
-                            && method.getSignature().equals("([Ljava/lang/String;)V")) {
+                    if ("main".equals(method.getName()) && method.isStatic()
+                            && "([Ljava/lang/String;)V".equals(method.getSignature())) {
                         propertySet.addProperty(DeadLocalStoreProperty.DEAD_INCREMENT_IN_MAIN);
                     }
 
@@ -508,8 +508,7 @@ public class FindDeadLocalStores implements Detector {
                     // Look for objects created but never used
 
                     Instruction prevIns = prev.getInstruction();
-                    if ((prevIns instanceof INVOKESPECIAL && ((INVOKESPECIAL) prevIns).getMethodName(methodGen.getConstantPool())
-                            .equals("<init>"))
+                    if ((prevIns instanceof INVOKESPECIAL && "<init>".equals(((INVOKESPECIAL) prevIns).getMethodName(methodGen.getConstantPool())))
                             || prevIns instanceof ANEWARRAY
                             || prevIns instanceof NEWARRAY
                             || prevIns instanceof MULTIANEWARRAY) {
diff --git a/FindDoubleCheck.java b/FindDoubleCheck.java
index f63adf7f300b11d3bf9c35fbc2c5670c21e6d32d..f310fdd4bf349431adf021be72ab3b017b6aaae4 100644
--- a/FindDoubleCheck.java
+++ b/FindDoubleCheck.java
@@ -22,22 +22,24 @@ package edu.umd.cs.findbugs.detect;
 import java.util.HashSet;
 import java.util.Set;
 
-import org.apache.bcel.Repository;
-import org.apache.bcel.classfile.Field;
-import org.apache.bcel.classfile.JavaClass;
 import org.apache.bcel.classfile.Method;
 
 import edu.umd.cs.findbugs.BugInstance;
 import edu.umd.cs.findbugs.BugReporter;
-import edu.umd.cs.findbugs.BytecodeScanningDetector;
 import edu.umd.cs.findbugs.FieldAnnotation;
-
-public class FindDoubleCheck extends BytecodeScanningDetector {
+import edu.umd.cs.findbugs.OpcodeStack.Item;
+import edu.umd.cs.findbugs.ba.XField;
+import edu.umd.cs.findbugs.bcel.OpcodeStackDetector;
+import edu.umd.cs.findbugs.classfile.Global;
+import edu.umd.cs.findbugs.detect.FindNoSideEffectMethods.MethodSideEffectStatus;
+import edu.umd.cs.findbugs.detect.FindNoSideEffectMethods.NoSideEffectMethodsDatabase;
+
+public class FindDoubleCheck extends OpcodeStackDetector {
     static final boolean DEBUG = false;
 
     int stage = 0;
 
-    int startPC, endPC;
+    int startPC, endPC, assignPC;
 
     int count;
 
@@ -49,14 +51,19 @@ public class FindDoubleCheck extends BytecodeScanningDetector {
 
     FieldAnnotation pendingFieldLoad;
 
+    XField currentDoubleCheckField;
+
     int countSinceGetReference;
 
     int countSinceGetBoolean;
 
     private final BugReporter bugReporter;
 
+    private final NoSideEffectMethodsDatabase nse;
+
     public FindDoubleCheck(BugReporter bugReporter) {
         this.bugReporter = bugReporter;
+        this.nse = Global.getAnalysisCache().getDatabase(NoSideEffectMethodsDatabase.class);
     }
 
     @Override
@@ -73,6 +80,7 @@ public class FindDoubleCheck extends BytecodeScanningDetector {
         countSinceGetBoolean = 1000;
         sawMonitorEnter = false;
         pendingFieldLoad = null;
+        currentDoubleCheckField = null;
     }
 
     @Override
@@ -90,7 +98,7 @@ public class FindDoubleCheck extends BytecodeScanningDetector {
                 System.out.println("\t" + pendingFieldLoad);
             }
             String sig = getSigConstantOperand();
-            if (sig.equals("Z")) {
+            if ("Z".equals(sig)) {
                 countSinceGetBoolean = 0;
                 countSinceGetReference++;
             } else if (sig.startsWith("L") || sig.startsWith("[")) {
@@ -158,46 +166,62 @@ public class FindDoubleCheck extends BytecodeScanningDetector {
                     System.out.println("\t" + f);
                 }
                 if (twice.contains(f) && !getNameConstantOperand().startsWith("class$")
-                        && !getSigConstantOperand().equals("Ljava/lang/String;")) {
-                    Field declaration = findField(getClassConstantOperand(), getNameConstantOperand());
-                    /*
-                     * System.out.println(f); System.out.println(declaration);
-                     * System.out.println(getSigConstantOperand());
-                     */
+                        && !"Ljava/lang/String;".equals(getSigConstantOperand())) {
+                    XField declaration = getXFieldOperand();
                     if (declaration == null || !declaration.isVolatile()) {
                         bugReporter.reportBug(new BugInstance(this, "DC_DOUBLECHECK", NORMAL_PRIORITY).addClassAndMethod(this)
                                 .addField(f).describe("FIELD_ON").addSourceLineRange(this, startPC, endPC));
+                    } else {
+                        if(declaration.isReferenceType()) {
+                            currentDoubleCheckField = declaration;
+                            assignPC = getPC();
+                        }
                     }
                     stage++;
                 }
             }
             break;
+        case 4:
+            if(currentDoubleCheckField != null) {
+                switch(seen) {
+                case MONITOREXIT:
+                    stage++;
+                    break;
+                case INVOKEINTERFACE:
+                case INVOKESPECIAL:
+                case INVOKEVIRTUAL:
+                    if(nse.is(getMethodDescriptorOperand(), MethodSideEffectStatus.OBJ, MethodSideEffectStatus.SE)) {
+                        checkStackValue(getNumberArguments(getMethodDescriptorOperand().getSignature()));
+                    }
+                    break;
+                case PUTFIELD:
+                    checkStackValue(1);
+                    break;
+                case DASTORE:
+                case FASTORE:
+                case SASTORE:
+                case LASTORE:
+                case BASTORE:
+                case CASTORE:
+                case AASTORE:
+                case IASTORE:
+                    checkStackValue(2);
+                    break;
+                }
+            }
+            break;
         default:
             break;
         }
     }
 
-    Field findField(String className, String fieldName) {
-        try {
-            // System.out.println("Looking for " + className);
-            JavaClass fieldDefinedIn = getThisClass();
-            if (!className.equals(getClassName())) {
-                // System.out.println("Using repository to look for " +
-                // className);
-
-                fieldDefinedIn = Repository.lookupClass(className);
-            }
-            Field[] f = fieldDefinedIn.getFields();
-            for (Field aF : f) {
-                if (aF.getName().equals(fieldName)) {
-                    // System.out.println("Found " + f[i]);
-                    return aF;
-                }
-            }
-            return null;
-        } catch (ClassNotFoundException e) {
-            return null;
+    private void checkStackValue(int arg) {
+        Item item = getStack().getStackItem(arg);
+        if(item.getXField() == currentDoubleCheckField) {
+            bugReporter.reportBug(new BugInstance(this, "DC_PARTIALLY_CONSTRUCTED", NORMAL_PRIORITY).addClassAndMethod(this)
+                    .addField(currentDoubleCheckField).describe("FIELD_ON").addSourceLine(this).addSourceLine(this, assignPC)
+                    .describe("SOURCE_LINE_STORED"));
+            stage++;
         }
     }
-
 }
diff --git a/FindFieldSelfAssignment.java b/FindFieldSelfAssignment.java
index 97a6323484ce4d6a68adbf3768541b52fc0a731d..9afac075bc6e5e93b3df1865e7b887b1da8f711b 100644
--- a/FindFieldSelfAssignment.java
+++ b/FindFieldSelfAssignment.java
@@ -91,7 +91,7 @@ public class FindFieldSelfAssignment extends OpcodeStackDetector implements Stat
                 int registerNumber2 = fourth.getRegisterNumber();
                 if (f2 != null && f2.equals(getXFieldOperand()) && registerNumber2 >= 0
                         && registerNumber2 == third.getFieldLoadedFromRegister()
-                        && !third.equals(top) && (third.getPC() == -1 || third.getPC() > lastMethodCall)) {
+                        && !third.sameValue(top) && (third.getPC() == -1 || third.getPC() > lastMethodCall)) {
                     possibleOverwrite = f2;
                 }
             }
diff --git a/FindFinalizeInvocations.java b/FindFinalizeInvocations.java
index de1e185a91b0e6473646c01de5338932036c1d96..686e52d1aa81a9f4a5eb14f4602a664def06bbc2 100644
--- a/FindFinalizeInvocations.java
+++ b/FindFinalizeInvocations.java
@@ -49,7 +49,7 @@ public class FindFinalizeInvocations extends BytecodeScanningDetector implements
         if (DEBUG) {
             System.out.println("FFI: visiting " + getFullyQualifiedMethodName());
         }
-        if (getMethodName().equals("finalize") && getMethodSig().equals("()V") && (obj.getAccessFlags() & (ACC_PUBLIC)) != 0) {
+        if ("finalize".equals(getMethodName()) && "()V".equals(getMethodSig()) && (obj.getAccessFlags() & (ACC_PUBLIC)) != 0) {
             bugReporter
             .reportBug(new BugInstance(this, "FI_PUBLIC_SHOULD_BE_PROTECTED", NORMAL_PRIORITY).addClassAndMethod(this));
         }
@@ -60,11 +60,11 @@ public class FindFinalizeInvocations extends BytecodeScanningDetector implements
         sawSuperFinalize = false;
         super.visit(obj);
         bugAccumulator.reportAccumulatedBugs();
-        if (!getMethodName().equals("finalize") || !getMethodSig().equals("()V")) {
+        if (!"finalize".equals(getMethodName()) || !"()V".equals(getMethodSig())) {
             return;
         }
         String overridesFinalizeIn = Lookup.findSuperImplementor(getDottedClassName(), "finalize", "()V", bugReporter);
-        boolean superHasNoFinalizer = overridesFinalizeIn.equals("java.lang.Object");
+        boolean superHasNoFinalizer = "java.lang.Object".equals(overridesFinalizeIn);
         // System.out.println("superclass: " + superclassName);
         if (obj.getCode().length == 1) {
             if (superHasNoFinalizer) {
@@ -85,14 +85,14 @@ public class FindFinalizeInvocations extends BytecodeScanningDetector implements
 
     @Override
     public void sawOpcode(int seen) {
-        if (seen == INVOKEVIRTUAL && getNameConstantOperand().equals("finalize") && getSigConstantOperand().equals("()V")) {
+        if (seen == INVOKEVIRTUAL && "finalize".equals(getNameConstantOperand()) && "()V".equals(getSigConstantOperand())) {
             bugAccumulator.accumulateBug(
-                    new BugInstance(this, "FI_EXPLICIT_INVOCATION", getMethodName().equals("finalize")
-                            && getMethodSig().equals("()V") ? HIGH_PRIORITY : NORMAL_PRIORITY).addClassAndMethod(this)
+                    new BugInstance(this, "FI_EXPLICIT_INVOCATION", "finalize".equals(getMethodName())
+                            && "()V".equals(getMethodSig()) ? HIGH_PRIORITY : NORMAL_PRIORITY).addClassAndMethod(this)
                             .addCalledMethod(this), this);
 
         }
-        if (seen == INVOKESPECIAL && getNameConstantOperand().equals("finalize")) {
+        if (seen == INVOKESPECIAL && "finalize".equals(getNameConstantOperand())) {
             sawSuperFinalize = true;
         }
     }
diff --git a/FindHEmismatch.java b/FindHEmismatch.java
index 4df7ef20084bc6cbc3d2e3f317110dc4721423ee..8e1fbdc673d1857f2c815e00c690a680c9856066 100644
--- a/FindHEmismatch.java
+++ b/FindHEmismatch.java
@@ -127,7 +127,7 @@ public class FindHEmismatch extends OpcodeStackDetector implements StatelessDete
         if (!obj.isClass()) {
             return;
         }
-        if (getDottedClassName().equals("java.lang.Object")) {
+        if ("java.lang.Object".equals(getDottedClassName())) {
             return;
         }
         int accessFlags = obj.getAccessFlags();
@@ -156,7 +156,7 @@ public class FindHEmismatch extends OpcodeStackDetector implements StatelessDete
                 }
             }
         }
-        boolean usesDefaultEquals = whereEqual.equals("java.lang.Object");
+        boolean usesDefaultEquals = "java.lang.Object".equals(whereEqual);
         String whereHashCode = getDottedClassName();
         if (!hasHashCode) {
             XClass wh = Lookup.findSuperImplementor(getXClass(), "hashCode", "()I", false, bugReporter);
@@ -170,7 +170,7 @@ public class FindHEmismatch extends OpcodeStackDetector implements StatelessDete
                 }
             }
         }
-        boolean usesDefaultHashCode = whereHashCode.equals("java.lang.Object");
+        boolean usesDefaultHashCode = "java.lang.Object".equals(whereHashCode);
         /*
         if (false && (usesDefaultEquals || usesDefaultHashCode)) {
             try {
@@ -217,7 +217,7 @@ public class FindHEmismatch extends OpcodeStackDetector implements StatelessDete
                 }
                 String bugPattern = "EQ_SELF_NO_OBJECT";
                 String superclassName = obj.getSuperclassName();
-                if (superclassName.equals("java.lang.Enum")) {
+                if ("java.lang.Enum".equals(superclassName)) {
                     bugPattern = "EQ_DONT_DEFINE_EQUALS_FOR_ENUM";
                     priority = HIGH_PRIORITY;
                 }
@@ -324,7 +324,7 @@ public class FindHEmismatch extends OpcodeStackDetector implements StatelessDete
         if (!hasEqualsObject && !hasEqualsSelf && !usesDefaultEquals && !obj.isAbstract() && hasFields && inheritedEquals != null
                 && !inheritedEqualsIsFinal && !inheritedEqualsFromAbstractClass
                 && !inheritedEquals.getClassDescriptor().getSimpleName().contains("Abstract")
-                && !inheritedEquals.getClassDescriptor().getClassName().equals("java/lang/Enum")) {
+                && !"java/lang/Enum".equals(inheritedEquals.getClassDescriptor().getClassName())) {
 
             BugInstance bug = new BugInstance(this, "EQ_DOESNT_OVERRIDE_EQUALS", NORMAL_PRIORITY);
 
@@ -338,7 +338,7 @@ public class FindHEmismatch extends OpcodeStackDetector implements StatelessDete
 
     @Override
     public void visit(JavaClass obj) {
-        extendsObject = getDottedSuperclassName().equals("java.lang.Object");
+        extendsObject = "java.lang.Object".equals(getDottedSuperclassName());
         hasFields = false;
         hasHashCode = false;
         hasCompareToObject = false;
@@ -366,7 +366,7 @@ public class FindHEmismatch extends OpcodeStackDetector implements StatelessDete
             return true;
         }
         String name = getMethod().getName();
-        if (name.equals("hashCode") || name.equals("equals")) {
+        if ("hashCode".equals(name) || "equals".equals(name)) {
             return true;
         }
         return false;
@@ -398,23 +398,23 @@ public class FindHEmismatch extends OpcodeStackDetector implements StatelessDete
         String name = obj.getName();
         String sig = obj.getSignature();
         if ((accessFlags & ACC_ABSTRACT) != 0) {
-            if (name.equals("equals") && sig.equals("(L" + getClassName() + ";)Z")) {
+            if ("equals".equals(name) && sig.equals("(L" + getClassName() + ";)Z")) {
                 bugReporter.reportBug(new BugInstance(this, "EQ_ABSTRACT_SELF", LOW_PRIORITY).addClass(getDottedClassName()));
                 return;
-            } else if (name.equals("compareTo") && sig.equals("(L" + getClassName() + ";)I")) {
+            } else if ("compareTo".equals(name) && sig.equals("(L" + getClassName() + ";)I")) {
                 bugReporter.reportBug(new BugInstance(this, "CO_ABSTRACT_SELF", LOW_PRIORITY).addClass(getDottedClassName()));
                 return;
             }
         }
-        boolean sigIsObject = sig.equals("(Ljava/lang/Object;)Z");
-        if (name.equals("hashCode") && sig.equals("()I")) {
+        boolean sigIsObject = "(Ljava/lang/Object;)Z".equals(sig);
+        if ("hashCode".equals(name) && "()I".equals(sig)) {
             hasHashCode = true;
             if (obj.isAbstract()) {
                 hashCodeIsAbstract = true;
             }
             hashCodeMethod = MethodAnnotation.fromVisitedMethod(this);
             // System.out.println("Found hashCode for " + betterClassName);
-        } else if (obj.isPublic() && name.equals("equals")) {
+        } else if (obj.isPublic() && "equals".equals(name)) {
             Matcher m = predicateOverAnInstance.matcher(sig);
             if (m.matches()) {
                 if (sigIsObject) {
@@ -475,12 +475,12 @@ public class FindHEmismatch extends OpcodeStackDetector implements StatelessDete
 
                 }
             }
-        } else if (name.equals("compareTo") && sig.endsWith(")I") && !obj.isStatic()) {
+        } else if ("compareTo".equals(name) && sig.endsWith(")I") && !obj.isStatic()) {
             MethodAnnotation tmp = MethodAnnotation.fromVisitedMethod(this);
             if (BCELUtil.isSynthetic(obj)) {
                 hasCompareToBridgeMethod = true;
             }
-            if (sig.equals("(Ljava/lang/Object;)I")) {
+            if ("(Ljava/lang/Object;)I".equals(sig)) {
                 hasCompareToObject = true;
                 compareToObjectMethod = compareToMethod = tmp;
             } else if (sig.equals("(L" + getClassName() + ";)I")) {
@@ -504,22 +504,22 @@ public class FindHEmismatch extends OpcodeStackDetector implements StatelessDete
     public void sawOpcode(int seen) {
         if (seen == INVOKEVIRTUAL || seen == INVOKEINTERFACE) {
             String className = getClassConstantOperand();
-            if (className.equals("java/util/Map") || className.equals("java/util/HashMap")
-                    || className.equals("java/util/LinkedHashMap") || className.equals("java/util/concurrent/ConcurrentHashMap")
+            if ("java/util/Map".equals(className) || "java/util/HashMap".equals(className)
+                    || "java/util/LinkedHashMap".equals(className) || "java/util/concurrent/ConcurrentHashMap".equals(className)
                     || className.contains("Hash")
                     && Subtypes2.instanceOf(ClassName.toDottedClassName(className), "java.util.Map")) {
-                if (getNameConstantOperand().equals("put")
-                        && getSigConstantOperand().equals("(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;")
+                if ("put".equals(getNameConstantOperand())
+                        && "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;".equals(getSigConstantOperand())
                         && stack.getStackDepth() >= 3) {
                     check(1);
-                } else if ((getNameConstantOperand().equals("get") || getNameConstantOperand().equals("remove"))
+                } else if (("get".equals(getNameConstantOperand()) || "remove".equals(getNameConstantOperand()))
                         && getSigConstantOperand().startsWith("(Ljava/lang/Object;)") && stack.getStackDepth() >= 2) {
                     check(0);
                 }
-            } else if (className.equals("java/util/Set") || className.equals("java/util/HashSet") || className.contains("Hash")
+            } else if ("java/util/Set".equals(className) || "java/util/HashSet".equals(className) || className.contains("Hash")
                     && Subtypes2.instanceOf(ClassName.toDottedClassName(className), "java.util.Set")) {
-                if (getNameConstantOperand().equals("add") || getNameConstantOperand().equals("contains")
-                        || getNameConstantOperand().equals("remove") && getSigConstantOperand().equals("(Ljava/lang/Object;)Z")
+                if ("add".equals(getNameConstantOperand()) || "contains".equals(getNameConstantOperand())
+                        || "remove".equals(getNameConstantOperand()) && "(Ljava/lang/Object;)Z".equals(getSigConstantOperand())
                         && stack.getStackDepth() >= 2) {
                     check(0);
                 }
diff --git a/FindInconsistentSync2.java b/FindInconsistentSync2.java
index 0c26ba5705c8d590313754b121b52282fbe7744b..13f91ad8e2a313357859ca16b9e1407466e0000c 100644
--- a/FindInconsistentSync2.java
+++ b/FindInconsistentSync2.java
@@ -28,6 +28,7 @@ import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
+import java.util.Map.Entry;
 import java.util.Set;
 
 import org.apache.bcel.Constants;
@@ -396,9 +397,9 @@ public class FindInconsistentSync2 implements Detector {
 
             String name = method.getName();
 
-            boolean inConstructor = name.equals("<init>") || name.equals("<clinit>")
-                    || name.equals("readObject") || name.equals("clone") || name.equals("close")
-                    || name.equals("finalize");
+            boolean inConstructor = "<init>".equals(name) || "<clinit>".equals(name)
+                    || "readObject".equals(name) || "clone".equals(name) || "close".equals(name)
+                    || "finalize".equals(name);
 
             if (inConstructor) {
                 continue;
@@ -436,8 +437,9 @@ public class FindInconsistentSync2 implements Detector {
             return;
         }
         JCIPAnnotationDatabase jcipAnotationDatabase = AnalysisContext.currentAnalysisContext().getJCIPAnnotationDatabase();
-        for (XField xfield : statMap.keySet()) {
-            FieldStats stats = statMap.get(xfield);
+        for (Entry<XField, FieldStats> entry : statMap.entrySet()) {
+            XField xfield = entry.getKey();
+            FieldStats stats = entry.getValue();
             if (!stats.isInteresting()) {
                 continue;
             }
@@ -448,7 +450,7 @@ public class FindInconsistentSync2 implements Detector {
             ElementValue guardedByValue = jcipAnotationDatabase.getFieldAnnotation(xfield, "GuardedBy");
             boolean guardedByThis;
             if(guardedByValue != null){
-                guardedByThis = guardedByValue.stringifyValue().equals("this");
+                guardedByThis = "this".equals(guardedByValue.stringifyValue());
             } else {
                 guardedByThis = false;
             }
@@ -614,11 +616,11 @@ public class FindInconsistentSync2 implements Detector {
      */
 
     private static boolean isConstructor(String methodName) {
-        return methodName.equals("<init>") || methodName.equals("<clinit>") || methodName.equals("readObject")
-                || methodName.equals("clone") || methodName.equals("close") || methodName.equals("writeObject")
-                || methodName.equals("toString") || methodName.equals("init") || methodName.equals("initialize")
-                || methodName.equals("dispose") || methodName.equals("finalize") || methodName.equals("this")
-                || methodName.equals("_jspInit") || methodName.equals("_jspDestroy");
+        return "<init>".equals(methodName) || "<clinit>".equals(methodName) || "readObject".equals(methodName)
+                || "clone".equals(methodName) || "close".equals(methodName) || "writeObject".equals(methodName)
+                || "toString".equals(methodName) || "init".equals(methodName) || "initialize".equals(methodName)
+                || "dispose".equals(methodName) || "finalize".equals(methodName) || "this".equals(methodName)
+                || "_jspInit".equals(methodName) || "_jspDestroy".equals(methodName);
 
     }
 
diff --git a/FindJSR166LockMonitorenter.java b/FindJSR166LockMonitorenter.java
index d649adbe7f51607c2825739a5ee6049e04df0f01..3ecfb69cbfce1ebe4fdb6d97aabbd0a498b46dcb 100644
--- a/FindJSR166LockMonitorenter.java
+++ b/FindJSR166LockMonitorenter.java
@@ -139,9 +139,9 @@ public final class FindJSR166LockMonitorenter implements Detector, StatelessDete
 
                 String methodName = iv.getMethodName(cpg);
                 String methodSig = iv.getSignature(cpg);
-                if (methodName.equals("wait")
-                        && (methodSig.equals("()V") || methodSig.equals("(J)V") || methodSig.equals("(JI)V"))
-                        || (methodName.equals("notify") || methodName.equals("notifyAll")) && methodSig.equals("()V")) {
+                if ("wait".equals(methodName)
+                        && ("()V".equals(methodSig) || "(J)V".equals(methodSig) || "(JI)V".equals(methodSig))
+                        || ("notify".equals(methodName) || "notifyAll".equals(methodName)) && "()V".equals(methodSig)) {
                     try {
                         TypeFrame frame = typeDataflow.getFactAtLocation(location);
                         if (!frame.isValid()) {
@@ -166,15 +166,15 @@ public final class FindJSR166LockMonitorenter implements Detector, StatelessDete
                         XClass c = Lookup.getXClass(classDescriptor);
                         XMethod m;
                         int priority = NORMAL_PRIORITY;
-                        if (methodName.equals("wait")) {
+                        if ("wait".equals(methodName)) {
                             m = c.findMethod("await", "()V", false);
                             priority = HIGH_PRIORITY;
-                        } else if (methodName.equals("notify")) {
+                        } else if ("notify".equals(methodName)) {
                             m = c.findMethod("signal", "()V", false);
                             if (m == null) {
                                 m = c.findMethod("countDown", "()V", false);
                             }
-                        } else if (methodName.equals("notifyAll")) {
+                        } else if ("notifyAll".equals(methodName)) {
                             m = c.findMethod("signalAll", "()V", false);
                             if (m == null) {
                                 m = c.findMethod("countDown", "()V", false);
diff --git a/FindLocalSelfAssignment2.java b/FindLocalSelfAssignment2.java
index f894cfdd043745623d743a2e7aa1c98e2aec1645..bcb04456656adefdddf1c9b365206da5f75ea824 100644
--- a/FindLocalSelfAssignment2.java
+++ b/FindLocalSelfAssignment2.java
@@ -73,7 +73,7 @@ public class FindLocalSelfAssignment2 extends BytecodeScanningDetector implement
                     if (previousLoadOf == getRegisterOperand() && gotoCount < 2 && getPC() != previousGotoTarget) {
                         int priority = NORMAL_PRIORITY;
                         String methodName = getMethodName();
-                        if (methodName.equals("<init>") || methodName.startsWith("set") && getCode().getCode().length <= 5
+                        if ("<init>".equals(methodName) || methodName.startsWith("set") && getCode().getCode().length <= 5
                                 || !previousStores.get(getRegisterOperand())) {
                             priority = HIGH_PRIORITY;
                         }
@@ -81,7 +81,7 @@ public class FindLocalSelfAssignment2 extends BytecodeScanningDetector implement
                         XClass c = getXClass();
                         LocalVariableAnnotation local = LocalVariableAnnotation.getLocalVariableAnnotation(getMethod(),
                                 getRegisterOperand(), getPC(), getPC());
-                        if (local.getName().equals("?")) {
+                        if ("?".equals(local.getName())) {
                             priority++;
                         } else {
                             for (XField f : c.getXFields()) {
diff --git a/FindMaskedFields.java b/FindMaskedFields.java
index 6d700fcbf699c782e12f1ed67c783c4f0ce31e93..5eac18d53a0290f2a8b6238ee5b41ec50b411156 100644
--- a/FindMaskedFields.java
+++ b/FindMaskedFields.java
@@ -98,7 +98,7 @@ public class FindMaskedFields extends BytecodeScanningDetector {
         XClass c = getXClass();
         while (true) {
             ClassDescriptor s = c.getSuperclassDescriptor();
-            if (s == null || s.getClassName().equals("java/lang/Object")) {
+            if (s == null || "java/lang/Object".equals(s.getClassName())) {
                 break;
             }
             try {
@@ -113,13 +113,13 @@ public class FindMaskedFields extends BytecodeScanningDetector {
                     if (fieldName.length() == 1) {
                         continue;
                     }
-                    if (fieldName.equals("serialVersionUID")) {
+                    if ("serialVersionUID".equals(fieldName)) {
                         continue;
                     }
                     String superClassName = s.getClassName();
                     if (superClassName.startsWith("java/io")
-                            && (superClassName.endsWith("InputStream") && fieldName.equals("in") || superClassName
-                                    .endsWith("OutputStream") && fieldName.equals("out"))) {
+                            && (superClassName.endsWith("InputStream") && "in".equals(fieldName) || superClassName
+                                    .endsWith("OutputStream") && "out".equals(fieldName))) {
                         continue;
                     }
                     if (classFields.containsKey(fieldName)) {
@@ -188,7 +188,7 @@ public class FindMaskedFields extends BytecodeScanningDetector {
                     continue;
                 }
                 String varName = var.getName();
-                if (varName.equals("serialVersionUID")) {
+                if ("serialVersionUID".equals(varName)) {
                     continue;
                 }
                 Field f = classFields.get(varName);
diff --git a/FindMismatchedWaitOrNotify.java b/FindMismatchedWaitOrNotify.java
index b9eb71647df6b5b3891cfa36536173cd7ac6b555..3c9e8f2d9fd67cab240a4bc940bd24148394a9e4 100644
--- a/FindMismatchedWaitOrNotify.java
+++ b/FindMismatchedWaitOrNotify.java
@@ -155,7 +155,7 @@ public final class FindMismatchedWaitOrNotify implements Detector, StatelessDete
 
                     if (!foundMatch) {
 
-                        String type = methodName.equals("wait") ? "MWN_MISMATCHED_WAIT" : "MWN_MISMATCHED_NOTIFY";
+                        String type = "wait".equals(methodName) ? "MWN_MISMATCHED_WAIT" : "MWN_MISMATCHED_NOTIFY";
                         String sourceFile = classContext.getJavaClass().getSourceFileName();
                         // Report as medium priority only if the method is
                         // public.
diff --git a/FindNakedNotify.java b/FindNakedNotify.java
index 422de3cb5dc1c7a614c01790feab24fb9d8c6421..c06c04f570928265f1b2d37d6e43d178c40abe38 100644
--- a/FindNakedNotify.java
+++ b/FindNakedNotify.java
@@ -76,8 +76,8 @@ public class FindNakedNotify extends BytecodeScanningDetector implements Statele
             break;
         case 2:
             if (seen == INVOKEVIRTUAL
-            && (getNameConstantOperand().equals("notify") || getNameConstantOperand().equals("notifyAll"))
-            && getSigConstantOperand().equals("()V")) {
+            && ("notify".equals(getNameConstantOperand()) || "notifyAll".equals(getNameConstantOperand()))
+            && "()V".equals(getSigConstantOperand())) {
                 stage = 3;
                 notifyPC = getPC();
             } else {
diff --git a/FindNoSideEffectMethods.java b/FindNoSideEffectMethods.java
new file mode 100644
index 0000000000000000000000000000000000000000..eb757bfd263f2b6dd8228e5ce26a4807cf2cf2a2
--- /dev/null
+++ b/FindNoSideEffectMethods.java
@@ -0,0 +1,1075 @@
+/*
+ * FindBugs - Find Bugs in Java programs
+ * Copyright (C) 2003-2008 University of Maryland
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+package edu.umd.cs.findbugs.detect;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Set;
+
+import javax.annotation.Nonnull;
+
+import org.apache.bcel.classfile.Code;
+import org.apache.bcel.classfile.CodeException;
+import org.apache.bcel.classfile.Field;
+import org.apache.bcel.classfile.JavaClass;
+import org.apache.bcel.classfile.Method;
+import org.apache.bcel.generic.Type;
+
+import edu.umd.cs.findbugs.BugReporter;
+import edu.umd.cs.findbugs.NonReportingDetector;
+import edu.umd.cs.findbugs.OpcodeStack;
+import edu.umd.cs.findbugs.OpcodeStack.Item;
+import edu.umd.cs.findbugs.ba.AnalysisContext;
+import edu.umd.cs.findbugs.ba.Hierarchy2;
+import edu.umd.cs.findbugs.ba.SignatureParser;
+import edu.umd.cs.findbugs.ba.XClass;
+import edu.umd.cs.findbugs.ba.XField;
+import edu.umd.cs.findbugs.ba.XMethod;
+import edu.umd.cs.findbugs.ba.ch.Subtypes2;
+import edu.umd.cs.findbugs.bcel.OpcodeStackDetector;
+import edu.umd.cs.findbugs.classfile.CheckedAnalysisException;
+import edu.umd.cs.findbugs.classfile.ClassDescriptor;
+import edu.umd.cs.findbugs.classfile.FieldDescriptor;
+import edu.umd.cs.findbugs.classfile.Global;
+import edu.umd.cs.findbugs.classfile.MethodDescriptor;
+import edu.umd.cs.findbugs.util.ClassName;
+
+/**
+ * @author Tagir Valeev
+ */
+public class FindNoSideEffectMethods extends OpcodeStackDetector implements NonReportingDetector {
+    private static final MethodDescriptor GET_CLASS = new MethodDescriptor("java/lang/Object", "getClass", "()Ljava/lang/Class;");
+    private static final MethodDescriptor ARRAY_COPY = new MethodDescriptor("java/lang/System", "arraycopy", "(Ljava/lang/Object;ILjava/lang/Object;II)V", true);
+    private static final MethodDescriptor HASH_CODE = new MethodDescriptor("java/lang/Object", "hashCode", "()I");
+    private static final MethodDescriptor CLASS_GET_NAME = new MethodDescriptor("java/lang/Class", "getName", "()Ljava/lang/String;");
+    // Stub method to generalize array store
+    private static final MethodDescriptor ARRAY_STORE_STUB_METHOD = new MethodDescriptor("java/lang/Array", "set", "(ILjava/lang/Object;)V");
+    // Stub method to generalize field store
+    private static final MethodDescriptor FIELD_STORE_STUB_METHOD = new MethodDescriptor("java/lang/Object", "putField", "(Ljava/lang/Object;)V");
+
+    // Fictional method call targets
+    private static final FieldDescriptor TARGET_THIS = new FieldDescriptor("java/lang/Stub", "this", "V", false);
+    private static final FieldDescriptor TARGET_NEW = new FieldDescriptor("java/lang/Stub", "new", "V", false);
+    private static final FieldDescriptor TARGET_OTHER = new FieldDescriptor("java/lang/Stub", "other", "V", false);
+
+    private static final Set<String> NUMBER_CLASSES = new HashSet<>(Arrays.asList("java/lang/Integer", "java/lang/Long",
+            "java/lang/Double", "java/lang/Float", "java/lang/Byte", "java/lang/Short", "java/math/BigInteger",
+            "java/math/BigDecimal"));
+
+    private static final Set<String> ALLOWED_EXCEPTIONS = new HashSet<>(Arrays.asList("java.lang.InternalError",
+            "java.lang.ArrayIndexOutOfBoundsException", "java.lang.StringIndexOutOfBoundsException",
+            "java.lang.IndexOutOfBoundsException"));
+
+    private static final Set<String> NO_SIDE_EFFECT_COLLECTION_METHODS = new HashSet<>(Arrays.asList("contains", "containsKey",
+            "containsValue", "get", "indexOf", "lastIndexOf", "iterator", "listIterator", "isEmpty", "size", "getOrDefault",
+            "subList", "keys", "elements", "keySet", "entrySet", "values", "stream", "firstKey", "lastKey", "headMap", "tailMap",
+            "subMap", "peek", "mappingCount"));
+
+    private static final Set<String> OBJECT_ONLY_CLASSES = new HashSet<>(Arrays.asList("java/lang/StringBuffer",
+            "java/lang/StringBuilder", "java/util/regex/Matcher", "java/io/ByteArrayOutputStream",
+            "java/util/concurrent/atomic/AtomicBoolean", "java/util/concurrent/atomic/AtomicInteger",
+            "java/util/concurrent/atomic/AtomicLong", "java/awt/Point"));
+
+    // Usual implementation of stub methods which are expected to be more complex in derived classes
+    private static final byte[][] STUB_METHODS = new byte[][] {
+        {(byte) RETURN},
+        {ICONST_0, (byte) IRETURN},
+        {ICONST_1, (byte) IRETURN},
+        {ICONST_M1, (byte) IRETURN},
+        {LCONST_0, (byte) LRETURN},
+        {FCONST_0, (byte) FRETURN},
+        {DCONST_0, (byte) DRETURN},
+        {ACONST_NULL, (byte) ARETURN},
+        {ALOAD_0, (byte) ARETURN},
+        {ALOAD_1, (byte) ARETURN},
+    };
+
+    /**
+     * Known methods which change only this object
+     */
+    private static final Set<MethodDescriptor> OBJECT_ONLY_METHODS = new HashSet<>(Arrays.asList(
+            ARRAY_STORE_STUB_METHOD, FIELD_STORE_STUB_METHOD,
+            new MethodDescriptor("java/util/Iterator", "next", "()Ljava/lang/Object;"),
+            new MethodDescriptor("java/util/Enumeration", "nextElement", "()Ljava/lang/Object;"),
+            new MethodDescriptor("java/lang/Throwable", "fillInStackTrace", "()Ljava/lang/Throwable;")
+            ));
+
+    /**
+     * Known methods which have no side-effect
+     */
+    private static final Set<MethodDescriptor> NO_SIDE_EFFECT_METHODS = new HashSet<>(Arrays.asList(
+            GET_CLASS, CLASS_GET_NAME, HASH_CODE,
+            new MethodDescriptor("java/lang/reflect/Array", "newInstance", "(Ljava/lang/Class;I)Ljava/lang/Object;"),
+            new MethodDescriptor("java/lang/Class", "getResource", "(Ljava/lang/String;)Ljava/net/URL;"),
+            new MethodDescriptor("java/lang/Class", "getSimpleName", "()Ljava/lang/String;"),
+            new MethodDescriptor("java/lang/Class", "getMethods", "()[Ljava/lang/reflect/Method;"),
+            new MethodDescriptor("java/lang/Class", "getSuperclass", "()Ljava/lang/Class;"),
+            new MethodDescriptor("java/lang/Runtime", "availableProcessors", "()I"),
+            new MethodDescriptor("java/lang/Runtime", "maxMemory", "()J"),
+            new MethodDescriptor("java/lang/Runtime", "totalMemory", "()J"),
+            new MethodDescriptor("java/lang/Iterable", "iterator", "()Ljava/util/Iterator;"),
+            new MethodDescriptor("java/lang/Comparable", "compareTo", "(Ljava/lang/Object;)I"),
+            new MethodDescriptor("java/util/Arrays", "deepEquals", "([Ljava/lang/Object;[Ljava/lang/Object;)Z", true),
+            new MethodDescriptor("java/util/Enumeration", "hasMoreElements", "()Z"),
+            new MethodDescriptor("java/util/Iterator", "hasNext", "()Z"),
+            new MethodDescriptor("java/util/Comparator", "compare", "(Ljava/lang/Object;Ljava/lang/Object;)I"),
+            new MethodDescriptor("java/util/logging/LogManager", "getLogger", "(Ljava/lang/String;)Ljava/util/logging/Logger;", true),
+            new MethodDescriptor("org/apache/log4j/LogManager", "getLogger", "(Ljava/lang/String;)Lorg/apache/log4j/Logger;", true)
+            ));
+
+    private static final Set<MethodDescriptor> NEW_OBJECT_RETURNING_METHODS = new HashSet<>(Arrays.asList(
+            new MethodDescriptor("java/util/Vector", "elements", "()Ljava/util/Enumeration;"),
+            new MethodDescriptor("java/util/Hashtable", "elements", "()Ljava/util/Enumeration;"),
+            new MethodDescriptor("java/util/Hashtable", "keys", "()Ljava/util/Enumeration;"),
+            new MethodDescriptor("java/lang/reflect/Array", "newInstance", "(Ljava/lang/Class;I)Ljava/lang/Object;")
+            ));
+
+    private static enum SideEffectStatus {
+        SIDE_EFFECT, UNSURE_OBJECT_ONLY, OBJECT_ONLY, UNSURE, NO_SIDE_EFFECT;
+
+        boolean unsure() {
+            return this == UNSURE || this == UNSURE_OBJECT_ONLY;
+        }
+
+        SideEffectStatus toObjectOnly() {
+            switch(this) {
+            case UNSURE:
+                return UNSURE_OBJECT_ONLY;
+            case NO_SIDE_EFFECT:
+                return OBJECT_ONLY;
+            default:
+                return this;
+            }
+        }
+
+        SideEffectStatus toUnsure() {
+            switch(this) {
+            case OBJECT_ONLY:
+                return UNSURE_OBJECT_ONLY;
+            case NO_SIDE_EFFECT:
+                return UNSURE;
+            default:
+                return this;
+            }
+        }
+
+        SideEffectStatus toSure() {
+            switch(this) {
+            case UNSURE_OBJECT_ONLY:
+                return OBJECT_ONLY;
+            case UNSURE:
+                return NO_SIDE_EFFECT;
+            default:
+                return this;
+            }
+        }
+    }
+
+    private static class MethodCall {
+        private final MethodDescriptor method;
+        private final FieldDescriptor target;
+
+        public MethodCall(MethodDescriptor method, FieldDescriptor target) {
+            this.method = method;
+            this.target = target;
+        }
+
+        public MethodDescriptor getMethod() {
+            return method;
+        }
+
+        public FieldDescriptor getTarget() {
+            return target;
+        }
+
+        @Override
+        public int hashCode() {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public boolean equals(Object obj) {
+            if (this == obj) {
+                return true;
+            }
+            if (obj == null) {
+                return false;
+            }
+            if (getClass() != obj.getClass()) {
+                return false;
+            }
+            MethodCall other = (MethodCall) obj;
+            if (!method.equals(other.method)) {
+                return false;
+            }
+            if (!target.equals(other.target)) {
+                return false;
+            }
+            return true;
+        }
+    }
+
+    /**
+     * Public status of the method in NSE database
+     * TODO: implement CHECK
+     */
+    public static enum MethodSideEffectStatus {
+        NSE, // Non-void method has no side effect
+        NSE_EX, // No side effect method which result value might be ignored for some reason
+        CHECK, // (unimplemented yet) No side effect method which just checks the arguments, throws exceptions and returns one of arguments (or void) like assert or precondition
+        USELESS, // Void method which seems to be useless
+        SE_CLINIT, // Method has no side effect, but it's a constructor or static method of the class having side effect
+        OBJ, // Non-static method which changes only its object
+        SE // Method has side effect or side-effect status for the method is unknown
+    }
+
+    public static class NoSideEffectMethodsDatabase {
+        private final Map<MethodDescriptor, MethodSideEffectStatus> map = new HashMap<>();
+
+        void add(MethodDescriptor m, MethodSideEffectStatus s) {
+            map.put(m, s);
+        }
+
+        public @Nonnull MethodSideEffectStatus status(MethodDescriptor m) {
+            MethodSideEffectStatus s = map.get(m);
+            return s == null ? MethodSideEffectStatus.SE : s;
+        }
+
+        /**
+         * @param m method to check
+         * @param statuses allowed statuses
+         * @return true if method status is one of the statuses
+         */
+        public boolean is(MethodDescriptor m, MethodSideEffectStatus... statuses) {
+            MethodSideEffectStatus s = status(m);
+            for(MethodSideEffectStatus status : statuses) {
+                if(s == status) {
+                    return true;
+                }
+            }
+            return false;
+        }
+
+        public boolean hasNoSideEffect(MethodDescriptor m) {
+            return status(m) == MethodSideEffectStatus.NSE;
+        }
+
+        public boolean useless(MethodDescriptor m) {
+            return status(m) == MethodSideEffectStatus.USELESS;
+        }
+
+        public boolean excluded(MethodDescriptor m) {
+            return is(m, MethodSideEffectStatus.NSE_EX, MethodSideEffectStatus.SE_CLINIT);
+        }
+    }
+
+    static class EarlyExitException extends RuntimeException {
+    }
+
+    private final Map<MethodDescriptor, SideEffectStatus> statusMap = new HashMap<>();
+    private final Map<MethodDescriptor, List<MethodCall>> callGraph = new HashMap<>();
+    private final Set<MethodDescriptor> getStaticMethods = new HashSet<>();
+    private final Set<MethodDescriptor> uselessVoidCandidates = new HashSet<>();
+
+    private SideEffectStatus status;
+    private ArrayList<MethodCall> calledMethods;
+    private Set<ClassDescriptor> subtypes;
+    private Set<Integer> finallyTargets;
+    private Set<Integer> finallyExceptionRegisters;
+
+    private boolean constructor;
+    private boolean uselessVoidCandidate;
+    private boolean classInit;
+
+    private Set<FieldDescriptor> allowedFields;
+    private Set<MethodDescriptor> fieldsModifyingMethods;
+
+    private final NoSideEffectMethodsDatabase noSideEffectMethods = new NoSideEffectMethodsDatabase();
+
+    public FindNoSideEffectMethods(BugReporter bugReporter) {
+        Global.getAnalysisCache().eagerlyPutDatabase(NoSideEffectMethodsDatabase.class, noSideEffectMethods);
+    }
+
+    @Override
+    public void visit(JavaClass obj) {
+        super.visit(obj);
+        allowedFields = new HashSet<>();
+        fieldsModifyingMethods = new HashSet<>();
+        subtypes = null;
+        if (!obj.isFinal() && !obj.isEnum()) {
+            try {
+                Subtypes2 subtypes2 = AnalysisContext.currentAnalysisContext().getSubtypes2();
+                subtypes = new HashSet<>(subtypes2.getSubtypes(getClassDescriptor()));
+                subtypes.remove(getClassDescriptor());
+            } catch (ClassNotFoundException e) {
+            }
+        }
+    }
+
+    @Override
+    public void visit(Method method) {
+        constructor = method.getName().equals("<init>");
+        classInit = method.getName().equals("<clinit>");
+        calledMethods = new ArrayList<>();
+        status = SideEffectStatus.NO_SIDE_EFFECT;
+        if (hasNoSideEffect(getMethodDescriptor())) {
+            handleStatus();
+            return;
+        }
+        if(isObjectOnlyMethod(getMethodDescriptor())) {
+            status = SideEffectStatus.OBJECT_ONLY;
+        }
+        if (method.isNative() || changedArg(getMethodDescriptor()) != -1) {
+            status = SideEffectStatus.SIDE_EFFECT;
+            handleStatus();
+            return;
+        }
+        boolean sawImplementation = false;
+        if (classInit) {
+            superClinitCall();
+        }
+        if (!method.isStatic() && !method.isPrivate() && !method.isFinal() && !constructor && subtypes != null) {
+            for (ClassDescriptor subtype : subtypes) {
+                try {
+                    XClass xClass = Global.getAnalysisCache().getClassAnalysis(XClass.class, subtype);
+                    XMethod matchingMethod = xClass.findMatchingMethod(getMethodDescriptor());
+                    if (matchingMethod != null) {
+                        sawImplementation = true;
+                        sawCall(new MethodCall(matchingMethod.getMethodDescriptor(), TARGET_THIS), false);
+                    }
+                } catch (CheckedAnalysisException e) {
+                }
+            }
+        }
+        if (method.isAbstract() || method.isInterface()) {
+            if (!sawImplementation
+                    || getClassName().endsWith("Visitor") || getClassName().endsWith("Listener")
+                    || getClassName().startsWith("java/sql/")
+                    || (getClassName().equals("java/util/concurrent/Future") && !method.getName().startsWith("is"))
+                    || (getClassName().equals("java/lang/Process") && method.getName().equals("exitValue"))) {
+                status = SideEffectStatus.SIDE_EFFECT;
+            } else if(isObjectOnlyMethod(getMethodDescriptor())) {
+                status = SideEffectStatus.OBJECT_ONLY;
+            } else {
+                String[] thrownExceptions = getXMethod().getThrownExceptions();
+                if(thrownExceptions != null && thrownExceptions.length > 0) {
+                    status = SideEffectStatus.SIDE_EFFECT;
+                }
+            }
+        }
+        if ((status == SideEffectStatus.SIDE_EFFECT || status == SideEffectStatus.OBJECT_ONLY) || method.isAbstract()
+                || method.isInterface() || method.isNative()) {
+            handleStatus();
+        }
+    }
+
+    @Override
+    public void visit(Field obj) {
+        XField xField = getXField();
+        if(!xField.isStatic() && (xField.isPrivate() || xField.isFinal()) && xField.isReferenceType()) {
+            allowedFields.add(xField.getFieldDescriptor());
+        }
+    }
+
+    @Override
+    public void visitAfter(JavaClass obj) {
+        for(MethodDescriptor method : fieldsModifyingMethods) {
+            List<MethodCall> calls = callGraph.get(method);
+            SideEffectStatus prevStatus = statusMap.get(method);
+            status = prevStatus.toSure();
+            calledMethods = new ArrayList<>();
+            for(MethodCall methodCall : calls) {
+                FieldDescriptor target = methodCall.getTarget();
+                if(target != TARGET_NEW && target != TARGET_OTHER && target != TARGET_THIS) {
+                    if(allowedFields.contains(target)) {
+                        methodCall = new MethodCall(methodCall.getMethod(), TARGET_THIS);
+                    } else {
+                        methodCall = new MethodCall(methodCall.getMethod(), TARGET_OTHER);
+                    }
+                }
+                sawCall(methodCall, false);
+                if(status == SideEffectStatus.SIDE_EFFECT) {
+                    break;
+                }
+            }
+            if (status != prevStatus) {
+                statusMap.put(method, status);
+            }
+            if(status.unsure()) {
+                calledMethods.trimToSize();
+                callGraph.put(method, calledMethods);
+            } else {
+                callGraph.remove(method);
+            }
+        }
+        MethodDescriptor clinit = new MethodDescriptor(getClassName(), "<clinit>", "()V", true);
+        if(!statusMap.containsKey(clinit)) {
+            status = SideEffectStatus.NO_SIDE_EFFECT;
+            calledMethods = new ArrayList<>();
+            superClinitCall();
+            statusMap.put(clinit, status);
+            if(status == SideEffectStatus.UNSURE || status == SideEffectStatus.UNSURE_OBJECT_ONLY) {
+                calledMethods.trimToSize();
+                callGraph.put(clinit, calledMethods);
+            }
+        }
+    }
+
+    private void superClinitCall() {
+        ClassDescriptor superclassDescriptor = getXClass().getSuperclassDescriptor();
+        if(superclassDescriptor != null && !superclassDescriptor.getClassName().equals("java/lang/Object")) {
+            sawCall(new MethodCall(new MethodDescriptor(superclassDescriptor.getClassName(), "<clinit>", "()V", true), TARGET_THIS), false);
+        }
+    }
+
+    private void handleStatus() {
+        statusMap.put(getMethodDescriptor(), status);
+        if(status == SideEffectStatus.UNSURE || status == SideEffectStatus.UNSURE_OBJECT_ONLY) {
+            calledMethods.trimToSize();
+            callGraph.put(getMethodDescriptor(), calledMethods);
+        } else {
+            fieldsModifyingMethods.remove(getMethodDescriptor());
+        }
+    }
+
+    @Override
+    public void visit(Code obj) {
+        uselessVoidCandidate = !classInit && !constructor && !getXMethod().isSynthetic() && Type.getReturnType(getMethodSig()) == Type.VOID;
+        byte[] code = obj.getCode();
+        if(code.length == 4 && (code[0] & 0xFF) == GETSTATIC && (code[3] & 0xFF) == ARETURN) {
+            getStaticMethods.add(getMethodDescriptor());
+            handleStatus();
+            return;
+        }
+
+        if (code.length <= 2 && !getXMethod().isStatic() && (getXMethod().isPublic() || getXMethod().isProtected())
+                && !getXMethod().isFinal() && (getXClass().isPublic() || getXClass().isProtected())) {
+            for(byte[] stubMethod : STUB_METHODS) {
+                if (Arrays.equals(stubMethod, code)
+                        && (getClassName().endsWith("Visitor") || getClassName().endsWith("Listener") || !hasOtherImplementations(getXMethod()))) {
+                    // stub method which can be extended: assume it can be extended with possible side-effect
+                    status = SideEffectStatus.SIDE_EFFECT;
+                    handleStatus();
+                    return;
+                }
+            }
+        }
+        if (statusMap.containsKey(getMethodDescriptor())) {
+            return;
+        }
+        finallyTargets = new HashSet<>();
+        for(CodeException ex : getCode().getExceptionTable()) {
+            if(ex.getCatchType() == 0) {
+                finallyTargets.add(ex.getHandlerPC());
+            }
+        }
+        finallyExceptionRegisters = new HashSet<>();
+        try {
+            super.visit(obj);
+        } catch (EarlyExitException e) {
+            // Ignore
+        }
+        if (uselessVoidCandidate && code.length > 1
+                && (status == SideEffectStatus.UNSURE || status == SideEffectStatus.NO_SIDE_EFFECT)) {
+            uselessVoidCandidates.add(getMethodDescriptor());
+        }
+        handleStatus();
+    }
+
+    @Override
+    public void sawOpcode(int seen) {
+        if (!allowedFields.isEmpty() && seen == PUTFIELD) {
+            Item objItem = getStack().getStackItem(1);
+            if (objItem.getRegisterNumber() == 0) {
+                if (allowedFields.contains(getFieldDescriptorOperand())) {
+                    Item valueItem = getStack().getStackItem(0);
+                    if (!isNew(valueItem) && !valueItem.isNull()) {
+                        allowedFields.remove(getFieldDescriptorOperand());
+                    }
+                }
+            }
+        }
+        if (status == SideEffectStatus.SIDE_EFFECT && allowedFields.isEmpty()) {
+            // Nothing to do: skip the rest of the method
+            throw new EarlyExitException();
+        }
+        if (status == SideEffectStatus.SIDE_EFFECT) {
+            return;
+        }
+        switch (seen) {
+        case ASTORE:
+        case ASTORE_0:
+        case ASTORE_1:
+        case ASTORE_2:
+        case ASTORE_3:
+            if(finallyTargets.contains(getPC())) {
+                finallyExceptionRegisters.add(getRegisterOperand());
+            }
+            break;
+        case ATHROW: {
+            Item exceptionItem = getStack().getStackItem(0);
+            if(!finallyExceptionRegisters.remove(exceptionItem.getRegisterNumber())) {
+                uselessVoidCandidate = false;
+                try {
+                    JavaClass javaClass = exceptionItem.getJavaClass();
+                    if (javaClass != null && ALLOWED_EXCEPTIONS.contains(javaClass.getClassName())) {
+                        break;
+                    }
+                } catch (ClassNotFoundException e) {
+                }
+                status = SideEffectStatus.SIDE_EFFECT;
+            }
+            break;
+        }
+        case PUTSTATIC:
+            if(classInit) {
+                if(getClassConstantOperand().equals(getClassName())) {
+                    break;
+                }
+            }
+            status = SideEffectStatus.SIDE_EFFECT;
+            break;
+        case INVOKEDYNAMIC:
+            status = SideEffectStatus.SIDE_EFFECT;
+            break;
+        case PUTFIELD:
+            sawCall(getMethodCall(FIELD_STORE_STUB_METHOD), false);
+            break;
+        case AASTORE:
+        case DASTORE:
+        case CASTORE:
+        case BASTORE:
+        case IASTORE:
+        case LASTORE:
+        case FASTORE:
+        case SASTORE:
+            sawCall(getMethodCall(ARRAY_STORE_STUB_METHOD), false);
+            break;
+        case INVOKESTATIC:
+            if (changesOnlyNewObjects(getMethodDescriptorOperand())) {
+                break;
+            }
+            sawCall(new MethodCall(getMethodDescriptorOperand(), TARGET_OTHER), false);
+            break;
+        case INVOKESPECIAL:
+        case INVOKEINTERFACE:
+        case INVOKEVIRTUAL: {
+            XMethod xMethodOperand = getXMethodOperand();
+            MethodDescriptor methodDescriptorOperand = xMethodOperand == null ? getMethodDescriptorOperand() : xMethodOperand
+                    .getMethodDescriptor();
+            if (changesOnlyNewObjects(getMethodDescriptorOperand())) {
+                break;
+            }
+            MethodCall methodCall = getMethodCall(methodDescriptorOperand);
+            sawCall(methodCall, false);
+            break;
+        }
+        default:
+            break;
+        }
+    }
+
+    private MethodCall getMethodCall(MethodDescriptor methodDescriptorOperand) {
+        Item objItem = getStack().getStackItem(getNumberArguments(methodDescriptorOperand.getSignature()));
+        if (isNew(objItem)) {
+            return new MethodCall(methodDescriptorOperand, TARGET_NEW);
+        }
+        if (objItem.getRegisterNumber() == 0 && !getMethod().isStatic()) {
+            return new MethodCall(methodDescriptorOperand, constructor ? TARGET_NEW : TARGET_THIS);
+        }
+        XField xField = objItem.getXField();
+        if (xField != null) {
+            if (classInit && xField.isStatic() && xField.getClassDescriptor().getClassName().equals(getClassName())) {
+                return new MethodCall(methodDescriptorOperand, TARGET_NEW);
+            }
+            if (!getMethodDescriptor().isStatic() && objItem.getFieldLoadedFromRegister() == 0
+                    && allowedFields.contains(xField.getFieldDescriptor())) {
+                fieldsModifyingMethods.add(getMethodDescriptor());
+                return new MethodCall(methodDescriptorOperand, xField.getFieldDescriptor());
+            }
+        }
+        return new MethodCall(methodDescriptorOperand, TARGET_OTHER);
+    }
+
+    private void sawCall(MethodCall methodCall, boolean finalPass) {
+        if (status == SideEffectStatus.SIDE_EFFECT) {
+            return;
+        }
+        MethodDescriptor methodDescriptor = methodCall.getMethod();
+        if (hasNoSideEffect(methodDescriptor)) {
+            sawNoSideEffectCall(methodDescriptor);
+            return;
+        }
+        FieldDescriptor target = methodCall.getTarget();
+        SideEffectStatus calledStatus = isObjectOnlyMethod(methodDescriptor) ? SideEffectStatus.OBJECT_ONLY : statusMap
+                .get(methodDescriptor);
+        if (calledStatus == null) {
+            calledStatus = finalPass ? hasNoSideEffectUnknown(methodDescriptor) ? SideEffectStatus.NO_SIDE_EFFECT : SideEffectStatus.SIDE_EFFECT
+                    : SideEffectStatus.UNSURE;
+        }
+        switch(calledStatus) {
+        case NO_SIDE_EFFECT:
+            sawNoSideEffectCall(methodDescriptor);
+            return;
+        case SIDE_EFFECT:
+            status = SideEffectStatus.SIDE_EFFECT;
+            return;
+        case OBJECT_ONLY:
+            if(target == TARGET_THIS) {
+                status = status.toObjectOnly();
+            } else if(target == TARGET_OTHER) {
+                status = SideEffectStatus.SIDE_EFFECT;
+            } else if(target != TARGET_NEW) {
+                status = status.toObjectOnly();
+                sawUnsureCall(methodCall);
+            }
+            return;
+        case UNSURE_OBJECT_ONLY:
+            if(target == TARGET_NEW) {
+                sawUnsureCall(methodCall);
+            } else if(target == TARGET_OTHER) {
+                status = SideEffectStatus.SIDE_EFFECT;
+            } else {
+                status = status.toObjectOnly();
+                sawUnsureCall(methodCall);
+            }
+            return;
+        case UNSURE:
+            sawUnsureCall(methodCall);
+            return;
+        }
+    }
+
+    /**
+     * @param methodDescriptor
+     */
+    private void sawNoSideEffectCall(MethodDescriptor methodDescriptor) {
+        if(uselessVoidCandidate && Type.getReturnType(methodDescriptor.getSignature()) == Type.VOID
+                && !methodDescriptor.getName().equals("<init>")) {
+            /* To reduce false-positives we do not mark method as useless void if it calls
+             * another useless void method. If that another method also in the scope of our project
+             * then we will report it instead. If there's a cycle of no-side-effect calls, then
+             * it's probably some delegation pattern and methods can be extended in future/derived
+             * projects to do something useful.
+             */
+            uselessVoidCandidate = false;
+        }
+    }
+
+    private void sawUnsureCall(MethodCall methodCall) {
+        calledMethods.add(methodCall);
+        status = status.toUnsure();
+    }
+
+    /**
+     * @param item stack item to check
+     * @return true if this stack item is known to be newly created
+     */
+    private static boolean isNew(OpcodeStack.Item item) {
+        if(item.isNewlyAllocated()) {
+            return true;
+        }
+        XMethod returnValueOf = item.getReturnValueOf();
+        if(returnValueOf == null) {
+            return false;
+        }
+        if("iterator".equals(returnValueOf.getName())
+                && "()Ljava/util/Iterator;".equals(returnValueOf.getSignature())
+                && Subtypes2.instanceOf(returnValueOf.getClassName(), "java.lang.Iterable")) {
+            return true;
+        }
+        if(returnValueOf.getClassName().startsWith("[") && returnValueOf.getName().equals("clone")) {
+            return true;
+        }
+        if(NEW_OBJECT_RETURNING_METHODS.contains(returnValueOf.getMethodDescriptor())) {
+            return true;
+        }
+        return false;
+    }
+
+    private boolean changesOnlyNewObjects(MethodDescriptor methodDescriptor) {
+        int arg = changedArg(methodDescriptor);
+        if(arg == -1) {
+            return false;
+        }
+        int nArgs = getNumberArguments(methodDescriptor.getSignature());
+        if(!isNew(getStack().getStackItem(nArgs-arg-1))) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * @param m method to check
+     * @return array of argument numbers (0-based) which this method writes into or null if we don't know anything about this method
+     */
+    private static int changedArg(MethodDescriptor m) {
+        if(m.equals(ARRAY_COPY)) {
+            return 2;
+        }
+        if(m.getName().equals("toArray") && m.getSignature().equals("([Ljava/lang/Object;)[Ljava/lang/Object;")
+                && Subtypes2.instanceOf(m.getClassDescriptor(), "java.util.Collection")) {
+            return 0;
+        }
+        if ((m.getName().equals("sort") || m.getName().equals("fill") || m.getName().equals("reverse") || m.getName().equals(
+                "shuffle"))
+                && (m.getSlashedClassName().equals("java/util/Arrays") || m.getSlashedClassName().equals("java/util/Collections"))) {
+            return 0;
+        }
+        return -1;
+    }
+
+    /**
+     * @param m method to check
+     * @return true if given method is known to have no side effects
+     */
+    private static boolean hasNoSideEffect(MethodDescriptor m) {
+        String className = m.getSlashedClassName();
+        if("java/lang/String".equals(className)) {
+            return !(m.getName().equals("getChars") || (m.getName().equals("getBytes") && m.getSignature().equals("(II[BI)V")));
+        }
+        if("java/lang/Math".equals(className)) {
+            return !m.getName().equals("random");
+        }
+        if("java/lang/Throwable".equals(className)) {
+            return m.getName().startsWith("get");
+        }
+        if("java/lang/Character".equals(className)) {
+            return !m.getName().equals("toChars");
+        }
+        if("java/lang/Class".equals(className) && m.getName().startsWith("is")) {
+            return true;
+        }
+        if("java/awt/Color".equals(className) && m.getName().equals("<init>")) {
+            return true;
+        }
+        if("java/util/regex/Pattern".contains(className)) {
+            // Pattern.compile is often used to check the PatternSyntaxException, thus we consider it as side-effect method
+            return !m.getName().equals("compile") && !m.getName().equals("<init>");
+        }
+        if(className.startsWith("[") && m.getName().equals("clone")) {
+            return true;
+        }
+        if(className.startsWith("org/w3c/dom/") && (m.getName().startsWith("get") || m.getName().startsWith("has") || m.getName().equals("item"))) {
+            return true;
+        }
+        if(className.startsWith("java/util/") &&
+                (className.endsWith("Set") || className.endsWith("Map") || className.endsWith("Collection")
+                        || className.endsWith("List") || className.endsWith("Queue") || className.endsWith("Deque")
+                        || className.endsWith("Vector")) || className.endsWith("Hashtable") || className.endsWith("Dictionary")) {
+            // LinkedHashSet in accessOrder mode changes internal state during get/getOrDefault
+            if(className.equals("java/util/LinkedHashMap") && m.getName().startsWith("get")) {
+                return false;
+            }
+            if(NO_SIDE_EFFECT_COLLECTION_METHODS.contains(m.getName()) || (m.getName().equals("toArray") && m.getSignature().equals("()[Ljava/lang/Object;"))) {
+                return true;
+            }
+        }
+        if(m.getName().equals("binarySearch") && (m.getSlashedClassName().equals("java/util/Arrays") || m.getSlashedClassName().equals("java/util/Collections"))) {
+            return true;
+        }
+        if(m.getName().startsWith("$SWITCH_TABLE$")) {
+            return true;
+        }
+        if(m.getName().equals("<init>") && isObjectOnlyClass(className)) {
+            return true;
+        }
+        if(m.getName().equals("toString") && m.getSignature().equals("()Ljava/lang/String;") && m.getSlashedClassName().startsWith("java/")) {
+            return true;
+        }
+        if(NUMBER_CLASSES.contains(className)) {
+            return !m.getSignature().startsWith("(Ljava/lang/String;");
+        }
+        if(!m.isStatic() && m.getName().equals("equals") &&
+                m.getSignature().equals("(Ljava/lang/Object;)Z")) {
+            return true;
+        }
+        if(NO_SIDE_EFFECT_METHODS.contains(m)) {
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * @param m method to check
+     * @return true if we may assume that given unseen method has no side effect
+     */
+    private static boolean hasNoSideEffectUnknown(MethodDescriptor m) {
+        if(m.isStatic() && m.getName().equals("<clinit>")) {
+            // No side effect for class initializer of unseen class
+            return true;
+        }
+        if(!m.isStatic() && m.getName().equals("toString") && m.getSignature().equals("()Ljava/lang/String;")) {
+            // We assume no side effect for unseen toString methods
+            return true;
+        }
+        if(!m.isStatic() && m.getName().equals("hashCode") && m.getSignature().equals("()I")) {
+            // We assume no side effect for unseen hashCode methods
+            return true;
+        }
+        if(m.isStatic() && m.getName().equals("values") && m.getSignature().startsWith("()")) {
+            // We assume no side effect for unseen enums
+            return Subtypes2.instanceOf(m.getClassDescriptor(), "java.lang.Enum");
+        }
+        return false;
+    }
+
+    /**
+     * @param m method to check
+     * @return true if given method is known to change its object only
+     */
+    private static boolean isObjectOnlyMethod(MethodDescriptor m) {
+        if (m.isStatic() || m.getName().equals("<init>")) {
+            return false;
+        }
+        String className = m.getSlashedClassName();
+        if(isObjectOnlyClass(className)) {
+            return true;
+        }
+        if(className.startsWith("javax/xml/") && m.getName().startsWith("next")) {
+            return true;
+        }
+        if ((className.startsWith("java/net/") || className.startsWith("javax/servlet"))
+                && (m.getName().startsWith("remove") || m.getName().startsWith("add") || m.getName().startsWith("set"))) {
+            return true;
+        }
+        if(OBJECT_ONLY_METHODS.contains(m)) {
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * @param className class to check
+     * @return true if all methods of this class are known to be object-only or no-side-effect
+     */
+    private static boolean isObjectOnlyClass(String className) {
+        if(OBJECT_ONLY_CLASSES.contains(className)) {
+            return true;
+        }
+        if(className.startsWith("java/lang/") && (className.endsWith("Error") || className.endsWith("Exception"))) {
+            return true;
+        }
+        return className.startsWith("java/util/") &&
+                (className.endsWith("Set") || className.endsWith("Map") || className.endsWith("Collection")
+                        || className.endsWith("List") || className.endsWith("Queue") || className.endsWith("Deque")
+                        || className.endsWith("Vector"));
+    }
+
+    @Override
+    public void report() {
+        computeFinalStatus();
+        Set<String> sideEffectClinit = new HashSet<>();
+        for(Entry<MethodDescriptor, SideEffectStatus> entry : statusMap.entrySet()) {
+            if (entry.getValue() == SideEffectStatus.SIDE_EFFECT && entry.getKey().isStatic() && entry.getKey().getName().equals("<clinit>")) {
+                sideEffectClinit.add(entry.getKey().getSlashedClassName());
+            }
+        }
+        for(Entry<MethodDescriptor, SideEffectStatus> entry : statusMap.entrySet()) {
+            MethodDescriptor m = entry.getKey();
+            if (entry.getValue() == SideEffectStatus.NO_SIDE_EFFECT) {
+                String returnType = new SignatureParser(m.getSignature()).getReturnTypeSignature();
+                if (!returnType.equals("V") || m.getName().equals("<init>")) {
+                    if(m.equals(GET_CLASS)) {
+                        /* We do not mark getClass() call as pure, because it can appear in code like this:
+                            public class Outer {
+                              public class Inner {}
+                              public void test(Outer n) { n.new Inner(); }
+                            }
+                            The test method is compiled into (assumably it's done to generate NPE if n is null)
+                               0: new           #16                 // class a/Outer$Inner
+                               3: aload_1
+                               4: dup
+                               5: invokevirtual #18                 // Method java/lang/Object.getClass:()Ljava/lang/Class;
+                               8: pop
+                               9: invokespecial #22                 // Method a/Outer$Inner."<init>":(La/Outer;)V
+                              12: return
+                            So we would have a false-positive here
+                         */
+                        continue;
+                    }
+                    if (m.getName().startsWith("access$") && (!(m instanceof XMethod) || ((XMethod)m).getAccessMethodForMethod() == null)) {
+                        /* We skip field access methods, because they can unnecessarily be used for static calls
+                         * (probably by older javac)
+                         */
+                        continue;
+                    }
+                    if (m.getName().startsWith("jjStopStringLiteral")) {
+                        /* Some old JJTree versions may generate redundant calls to this method
+                         * Skip it as reports in generated code don't help much
+                         */
+                        continue;
+                    }
+                    if (m.isStatic() || m.getName().equals("<init>")) {
+                        if(sideEffectClinit.contains(m.getSlashedClassName())) {
+                            /* Skip static methods and constructors for classes which have
+                             * side-effect class initializer
+                             */
+                            noSideEffectMethods.add(m, MethodSideEffectStatus.SE_CLINIT);
+                            continue;
+                        }
+                    }
+                    if(m.equals(CLASS_GET_NAME) // used sometimes to trigger class loading
+                            || m.equals(HASH_CODE) // found intended hashCode call several times in different projects, need further research
+                            ) {
+                        noSideEffectMethods.add(m, MethodSideEffectStatus.NSE_EX);
+                        continue;
+                    }
+                    if (m.isStatic() && getStaticMethods.contains(m) && !m.getSlashedClassName().startsWith("java/")) {
+                        String returnSlashedClassName = ClassName.fromFieldSignature(returnType);
+                        if(returnSlashedClassName != null) {
+                            String returnClass = ClassName.toDottedClassName(returnSlashedClassName);
+                            if(ClassName.extractPackageName(returnClass).equals(m.getClassDescriptor().getPackageName())) {
+                                /* Skip methods which only retrieve static field from the same package
+                                 * As they as often used to trigger class initialization
+                                 */
+                                noSideEffectMethods.add(m, MethodSideEffectStatus.NSE_EX);
+                                continue;
+                            }
+                        }
+                    }
+                    noSideEffectMethods.add(m, MethodSideEffectStatus.NSE);
+                } else {    // void methods
+                    if(uselessVoidCandidates.contains(m)) {
+                        if(m.getName().equals("maybeForceBuilderInitialization") && m.getSignature().equals("()V")) {
+                            // Autogenerated by Google protocol buffer compiler
+                            continue;
+                        }
+                        noSideEffectMethods.add(m, MethodSideEffectStatus.USELESS);
+                    }
+                }
+            } else if(entry.getValue() == SideEffectStatus.OBJECT_ONLY) {
+                noSideEffectMethods.add(m, MethodSideEffectStatus.OBJ);
+            }
+        }
+    }
+
+    /**
+     * @param xMethod
+     * @return true if this has other implementations
+     */
+    private static boolean hasOtherImplementations(XMethod xMethod) {
+        Set<XMethod> superMethods = Hierarchy2.findSuperMethods(xMethod);
+        superMethods.add(xMethod);
+        Subtypes2 subtypes2 = AnalysisContext.currentAnalysisContext().getSubtypes2();
+        Set<ClassDescriptor> subtypes = new HashSet<>();
+        for(XMethod superMethod : superMethods) {
+            try {
+                subtypes.addAll(subtypes2.getSubtypes(superMethod.getClassDescriptor()));
+            } catch (ClassNotFoundException e) {
+                // ignore
+            }
+        }
+        subtypes.remove(xMethod.getClassDescriptor());
+        for (ClassDescriptor subtype : subtypes) {
+            try {
+                XClass xClass = subtype.getXClass();
+                XMethod subMethod = xClass.findMatchingMethod(xMethod.getMethodDescriptor());
+                if (subMethod != null) {
+                    if(!subMethod.isAbstract() ) {
+                        return true;
+                    }
+                }
+            } catch (CheckedAnalysisException e) {
+                // ignore
+            }
+        }
+        return false;
+    }
+
+    private void computeFinalStatus() {
+        boolean changed = true;
+        while (changed) {
+            changed = false;
+            Iterator<Entry<MethodDescriptor, List<MethodCall>>> iterator = callGraph.entrySet().iterator();
+            while (iterator.hasNext()) {
+                Entry<MethodDescriptor, List<MethodCall>> entry = iterator.next();
+                MethodDescriptor method = entry.getKey();
+                uselessVoidCandidate = uselessVoidCandidates.contains(method);
+                SideEffectStatus prevStatus = statusMap.get(method);
+                status = prevStatus.toSure();
+                calledMethods = new ArrayList<>();
+                for(MethodCall methodCall : entry.getValue()) {
+                    sawCall(methodCall, true);
+                    if(status == SideEffectStatus.SIDE_EFFECT) {
+                        break;
+                    }
+                }
+                if (!uselessVoidCandidate || (status != SideEffectStatus.UNSURE && status != SideEffectStatus.NO_SIDE_EFFECT)) {
+                    uselessVoidCandidates.remove(method);
+                }
+                if (status != prevStatus || !entry.getValue().equals(calledMethods)) {
+                    statusMap.put(method, status);
+                    if (status.unsure()) {
+                        entry.setValue(calledMethods);
+                    } else {
+                        iterator.remove();
+                    }
+                    changed = true;
+                }
+            }
+        }
+        for(Entry<MethodDescriptor, List<MethodCall>> entry : callGraph.entrySet()) {
+            MethodDescriptor method = entry.getKey();
+            status = statusMap.get(method);
+            if(status == SideEffectStatus.UNSURE) {
+                boolean safeCycle = true;
+                for(MethodCall methodCall : entry.getValue()) {
+                    SideEffectStatus calledStatus = statusMap.get(methodCall.getMethod());
+                    if(calledStatus != SideEffectStatus.UNSURE && calledStatus != SideEffectStatus.NO_SIDE_EFFECT) {
+                        safeCycle = false;
+                        break;
+                    }
+                }
+                if(safeCycle) {
+                    statusMap.put(method, SideEffectStatus.NO_SIDE_EFFECT);
+                    uselessVoidCandidate = uselessVoidCandidates.contains(method);
+                    if(uselessVoidCandidate) {
+                        for(MethodCall call : entry.getValue()) {
+                            uselessVoidCandidate = false;
+                            if((call.getMethod().equals(method) && call.getTarget() == TARGET_THIS) || method.isStatic()) {
+                                uselessVoidCandidate = true;
+                            } else {
+                                if(call.getMethod() instanceof XMethod) {
+                                    XMethod xMethod = (XMethod) call.getMethod();
+                                    if(xMethod.isFinal() || (!xMethod.isPublic() && !xMethod.isProtected())) {
+                                        uselessVoidCandidate = true;
+                                    }
+                                }
+                            }
+                            if(!uselessVoidCandidate) {
+                                break;
+                            }
+                        }
+                        if(!uselessVoidCandidate) {
+                            uselessVoidCandidates.remove(method);
+                        }
+                    }
+                }
+            }
+        }
+    }
+}
diff --git a/FindNonSerializableStoreIntoSession.java b/FindNonSerializableStoreIntoSession.java
index d2fb211f7975087887e159a9fc6cc8c424162fa5..ac1502716fd9a0521eae8872f2ee898ea2baa779 100644
--- a/FindNonSerializableStoreIntoSession.java
+++ b/FindNonSerializableStoreIntoSession.java
@@ -98,11 +98,11 @@ public class FindNonSerializableStoreIntoSession implements Detector {
 
             INVOKEINTERFACE invoke = (INVOKEINTERFACE) ins;
             String mName = invoke.getMethodName(cpg);
-            if (!mName.equals("setAttribute")) {
+            if (!"setAttribute".equals(mName)) {
                 continue;
             }
             String cName = invoke.getClassName(cpg);
-            if (!cName.equals("javax.servlet.http.HttpSession")) {
+            if (!"javax.servlet.http.HttpSession".equals(cName)) {
                 continue;
             }
 
diff --git a/FindNonSerializableValuePassedToWriteObject.java b/FindNonSerializableValuePassedToWriteObject.java
index 96846f843832d74d12f577b3273dc355090422a3..db9ecc7b620c7322a10f4c0d19cd1f9c49544715 100644
--- a/FindNonSerializableValuePassedToWriteObject.java
+++ b/FindNonSerializableValuePassedToWriteObject.java
@@ -94,11 +94,11 @@ public class FindNonSerializableValuePassedToWriteObject implements Detector {
 
             InvokeInstruction invoke = (InvokeInstruction) ins;
             String mName = invoke.getMethodName(cpg);
-            if (!mName.equals("writeObject")) {
+            if (!"writeObject".equals(mName)) {
                 continue;
             }
             String cName = invoke.getClassName(cpg);
-            if (!cName.equals("java.io.ObjectOutput") && !cName.equals("java.io.ObjectOutputStream")) {
+            if (!"java.io.ObjectOutput".equals(cName) && !"java.io.ObjectOutputStream".equals(cName)) {
                 continue;
             }
 
diff --git a/FindNonShortCircuit.java b/FindNonShortCircuit.java
index 3fd051718e6bac84d28868418541ce94f9ffce61..ab4eb7a1d674c42395ef692c7cd887affc6f5268 100644
--- a/FindNonShortCircuit.java
+++ b/FindNonShortCircuit.java
@@ -116,7 +116,7 @@ public class FindNonShortCircuit extends OpcodeStackDetector implements Stateles
             break;
 
         case INVOKEVIRTUAL:
-            if (getNameConstantOperand().equals("length") && getClassConstantOperand().equals("java/lang/String")) {
+            if ("length".equals(getNameConstantOperand()) && "java/lang/String".equals(getClassConstantOperand())) {
                 break;
             }
             sawDanger = true;
diff --git a/FindNullDeref.java b/FindNullDeref.java
index a7c78b331563c0a29a1f7b38aae15e49dd4331ac..a9a03557dcbc8993e119285de1ef8614b5b93a3f 100644
--- a/FindNullDeref.java
+++ b/FindNullDeref.java
@@ -246,7 +246,7 @@ public class FindNullDeref implements Detector, UseAnnotationDatabase, NullDeref
 
             if (value instanceof Type) {
                 String className = ((Type) value).getClassName();
-                if (className.equals("java.lang.NullPointerException")) {
+                if ("java.lang.NullPointerException".equals(className)) {
                     return;
                 }
             }
@@ -384,7 +384,7 @@ public class FindNullDeref implements Detector, UseAnnotationDatabase, NullDeref
         // Don't check equals() calls.
         // If an equals() call unconditionally dereferences the parameter,
         // it is the fault of the method, not the caller.
-        if (methodName.equals("equals") && signature.equals("(Ljava/lang/Object;)Z")) {
+        if ("equals".equals(methodName) && "(Ljava/lang/Object;)Z".equals(signature)) {
             return;
         }
 
@@ -394,7 +394,7 @@ public class FindNullDeref implements Detector, UseAnnotationDatabase, NullDeref
         }
         String paramList = signature.substring(0, returnTypeStart + 1);
 
-        if (paramList.equals("()") || (paramList.indexOf('L') < 0 && paramList.indexOf('[') < 0)) {
+        if ("()".equals(paramList) || (paramList.indexOf('L') < 0 && paramList.indexOf('[') < 0)) {
             // Method takes no arguments, or takes no reference arguments
             return;
         }
@@ -546,10 +546,10 @@ public class FindNullDeref implements Detector, UseAnnotationDatabase, NullDeref
                 priority = HIGH_PRIORITY;
             }
             String methodName = method.getName();
-            if (methodName.equals("clone")) {
+            if ("clone".equals(methodName)) {
                 bugPattern = "NP_CLONE_COULD_RETURN_NULL";
                 priority = NORMAL_PRIORITY;
-            } else if (methodName.equals("toString")) {
+            } else if ("toString".equals(methodName)) {
                 bugPattern = "NP_TOSTRING_COULD_RETURN_NULL";
                 priority = NORMAL_PRIORITY;
             }
@@ -606,7 +606,7 @@ public class FindNullDeref implements Detector, UseAnnotationDatabase, NullDeref
     private boolean safeCallToPrimateParseMethod(XMethod calledMethod, Location location) {
         int position = location.getHandle().getPosition();
 
-        if (calledMethod.getClassName().equals("java.lang.Integer")) {
+        if ("java.lang.Integer".equals(calledMethod.getClassName())) {
 
             ConstantPool constantPool = classContext.getJavaClass().getConstantPool();
             Code code = method.getCode();
@@ -764,7 +764,7 @@ public class FindNullDeref implements Detector, UseAnnotationDatabase, NullDeref
         // Check which params might be null
         addParamAnnotations(location, definitelyNullArgSet, unconditionallyDereferencedNullArgSet, propertySet, warning);
 
-        if (bugType.equals("NP_NULL_PARAM_DEREF_ALL_TARGETS_DANGEROUS")) {
+        if ("NP_NULL_PARAM_DEREF_ALL_TARGETS_DANGEROUS".equals(bugType)) {
             // Add annotations for dangerous method call targets
             for (JavaClassAndMethod dangerousCallTarget : veryDangerousCallTargetList) {
                 warning.addMethod(dangerousCallTarget).describe(MethodAnnotation.METHOD_DANGEROUS_TARGET_ACTUAL_GUARANTEED_NULL);
@@ -953,8 +953,8 @@ public class FindNullDeref implements Detector, UseAnnotationDatabase, NullDeref
         Instruction ins = location.getHandle().getInstruction();
         if (ins instanceof InvokeInstruction && refValue.isDefinitelyNull()) {
             InvokeInstruction iins = (InvokeInstruction) ins;
-            if (iins.getMethodName(classContext.getConstantPoolGen()).equals("close")
-                    && iins.getSignature(classContext.getConstantPoolGen()).equals("()V")) {
+            if ("close".equals(iins.getMethodName(classContext.getConstantPoolGen()))
+                    && "()V".equals(iins.getSignature(classContext.getConstantPoolGen()))) {
                 propertySet.addProperty(NullDerefProperty.CLOSING_NULL);
             }
         }
@@ -991,7 +991,7 @@ public class FindNullDeref implements Detector, UseAnnotationDatabase, NullDeref
                 priority++;
             }
 
-            if (method.getName().equals("equals") && method.getSignature().equals("(Ljava/lang/Object;)Z")) {
+            if ("equals".equals(method.getName()) && "(Ljava/lang/Object;)Z".equals(method.getSignature())) {
                 if (caught) {
                     return;
                 }
@@ -1251,7 +1251,7 @@ public class FindNullDeref implements Detector, UseAnnotationDatabase, NullDeref
                 if (variableAnnotation instanceof LocalVariableAnnotation) {
                     LocalVariableAnnotation local = (LocalVariableAnnotation) variableAnnotation;
                     if (!local.isNamed()) {
-                        if (warning.equals("RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE")) {
+                        if ("RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE".equals(warning)) {
                             return;
                         }
                         priority++;
@@ -1271,7 +1271,7 @@ public class FindNullDeref implements Detector, UseAnnotationDatabase, NullDeref
                 BugInstance.getFieldOrMethodValueSource(item1), BugInstance.getFieldOrMethodValueSource(item2));
 
         if (!foundSource) {
-            if (warning.equals("RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE")) {
+            if ("RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE".equals(warning)) {
                 return;
             }
             bugInstance.setPriority(priority+1);
@@ -1527,10 +1527,10 @@ public class FindNullDeref implements Detector, UseAnnotationDatabase, NullDeref
                 bugType = "NP_NONNULL_RETURN_VIOLATION";
                 String methodName = method.getName();
                 String methodSig = method.getSignature();
-                if (methodName.equals("clone") && methodSig.equals("()Ljava/lang/Object;")) {
+                if ("clone".equals(methodName) && "()Ljava/lang/Object;".equals(methodSig)) {
                     bugType = "NP_CLONE_COULD_RETURN_NULL";
                     priority = NORMAL_PRIORITY;
-                } else if (methodName.equals("toString") && methodSig.equals("()Ljava/lang/String;")) {
+                } else if ("toString".equals(methodName) && "()Ljava/lang/String;".equals(methodSig)) {
                     bugType = "NP_TOSTRING_COULD_RETURN_NULL";
                     priority = NORMAL_PRIORITY;
                 }
@@ -1568,7 +1568,7 @@ public class FindNullDeref implements Detector, UseAnnotationDatabase, NullDeref
             }
         }
         if (hasManyNullTests) {
-            if (bugType.equals("NP_NULL_ON_SOME_PATH") || bugType.equals("NP_GUARANTEED_DEREF")) {
+            if ("NP_NULL_ON_SOME_PATH".equals(bugType) || "NP_GUARANTEED_DEREF".equals(bugType)) {
                 bugType = "NP_NULL_ON_SOME_PATH_MIGHT_BE_INFEASIBLE";
             } else {
                 priority++;
@@ -1606,7 +1606,7 @@ public class FindNullDeref implements Detector, UseAnnotationDatabase, NullDeref
 
         propertySet.decorateBugInstance(bugInstance);
 
-        if (bugType.equals("NP_DEREFERENCE_OF_READLINE_VALUE")) {
+        if ("NP_DEREFERENCE_OF_READLINE_VALUE".equals(bugType)) {
 
             int source = -9999;
             if (knownNullLocations.size() == 1) {
diff --git a/FindOpenStream.java b/FindOpenStream.java
index ad46c9d3572dcff6abdb3de276b47b7bd230578e..1ca9b000cc9637fd0e155e6ad7fb731b693e24de 100644
--- a/FindOpenStream.java
+++ b/FindOpenStream.java
@@ -324,7 +324,7 @@ public final class FindOpenStream extends ResourceTrackingDetector<Stream, Strea
     }
 
     public static boolean isMainMethod(Method method) {
-        return method.isStatic() && method.getName().equals("main") && method.getSignature().equals("([Ljava/lang/String;)V");
+        return method.isStatic() && "main".equals(method.getName()) && "([Ljava/lang/String;)V".equals(method.getSignature());
     }
 
     @Override
diff --git a/FindPuzzlers.java b/FindPuzzlers.java
index f99f5dd4384e67bff82a6c0ad0831f05ef1131a8..ee76221993d58787dbfb354fc87ffb2a10fb8257 100644
--- a/FindPuzzlers.java
+++ b/FindPuzzlers.java
@@ -190,15 +190,15 @@ public class FindPuzzlers extends OpcodeStackDetector {
         }
         becameTop = -1;
 
-        if (seen == INVOKESPECIAL && getNameConstantOperand().equals("<init>") && getSigConstantOperand().equals("(Ljava/util/Collection;)V")
+        if (seen == INVOKESPECIAL && "<init>".equals(getNameConstantOperand()) && "(Ljava/util/Collection;)V".equals(getSigConstantOperand())
                 && getClassConstantOperand().contains("Set")
-                || (seen == INVOKEVIRTUAL || seen == INVOKEINTERFACE) && getNameConstantOperand().equals("addAll") && getSigConstantOperand().equals("(Ljava/util/Collection;)Z")) {
+                || (seen == INVOKEVIRTUAL || seen == INVOKEINTERFACE) && "addAll".equals(getNameConstantOperand()) && "(Ljava/util/Collection;)Z".equals(getSigConstantOperand())) {
             OpcodeStack.Item top = stack.getStackItem(0);
             XMethod returnValueOf = top.getReturnValueOf();
-            if (returnValueOf != null && returnValueOf.getName().equals("entrySet")) {
+            if (returnValueOf != null && "entrySet".equals(returnValueOf.getName())) {
                 String name = returnValueOf.getClassName();
                 int priority = Priorities.LOW_PRIORITY;
-                if (name.equals("java.util.Map")) {
+                if ("java.util.Map".equals(name)) {
                     priority = Priorities.NORMAL_PRIORITY;
                 } else if (name.equals(EnumMap.class.getName())
                         || name.equals(IdentityHashMap.class.getName())) {
@@ -211,7 +211,7 @@ public class FindPuzzlers extends OpcodeStackDetector {
 
         }
 
-        if (seen == INVOKEVIRTUAL && getNameConstantOperand().equals("hashCode") && getSigConstantOperand().equals("()I")
+        if (seen == INVOKEVIRTUAL && "hashCode".equals(getNameConstantOperand()) && "()I".equals(getSigConstantOperand())
                 && stack.getStackDepth() > 0) {
             OpcodeStack.Item item0 = stack.getStackItem(0);
             if (item0.getSignature().charAt(0) == '[') {
@@ -268,7 +268,7 @@ public class FindPuzzlers extends OpcodeStackDetector {
             }
         }
 
-        if (getMethodName().equals("<clinit>") && (seen == PUTSTATIC || seen == GETSTATIC || seen == INVOKESTATIC)) {
+        if ("<clinit>".equals(getMethodName()) && (seen == PUTSTATIC || seen == GETSTATIC || seen == INVOKESTATIC)) {
             String clazz = getClassConstantOperand();
             if (!clazz.equals(getClassName())) {
                 try {
@@ -335,6 +335,39 @@ public class FindPuzzlers extends OpcodeStackDetector {
                     this);
         }
 
+
+        if (seen == IADD && (getNextOpcode() == ISHL || getNextOpcode() == LSHL) && stack.getStackDepth() >=3) {
+            OpcodeStack.Item l = stack.getStackItem(2);
+            OpcodeStack.Item v = stack.getStackItem(1);
+            Object constantValue = v.getConstant();
+            // Ignore 1 << (const + var) as it's usually intended
+            if (constantValue instanceof Integer && !Integer.valueOf(1).equals(l.getConstant())) {
+                int c = ((Integer) constantValue).intValue();
+                int priority = LOW_PRIORITY;
+                // If (foo << 32 + var) encountered, then ((foo << 32) + var) is absolutely meaningless,
+                // but (foo << (32 + var)) can be meaningful for negative var values
+                if (c < 32 || (c < 64 && getNextOpcode() == LSHL)) {
+                    if (c == 8) {
+                        priority--;
+                    }
+                    if (getPrevOpcode(1) == IAND) {
+                        priority--;
+                    }
+                    if (getMethodName().equals("hashCode") && getMethodSig().equals("()I")
+                            && (getCode().getCode()[getNextPC() + 1] & 0xFF) == IRETURN) {
+                        // commonly observed error is hashCode body like "return foo << 16 + bar;"
+                        priority = HIGH_PRIORITY;
+                    }
+                    bugAccumulator.accumulateBug(new BugInstance(this, "BSHIFT_WRONG_ADD_PRIORITY", priority)
+                    .addClassAndMethod(this)
+                    .addInt(c).describe(IntAnnotation.INT_SHIFT)
+                    .addValueSource(stack.getStackItem(2), this)
+                    .addValueSource(stack.getStackItem(0), this)
+                    , this);
+                }
+            }
+
+        }
         constantArgumentToShift = false;
         shiftOfNonnegativeValue = false;
         if ((seen == IUSHR || seen == ISHR || seen == ISHL)) {
@@ -353,7 +386,7 @@ public class FindPuzzlers extends OpcodeStackDetector {
                     if (valueOfConstantArgumentToShift < 0 || valueOfConstantArgumentToShift >= 32) {
                         bugAccumulator.accumulateBug(new BugInstance(this, "ICAST_BAD_SHIFT_AMOUNT",
                                 valueOfConstantArgumentToShift < 0 ? LOW_PRIORITY : (valueOfConstantArgumentToShift == 32
-                                && getMethodName().equals("hashCode") ? NORMAL_PRIORITY : HIGH_PRIORITY))
+                                && "hashCode".equals(getMethodName()) ? NORMAL_PRIORITY : HIGH_PRIORITY))
                         .addClassAndMethod(this).addInt(valueOfConstantArgumentToShift).describe(IntAnnotation.INT_SHIFT)
                         .addValueSource(stack.getStackItem(1), this), this);
                     }
@@ -368,8 +401,8 @@ public class FindPuzzlers extends OpcodeStackDetector {
         }
 
         if (seen == INVOKEVIRTUAL && stack.getStackDepth() > 0
-                && (getClassConstantOperand().equals("java/util/Date") || getClassConstantOperand().equals("java/sql/Date"))
-                && getNameConstantOperand().equals("setMonth") && getSigConstantOperand().equals("(I)V")) {
+                && ("java/util/Date".equals(getClassConstantOperand()) || "java/sql/Date".equals(getClassConstantOperand()))
+                && "setMonth".equals(getNameConstantOperand()) && "(I)V".equals(getSigConstantOperand())) {
             OpcodeStack.Item item = stack.getStackItem(0);
             Object o = item.getConstant();
             if (o != null && o instanceof Integer) {
@@ -381,11 +414,11 @@ public class FindPuzzlers extends OpcodeStackDetector {
             }
         }
 
-        if (seen == INVOKEVIRTUAL && stack.getStackDepth() > 1 && getClassConstantOperand().equals("java/util/Calendar")
-                && getNameConstantOperand().equals("set")
+        if (seen == INVOKEVIRTUAL && stack.getStackDepth() > 1 && "java/util/Calendar".equals(getClassConstantOperand())
+                && "set".equals(getNameConstantOperand())
 
                 || seen == INVOKESPECIAL && stack.getStackDepth() > 1
-                && getClassConstantOperand().equals("java/util/GregorianCalendar") && getNameConstantOperand().equals("<init>")
+                && "java/util/GregorianCalendar".equals(getClassConstantOperand()) && "<init>".equals(getNameConstantOperand())
 
                 ) {
             String sig = getSigConstantOperand();
@@ -457,19 +490,18 @@ public class FindPuzzlers extends OpcodeStackDetector {
         // Java Puzzlers, chapter 3, puzzle 12
         if (seen == INVOKEVIRTUAL
                 && stack.getStackDepth() > 0
-                && (getNameConstantOperand().equals("toString") && getSigConstantOperand().equals("()Ljava/lang/String;")
-                        || getNameConstantOperand().equals("append")
-                        && getSigConstantOperand().equals("(Ljava/lang/Object;)Ljava/lang/StringBuilder;")
-                        && getClassConstantOperand().equals("java/lang/StringBuilder")
-                        || getNameConstantOperand().equals("append")
-                        && getSigConstantOperand().equals("(Ljava/lang/Object;)Ljava/lang/StringBuffer;")
-                        && getClassConstantOperand().equals("java/lang/StringBuffer") || (getNameConstantOperand()
-                                .equals("print") || getNameConstantOperand().equals("println"))
-                                && getSigConstantOperand().equals("(Ljava/lang/Object;)V"))) {
+                && ("toString".equals(getNameConstantOperand()) && "()Ljava/lang/String;".equals(getSigConstantOperand())
+                        || "append".equals(getNameConstantOperand())
+                        && "(Ljava/lang/Object;)Ljava/lang/StringBuilder;".equals(getSigConstantOperand())
+                        && "java/lang/StringBuilder".equals(getClassConstantOperand())
+                        || "append".equals(getNameConstantOperand())
+                        && "(Ljava/lang/Object;)Ljava/lang/StringBuffer;".equals(getSigConstantOperand())
+                        && "java/lang/StringBuffer".equals(getClassConstantOperand()) || ("print".equals(getNameConstantOperand()) || "println".equals(getNameConstantOperand()))
+                        && "(Ljava/lang/Object;)V".equals(getSigConstantOperand()))) {
             OpcodeStack.Item item = stack.getStackItem(0);
             String signature = item.getSignature();
             if (signature != null && signature.startsWith("[")) {
-                boolean debuggingContext = signature.equals("[Ljava/lang/StackTraceElement;");
+                boolean debuggingContext = "[Ljava/lang/StackTraceElement;".equals(signature);
 
                 if (!debuggingContext) {
                     for (CodeException e : getCode().getExceptionTable()) {
@@ -545,7 +577,7 @@ public class FindPuzzlers extends OpcodeStackDetector {
                         && classNameForPreviousMethod.equals(classNameForThisMethod.replace('/', '.'))
                         && previousMethodInvocation.getName().endsWith("Value")
                         && previousMethodInvocation.getSignature().length() == 3
-                        && getNameConstantOperand().equals("valueOf")
+                        && "valueOf".equals(getNameConstantOperand())
                         && getSigConstantOperand().charAt(1) == previousMethodInvocation.getSignature().charAt(2)) {
                     bugAccumulator.accumulateBug(
                             new BugInstance(this, "BX_UNBOXING_IMMEDIATELY_REBOXED", NORMAL_PRIORITY).addClassAndMethod(this)
@@ -601,7 +633,7 @@ public class FindPuzzlers extends OpcodeStackDetector {
 
         AssertInvokedFromRun: if (seen == INVOKESTATIC) {
             if ((getNameConstantOperand().startsWith("assert") || getNameConstantOperand().startsWith("fail"))
-                    && getMethodName().equals("run") && implementsRunnable(getThisClass())) {
+                    && "run".equals(getMethodName()) && implementsRunnable(getThisClass())) {
                 int size1 = Util.getSizeOfSurroundingTryBlock(getConstantPool(), getMethod().getCode(), "java/lang/Throwable",
                         getPC());
                 int size2 = Util.getSizeOfSurroundingTryBlock(getConstantPool(), getMethod().getCode(), "java/lang/Error",
@@ -631,10 +663,10 @@ public class FindPuzzlers extends OpcodeStackDetector {
             }
         }
         if (seen == INVOKESPECIAL && getClassConstantOperand().startsWith("java/lang/")
-                && getNameConstantOperand().equals("<init>") && getSigConstantOperand().length() == 4) {
+                && "<init>".equals(getNameConstantOperand()) && getSigConstantOperand().length() == 4) {
             previousMethodInvocation = XFactory.createReferencedXMethod(this);
         } else if (seen == INVOKESTATIC && getClassConstantOperand().startsWith("java/lang/")
-                && getNameConstantOperand().equals("valueOf") && getSigConstantOperand().length() == 4) {
+                && "valueOf".equals(getNameConstantOperand()) && getSigConstantOperand().length() == 4) {
             previousMethodInvocation = XFactory.createReferencedXMethod(this);
         } else if (seen == INVOKEVIRTUAL && getClassConstantOperand().startsWith("java/lang/")
                 && getNameConstantOperand().endsWith("Value")
@@ -669,7 +701,7 @@ public class FindPuzzlers extends OpcodeStackDetector {
             OpcodeStack.Item top = stack.getStackItem(0);
             XMethod m = top.getReturnValueOf();
             if (m != null) {
-                if (m.getName().equals("compareTo") || m.getName().equals("compare")) {
+                if ("compareTo".equals(m.getName()) || "compare".equals(m.getName())) {
                     bugAccumulator.accumulateBug(new BugInstance(this, "RV_NEGATING_RESULT_OF_COMPARETO", NORMAL_PRIORITY)
                     .addClassAndMethod(this)
                     .addCalledMethod(m).addValueSource(top, this), this);
@@ -677,15 +709,6 @@ public class FindPuzzlers extends OpcodeStackDetector {
             }
 
         }
-        if (seen == IRETURN && (getMethod().getName().equals("compareTo") || getMethod().getName().equals("compare"))) {
-            OpcodeStack.Item top = stack.getStackItem(0);
-            Object o = top.getConstant();
-            if (o instanceof Integer && ((Integer)o).intValue() == Integer.MIN_VALUE) {
-                bugAccumulator.accumulateBug(new BugInstance(this, "CO_COMPARETO_RESULTS_MIN_VALUE", NORMAL_PRIORITY)
-                .addClassAndMethod(this), this);
-            }
-
-        }
         prevOpCode = seen;
 
     }
diff --git a/FindRefComparison.java b/FindRefComparison.java
index dbf41ae027d55e436e82e807cb7307c17919a4f6..de559d09b80369c7296bb09c764d6570c98fdb31 100644
--- a/FindRefComparison.java
+++ b/FindRefComparison.java
@@ -404,7 +404,7 @@ public class FindRefComparison implements Detector, ExtendedTypes {
                 consumeStack(obj);
 
                 String className = obj.getClassName(getCPG());
-                if (className.equals("java.lang.String")) {
+                if ("java.lang.String".equals(className)) {
                     pushValue(dynamicStringTypeInstance);
                 } else {
                     pushReturnType(obj);
@@ -455,10 +455,10 @@ public class FindRefComparison implements Detector, ExtendedTypes {
             String methodName = obj.getName(getCPG());
             // System.out.println(className + "." + methodName);
 
-            if (methodName.equals("intern") && className.equals("java.lang.String")) {
+            if ("intern".equals(methodName) && "java.lang.String".equals(className)) {
                 sawStringIntern = true;
                 pushValue(staticStringTypeInstance);
-            } else if (methodName.equals("toString") || className.equals("java.lang.String")) {
+            } else if ("toString".equals(methodName) || "java.lang.String".equals(className)) {
                 pushValue(dynamicStringTypeInstance);
                 // System.out.println("  dynamic");
             } else {
@@ -489,7 +489,7 @@ public class FindRefComparison implements Detector, ExtendedTypes {
         }
 
         private boolean isString(Type type) {
-            return type.getSignature().equals(STRING_SIGNATURE);
+            return STRING_SIGNATURE.equals(type.getSignature());
         }
 
         @Override
@@ -516,7 +516,7 @@ public class FindRefComparison implements Detector, ExtendedTypes {
                 }
 
             }
-            if (type.getSignature().equals(STRING_SIGNATURE)) {
+            if (STRING_SIGNATURE.equals(type.getSignature())) {
                 handleLoad(obj);
             } else {
                 super.visitGETSTATIC(obj);
@@ -526,7 +526,7 @@ public class FindRefComparison implements Detector, ExtendedTypes {
         @Override
         public void visitGETFIELD(GETFIELD obj) {
             Type type = obj.getType(getCPG());
-            if (type.getSignature().equals(STRING_SIGNATURE)) {
+            if (STRING_SIGNATURE.equals(type.getSignature())) {
                 handleLoad(obj);
             } else {
                 XField xf = XFactory.createXField(obj, cpg);
@@ -558,7 +558,7 @@ public class FindRefComparison implements Detector, ExtendedTypes {
             consumeStack(obj);
 
             Type type = obj.getType(getCPG());
-            if (!type.getSignature().equals(STRING_SIGNATURE)) {
+            if (!STRING_SIGNATURE.equals(type.getSignature())) {
                 throw new IllegalArgumentException("type is not String: " + type);
             }
             try {
@@ -850,10 +850,10 @@ public class FindRefComparison implements Detector, ExtendedTypes {
             @DottedClassName String className = inv.getClassName(cpg);
             String methodName = inv.getMethodName(cpg);
             String methodSig = inv.getSignature(cpg);
-            if ( methodName.equals("assertSame") && methodSig.equals("(Ljava/lang/Object;Ljava/lang/Object;)V")) {
+            if ( "assertSame".equals(methodName) && "(Ljava/lang/Object;Ljava/lang/Object;)V".equals(methodSig)) {
                 checkRefComparison(location, jclass, method, methodGen, visitor, typeDataflow, stringComparisonList,
                         refComparisonList);
-            } else if ( methodName.equals("assertFalse") && methodSig.equals("(Z)V")) {
+            } else if ( "assertFalse".equals(methodName) && "(Z)V".equals(methodSig)) {
                 SourceLineAnnotation lastLocation = bugAccumulator.getLastBugLocation();
                 InstructionHandle prevHandle = location.getHandle().getPrev();
                 if (lastLocation != null && prevHandle != null && lastLocation.getEndBytecode() == prevHandle.getPosition()){
@@ -864,13 +864,13 @@ public class FindRefComparison implements Detector, ExtendedTypes {
                 }
 
             } else {
-                boolean equalsMethod = !isStatic && methodName.equals("equals") && methodSig.equals("(Ljava/lang/Object;)Z")
-                        || isStatic &&  methodName.equals("assertEquals")
-                        && methodSig.equals("(Ljava/lang/Object;Ljava/lang/Object;)V")
-                        || isStatic && methodName.equals("equal") && methodSig.equals("(Ljava/lang/Object;Ljava/lang/Object;)Z")
-                        && className.equals("com.google.common.base.Objects")
-                        || isStatic && methodName.equals("equals") && methodSig.equals("(Ljava/lang/Object;Ljava/lang/Object;)Z")
-                        && className.equals("java.util.Objects");
+                boolean equalsMethod = !isStatic && "equals".equals(methodName) && "(Ljava/lang/Object;)Z".equals(methodSig)
+                        || isStatic &&  "assertEquals".equals(methodName)
+                        && "(Ljava/lang/Object;Ljava/lang/Object;)V".equals(methodSig)
+                        || isStatic && "equal".equals(methodName) && "(Ljava/lang/Object;Ljava/lang/Object;)Z".equals(methodSig)
+                        && "com.google.common.base.Objects".equals(className)
+                        || isStatic && "equals".equals(methodName) && "(Ljava/lang/Object;Ljava/lang/Object;)Z".equals(methodSig)
+                        && "java.util.Objects".equals(className);
 
                 if (equalsMethod) {
                     checkEqualsComparison(location, jclass, method, methodGen, cpg, typeDataflow);
@@ -970,7 +970,7 @@ public class FindRefComparison implements Detector, ExtendedTypes {
             String lhs = SignatureConverter.convert(lhsType.getSignature());
             String rhs = SignatureConverter.convert(rhsType.getSignature());
 
-            if (lhs.equals("java.lang.String") || rhs.equals("java.lang.String")) {
+            if ("java.lang.String".equals(lhs) || "java.lang.String".equals(rhs)) {
                 handleStringComparison(jclass, method, methodGen, visitor, stringComparisonList, location, lhsType, rhsType);
             } else if (suspiciousSet.contains(lhs)) {
                 handleSuspiciousRefComparison(jclass, method, methodGen, refComparisonList, location, lhs,
@@ -1049,7 +1049,7 @@ public class FindRefComparison implements Detector, ExtendedTypes {
         String sourceFile = jclass.getSourceFileName();
         String bugPattern = "RC_REF_COMPARISON";
         int priority = Priorities.HIGH_PRIORITY;
-        if (lhs.equals("java.lang.Boolean")) {
+        if ("java.lang.Boolean".equals(lhs)) {
             bugPattern = "RC_REF_COMPARISON_BAD_PRACTICE_BOOLEAN";
             priority = Priorities.NORMAL_PRIORITY;
         } else if (xf != null && xf.isStatic() && xf.isFinal()) {
@@ -1088,7 +1088,7 @@ public class FindRefComparison implements Detector, ExtendedTypes {
         InstructionHandle next = handle.getNext();
         if (next != null && next.getInstruction() instanceof INVOKESTATIC) {
             INVOKESTATIC is = (INVOKESTATIC) next.getInstruction();
-            if (is.getMethodName(cpg).equals("assertFalse")) {
+            if ("assertFalse".equals(is.getMethodName(cpg))) {
                 return;
             }
         }
@@ -1136,7 +1136,7 @@ public class FindRefComparison implements Detector, ExtendedTypes {
                         }
                         BugInstance bug = new BugInstance(this, type, priority + priorityModifier).addClassAndMethod(methodGen, sourceFile)
                                 .addOptionalAnnotation(calledMethodAnnotation);
-                        if (type.equals("DMI_DOH")) {
+                        if ("DMI_DOH".equals(type)) {
                             bug.addString("Use \"== null\" to check for a value being null");
                         }
                         bugAccumulator.accumulateBug(
@@ -1167,7 +1167,7 @@ public class FindRefComparison implements Detector, ExtendedTypes {
             IncompatibleTypes result2 = IncompatibleTypes.getPriorityForAssumingCompatible(lhsType_, rhsType_, true);
             if (result2.getPriority() <= Priorities.NORMAL_PRIORITY) {
                 pattern = "EC_INCOMPATIBLE_ARRAY_COMPARE";
-            } else if (calledMethodAnnotation != null && calledMethodAnnotation.getClassName().equals("org.testng.Assert")) {
+            } else if (calledMethodAnnotation != null && "org.testng.Assert".equals(calledMethodAnnotation.getClassName())) {
                 return;
             }
             bugAccumulator.accumulateBug(new BugInstance(this, pattern, NORMAL_PRIORITY).addClassAndMethod(methodGen, sourceFile)
@@ -1257,8 +1257,8 @@ public class FindRefComparison implements Detector, ExtendedTypes {
 
     public @CheckForNull MethodAnnotation getMethodCalledAnnotation(ConstantPoolGen cpg, InvokeInstruction inv) {
         MethodDescriptor invokedMethod = getInvokedMethod(cpg, inv);
-        boolean standardEquals = invokedMethod.getName().equals("equals")
-                && invokedMethod.getSignature().equals("(Ljava/lang/Object;)Z") && !invokedMethod.isStatic();
+        boolean standardEquals = "equals".equals(invokedMethod.getName())
+                && "(Ljava/lang/Object;)Z".equals(invokedMethod.getSignature()) && !invokedMethod.isStatic();
         return standardEquals ? null : MethodAnnotation.fromMethodDescriptor(invokedMethod);
     }
 
diff --git a/FindRoughConstants.java b/FindRoughConstants.java
index e265b0cd7a56c7a2740d979644f09ba0749543a5..0d603a04e2c80339b4ae14626eea3a8b5d17a9e0 100644
--- a/FindRoughConstants.java
+++ b/FindRoughConstants.java
@@ -27,31 +27,33 @@ import java.util.Set;
 import org.apache.bcel.classfile.Constant;
 import org.apache.bcel.classfile.ConstantDouble;
 import org.apache.bcel.classfile.ConstantFloat;
+import org.apache.bcel.classfile.ConstantPool;
+import org.apache.bcel.classfile.JavaClass;
 
+import edu.umd.cs.findbugs.BugAccumulator;
 import edu.umd.cs.findbugs.BugInstance;
 import edu.umd.cs.findbugs.BugReporter;
+import edu.umd.cs.findbugs.BytecodeScanningDetector;
 import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
-import edu.umd.cs.findbugs.bcel.OpcodeStackDetector;
+import edu.umd.cs.findbugs.ba.ClassContext;
 
-public class FindRoughConstants extends OpcodeStackDetector {
+public class FindRoughConstants extends BytecodeScanningDetector {
 
     static class BadConstant {
-
         double base;
-
         double factor;
-
         String replacement;
-
         double value;
+        int basePriority;
 
         Set<Number> approxSet = new HashSet<Number>();
 
-        BadConstant(double base, double factor, String replacement) {
+        BadConstant(double base, double factor, String replacement, int basePriority) {
             this.base = base;
             this.factor = factor;
             this.value = this.base * this.factor;
             this.replacement = replacement;
+            this.basePriority = basePriority;
             BigDecimal valueBig = BigDecimal.valueOf(value);
             BigDecimal baseBig = BigDecimal.valueOf(base);
             BigDecimal factorBig = BigDecimal.valueOf(factor);
@@ -82,11 +84,11 @@ public class FindRoughConstants extends OpcodeStackDetector {
         @SuppressFBWarnings("FE_FLOATING_POINT_EQUALITY")
         private void addApprox(BigDecimal roundFloor) {
             double approxDouble = roundFloor.doubleValue();
-            if (approxDouble != value && Math.abs(approxDouble - value) / value < 0.0001) {
+            if (approxDouble != value && Math.abs(approxDouble - value) / value < 0.001) {
                 approxSet.add(approxDouble);
             }
             float approxFloat = roundFloor.floatValue();
-            if (Math.abs(approxFloat - value) / value < 0.0001) {
+            if (Math.abs(approxFloat - value) / value < 0.001) {
                 approxSet.add(approxFloat);
                 approxSet.add((double) approxFloat);
             }
@@ -94,18 +96,33 @@ public class FindRoughConstants extends OpcodeStackDetector {
     }
 
     private static final BadConstant[] badConstants = new BadConstant[] {
-        new BadConstant(Math.PI, 1, "Math.PI"),
-        new BadConstant(Math.PI, 1/2.0, "Math.PI/2"),
-        new BadConstant(Math.PI, 1/3.0, "Math.PI/3"),
-        new BadConstant(Math.PI, 1/4.0, "Math.PI/4"),
-        new BadConstant(Math.PI, 2, "2*Math.PI"),
-        new BadConstant(Math.E, 1, "Math.E")
+        new BadConstant(Math.PI, 1, "Math.PI", HIGH_PRIORITY),
+        new BadConstant(Math.PI, 1/2.0, "Math.PI/2", NORMAL_PRIORITY),
+        new BadConstant(Math.PI, 1/3.0, "Math.PI/3", LOW_PRIORITY),
+        new BadConstant(Math.PI, 1/4.0, "Math.PI/4", LOW_PRIORITY),
+        new BadConstant(Math.PI, 2, "2*Math.PI", NORMAL_PRIORITY),
+        new BadConstant(Math.E, 1, "Math.E", LOW_PRIORITY)
     };
 
-    private final BugReporter bugReporter;
+    private final BugAccumulator bugAccumulator;
+
+    private BugInstance lastBug;
+    private int lastPriority;
 
     public FindRoughConstants(BugReporter bugReporter) {
-        this.bugReporter = bugReporter;
+        this.bugAccumulator = new BugAccumulator(bugReporter);
+    }
+
+    @Override
+    public void visitClassContext(ClassContext classContext) {
+        if(hasInterestingConstant(classContext.getJavaClass().getConstantPool())) {
+            super.visitClassContext(classContext);
+        }
+    }
+
+    @Override
+    public void visitAfter(JavaClass obj) {
+        bugAccumulator.reportAccumulatedBugs();
     }
 
     @Override
@@ -117,7 +134,67 @@ public class FindRoughConstants extends OpcodeStackDetector {
             } else if (c instanceof ConstantDouble) {
                 checkConst(((ConstantDouble) c).getBytes());
             }
+            return;
+        }
+        // Lower priority if the constant is put into array immediately or after the boxing:
+        // this is likely to be just similar number in some predefined dataset (like lookup table)
+        if(seen == INVOKESTATIC && lastBug != null) {
+            if (getNextOpcode() == AASTORE
+                    && getNameConstantOperand().equals("valueOf")
+                    && (getClassConstantOperand().equals("java/lang/Double") || getClassConstantOperand().equals(
+                            "java/lang/Float"))) {
+                lastBug = ((BugInstance)lastBug.clone());
+                lastBug.setPriority(lastPriority+1);
+                bugAccumulator.forgetLastBug();
+                bugAccumulator.accumulateBug(lastBug, this);
+            }
         }
+        lastBug = null;
+    }
+
+    private boolean hasInterestingConstant(ConstantPool cp) {
+        for(Constant constant : cp.getConstantPool()) {
+            if(constant instanceof ConstantFloat) {
+                float val = ((ConstantFloat)constant).getBytes();
+                if(isInteresting(val, val)) {
+                    return true;
+                }
+            }
+            if(constant instanceof ConstantDouble) {
+                double val = ((ConstantDouble)constant).getBytes();
+                if(isInteresting(val, val)) {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    private boolean isInteresting(Number constValue, double candidate) {
+        for (BadConstant badConstant : badConstants) {
+            if(getPriority(badConstant, constValue, candidate) < IGNORE_PRIORITY) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private int getPriority(BadConstant badConstant, Number constValue, double candidate) {
+        if (badConstant.exact(constValue)) {
+            return IGNORE_PRIORITY;
+        }
+        double diff = badConstant.diff(candidate);
+        if (diff > 1e-3) {
+            return IGNORE_PRIORITY;
+        }
+        if (badConstant.equalPrefix(constValue)) {
+            return diff > 1e-4 ? badConstant.basePriority+1 :
+                diff < 1e-6 ? badConstant.basePriority-1 : badConstant.basePriority;
+        }
+        if (diff > 1e-7) {
+            return IGNORE_PRIORITY;
+        }
+        return badConstant.basePriority+1;
     }
 
     private void checkConst(Number constValue) {
@@ -126,29 +203,17 @@ public class FindRoughConstants extends OpcodeStackDetector {
             return;
         }
         for (BadConstant badConstant : badConstants) {
-            if (badConstant.exact(constValue)) {
-                continue;
+            int priority = getPriority(badConstant, constValue, candidate);
+            if(getNextOpcode() == FASTORE || getNextOpcode() == DASTORE) {
+                priority++;
             }
-            double diff = badConstant.diff(candidate);
-            if (diff > 0.0001) {
-                continue;
-            }
-            if (badConstant.equalPrefix(constValue)) {
-                bugReporter.reportBug(new BugInstance(this,
-                        "CNT_ROUGH_CONSTANT_VALUE", NORMAL_PRIORITY)
-                .addClassAndMethod(this).addSourceLine(this)
-                .addString(constValue.toString())
-                .addString(badConstant.replacement));
+            if(priority < IGNORE_PRIORITY) {
+                lastPriority = priority;
+                lastBug = new BugInstance(this, "CNT_ROUGH_CONSTANT_VALUE", priority).addClassAndMethod(this)
+                        .addString(constValue.toString()).addString(badConstant.replacement);
+                bugAccumulator.accumulateBug(lastBug, this);
                 return;
             }
-            if (diff > 0.0000001) {
-                continue;
-            }
-            bugReporter.reportBug(new BugInstance(this,
-                    "CNT_ROUGH_CONSTANT_VALUE", LOW_PRIORITY)
-            .addClassAndMethod(this).addSourceLine(this)
-            .addString(constValue.toString())
-            .addString(badConstant.replacement));
         }
     }
 }
diff --git a/FindRunInvocations.java b/FindRunInvocations.java
index eb84bbeb163b0239d42c5f68ff2016a54ce647c7..9def38127e398a882aa0074717d01f9a9181dd8b 100644
--- a/FindRunInvocations.java
+++ b/FindRunInvocations.java
@@ -62,15 +62,15 @@ public class FindRunInvocations extends BytecodeScanningDetector implements Stat
         if (alreadySawStart) {
             return;
         }
-        if ((seen == INVOKEVIRTUAL || seen == INVOKEINTERFACE) && getSigConstantOperand().equals("()V")
+        if ((seen == INVOKEVIRTUAL || seen == INVOKEINTERFACE) && "()V".equals(getSigConstantOperand())
                 && isThread(getDottedClassConstantOperand())) {
-            if (getNameConstantOperand().equals("start")) {
+            if ("start".equals(getNameConstantOperand())) {
                 alreadySawStart = true;
             } else {
-                boolean isJustThread = !getDottedClassConstantOperand().equals("java.lang.Thread");
+                boolean isJustThread = !"java.lang.Thread".equals(getDottedClassConstantOperand());
                 if (amVisitingMainMethod() && getPC() == getCode().getLength() - 4 && isJustThread) {
                     return;
-                } else if (getNameConstantOperand().equals("run")) {
+                } else if ("run".equals(getNameConstantOperand())) {
                     bugAccumulator.accumulateBug(new BugInstance(this, "RU_INVOKE_RUN", isJustThread ? HIGH_PRIORITY
                             : NORMAL_PRIORITY).addClassAndMethod(this), this);
                 }
diff --git a/FindSelfComparison.java b/FindSelfComparison.java
index d08976faee960ffe1847aa53eea265c7fd0176e7..319e8f01ef0d8170700a38db7143add09334c307 100644
--- a/FindSelfComparison.java
+++ b/FindSelfComparison.java
@@ -105,7 +105,8 @@ public class FindSelfComparison extends OpcodeStackDetector {
             XClass x = getXClassOperand();
 
             checkPUTFIELD: if (putFieldPC + 10 > getPC() && f != null && obj != null && f.equals(putFieldXField)
-                    && !f.isSynthetic() && obj.equals(putFieldObj) && x != null) {
+                    && !f.isSynthetic() && obj.sameValue(putFieldObj) && x != null) {
+
 
                 LineNumberTable table = getCode().getLineNumberTable();
                 if (table != null) {
@@ -168,7 +169,7 @@ public class FindSelfComparison extends OpcodeStackDetector {
             resetDoubleAssignmentState();
         } else if (seen == GETFIELD && Util.nullSafeEquals(getXFieldOperand(), putFieldXField)) {
             OpcodeStack.Item obj = stack.getStackItem(0);
-            if (obj.equals(putFieldObj)) {
+            if (obj.sameValue(putFieldObj)) {
                 resetDoubleAssignmentState();
             }
         }
@@ -262,10 +263,10 @@ public class FindSelfComparison extends OpcodeStackDetector {
             OpcodeStack.Item item0 = stack.getStackItem(0);
             OpcodeStack.Item item1 = stack.getStackItem(1);
 
-            if (item0.getSignature().equals("D") || item0.getSignature().equals("F")) {
+            if ("D".equals(item0.getSignature()) || "F".equals(item0.getSignature())) {
                 return;
             }
-            if (item1.getSignature().equals("D") || item1.getSignature().equals("F")) {
+            if ("D".equals(item1.getSignature()) || "F".equals(item1.getSignature())) {
                 return;
             }
 
@@ -319,7 +320,7 @@ public class FindSelfComparison extends OpcodeStackDetector {
                 bugAccumulator.accumulateBug(bug, this);
             }
 
-            else if (opCode == IXOR && item0.equals(item1)) {
+            else if (opCode == IXOR && item0.sameValue(item1)) {
                 LocalVariableAnnotation localVariableAnnotation = LocalVariableAnnotation.getLocalVariableAnnotation(this, item0);
                 if (localVariableAnnotation != null) {
                     bugAccumulator.accumulateBug(
diff --git a/FindSelfComparison2.java b/FindSelfComparison2.java
index 11e0ad4527223f9fa9b8d7bff8e1904c91dd607e..abb064b0dec9517d71b04a17b19f5125cee2f9dc 100644
--- a/FindSelfComparison2.java
+++ b/FindSelfComparison2.java
@@ -64,12 +64,12 @@ public class FindSelfComparison2 implements Detector {
     }
 
     static boolean booleanComparisonMethod(String methodName) {
-        return methodName.equals("equals") ||methodName.equals("endsWith") || methodName.equals("startsWith")
-                || methodName.equals("contains") || methodName.equals("equalsIgnoreCase");
+        return "equals".equals(methodName) ||"endsWith".equals(methodName) || "startsWith".equals(methodName)
+                || "contains".equals(methodName) || "equalsIgnoreCase".equals(methodName);
     }
 
     static boolean comparatorMethod(String methodName) {
-        return  methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase");
+        return  "compareTo".equals(methodName) || "compareToIgnoreCase".equals(methodName);
     }
     private void analyzeMethod(ClassContext classContext, Method method) throws CFGBuilderException, DataflowAnalysisException {
         CFG cfg = classContext.getCFG(method);
diff --git a/FindSleepWithLockHeld.java b/FindSleepWithLockHeld.java
index 165c448fd454a5de7c8a173024a5e4af7cb61a4e..02a83f2bf8a5a6fbd4d89cdee33a20f7cd79e77c 100644
--- a/FindSleepWithLockHeld.java
+++ b/FindSleepWithLockHeld.java
@@ -130,13 +130,13 @@ public class FindSleepWithLockHeld implements Detector {
 
     private boolean isSleep(INVOKESTATIC ins, ConstantPoolGen cpg) {
         String className = ins.getClassName(cpg);
-        if (!className.equals("java.lang.Thread")) {
+        if (!"java.lang.Thread".equals(className)) {
             return false;
         }
         String methodName = ins.getMethodName(cpg);
         String signature = ins.getSignature(cpg);
 
-        return methodName.equals("sleep") && (signature.equals("(J)V") || signature.equals("(JI)V"));
+        return "sleep".equals(methodName) && ("(J)V".equals(signature) || "(JI)V".equals(signature));
     }
 
     @Override
diff --git a/FindSqlInjection.java b/FindSqlInjection.java
index 1e036c9e961a106faaed3f2e08ae59d173da0a31..d17a1d42fef7a4e244e7c18df9ddb62f8807e38e 100644
--- a/FindSqlInjection.java
+++ b/FindSqlInjection.java
@@ -19,7 +19,10 @@
 
 package edu.umd.cs.findbugs.detect;
 
+import java.util.HashSet;
 import java.util.Iterator;
+import java.util.Map;
+import java.util.Set;
 import java.util.regex.Pattern;
 
 import javax.annotation.CheckForNull;
@@ -30,7 +33,6 @@ import org.apache.bcel.generic.AALOAD;
 import org.apache.bcel.generic.ConstantPoolGen;
 import org.apache.bcel.generic.GETFIELD;
 import org.apache.bcel.generic.GETSTATIC;
-import org.apache.bcel.generic.INVOKEINTERFACE;
 import org.apache.bcel.generic.INVOKEVIRTUAL;
 import org.apache.bcel.generic.Instruction;
 import org.apache.bcel.generic.InstructionHandle;
@@ -60,6 +62,11 @@ import edu.umd.cs.findbugs.ba.type.TopType;
 import edu.umd.cs.findbugs.ba.type.TypeDataflow;
 import edu.umd.cs.findbugs.ba.type.TypeFrame;
 import edu.umd.cs.findbugs.classfile.CheckedAnalysisException;
+import edu.umd.cs.findbugs.classfile.Global;
+import edu.umd.cs.findbugs.classfile.MethodDescriptor;
+import edu.umd.cs.findbugs.detect.BuildStringPassthruGraph.MethodParameter;
+import edu.umd.cs.findbugs.detect.BuildStringPassthruGraph.StringPassthruDatabase;
+import edu.umd.cs.findbugs.visitclass.PreorderVisitor;
 
 /**
  * Find potential SQL injection vulnerabilities.
@@ -69,6 +76,32 @@ import edu.umd.cs.findbugs.classfile.CheckedAnalysisException;
  * @author Matt Hargett
  */
 public class FindSqlInjection implements Detector {
+    private static final String[] PREPARE_STATEMENT_SIGNATURES = new String[] {
+        "(Ljava/lang/String;)Ljava/sql/PreparedStatement;",
+        "(Ljava/lang/String;I)Ljava/sql/PreparedStatement;",
+        "(Ljava/lang/String;II)Ljava/sql/PreparedStatement;",
+        "(Ljava/lang/String;III)Ljava/sql/PreparedStatement;",
+        "(Ljava/lang/String;[I)Ljava/sql/PreparedStatement;",
+        "(Ljava/lang/String;[Ljava/lang/String;)Ljava/sql/PreparedStatement;",
+    };
+
+    private static final MethodDescriptor[] EXECUTE_METHODS = new MethodDescriptor[] {
+        new MethodDescriptor("java/sql/Statement", "executeQuery", "(Ljava/lang/String;)Ljava/sql/ResultSet;"),
+        new MethodDescriptor("java/sql/Statement", "executeUpdate", "(Ljava/lang/String;)I"),
+        new MethodDescriptor("java/sql/Statement", "executeUpdate", "(Ljava/lang/String;I)I"),
+        new MethodDescriptor("java/sql/Statement", "executeUpdate", "(Ljava/lang/String;[I)I"),
+        new MethodDescriptor("java/sql/Statement", "executeUpdate", "(Ljava/lang/String;[Ljava/lang/String;)I"),
+        new MethodDescriptor("java/sql/Statement", "executeLargeUpdate", "(Ljava/lang/String;)J"),
+        new MethodDescriptor("java/sql/Statement", "executeLargeUpdate", "(Ljava/lang/String;I)J"),
+        new MethodDescriptor("java/sql/Statement", "executeLargeUpdate", "(Ljava/lang/String;[I)J"),
+        new MethodDescriptor("java/sql/Statement", "executeLargeUpdate", "(Ljava/lang/String;[Ljava/lang/String;)J"),
+        new MethodDescriptor("java/sql/Statement", "execute", "(Ljava/lang/String;)Z"),
+        new MethodDescriptor("java/sql/Statement", "execute", "(Ljava/lang/String;I)Z"),
+        new MethodDescriptor("java/sql/Statement", "execute", "(Ljava/lang/String;[I)Z"),
+        new MethodDescriptor("java/sql/Statement", "execute", "(Ljava/lang/String;[Ljava/lang/String;)Z"),
+        new MethodDescriptor("java/sql/Statement", "addBatch", "(Ljava/lang/String;)V"),
+    };
+
     private static class StringAppendState {
         // remember the smallest position at which we saw something that
         // concerns us
@@ -152,17 +185,36 @@ public class FindSqlInjection implements Detector {
 
     BugAccumulator bugAccumulator;
 
+    final Map<MethodDescriptor, int[]> preparedStatementMethods;
+    final Map<MethodDescriptor, int[]> executeMethods;
+    final Set<MethodDescriptor> allMethods = new HashSet<>();
+
     private final boolean testingEnabled;
 
     public FindSqlInjection(BugReporter bugReporter) {
         this.bugReporter = bugReporter;
         this.bugAccumulator = new BugAccumulator(bugReporter);
         testingEnabled = SystemProperties.getBoolean("report_TESTING_pattern_in_standard_detectors");
+        Set<MethodParameter> baseExecuteMethods = new HashSet<>();
+        for(MethodDescriptor executeMethod : EXECUTE_METHODS) {
+            baseExecuteMethods.add(new MethodParameter(executeMethod, 0));
+        }
+        executeMethods = Global.getAnalysisCache().getDatabase(StringPassthruDatabase.class).findLinkedMethods(baseExecuteMethods);
+        Set<MethodParameter> basePrepareMethods = new HashSet<>();
+        for(String signature : PREPARE_STATEMENT_SIGNATURES) {
+            basePrepareMethods.add(new MethodParameter(new MethodDescriptor("java/sql/Connection", "prepareStatement", signature), 0));
+        }
+        preparedStatementMethods = Global.getAnalysisCache().getDatabase(StringPassthruDatabase.class).findLinkedMethods(basePrepareMethods);
+        allMethods.addAll(executeMethods.keySet());
+        allMethods.addAll(preparedStatementMethods.keySet());
     }
 
     @Override
     public void visitClassContext(ClassContext classContext) {
         JavaClass javaClass = classContext.getJavaClass();
+        if(!PreorderVisitor.hasInterestingMethod(javaClass.getConstantPool(), allMethods)) {
+            return;
+        }
         Method[] methodList = javaClass.getMethods();
 
         for (Method method : methodList) {
@@ -193,7 +245,7 @@ public class FindSqlInjection implements Detector {
         if (ins instanceof INVOKEVIRTUAL) {
             INVOKEVIRTUAL invoke = (INVOKEVIRTUAL) ins;
 
-            if (invoke.getMethodName(cpg).equals("append") && invoke.getClassName(cpg).startsWith("java.lang.StringB")) {
+            if ("append".equals(invoke.getMethodName(cpg)) && invoke.getClassName(cpg).startsWith("java.lang.StringB")) {
                 String sig = invoke.getSignature(cpg);
                 char firstChar = sig.charAt(1);
                 return firstChar == '[' || firstChar == 'L';
@@ -252,46 +304,6 @@ public class FindSqlInjection implements Detector {
         return stringAppendState;
     }
 
-    private boolean isPreparedStatementDatabaseSink(Instruction ins, ConstantPoolGen cpg) {
-        if (!(ins instanceof INVOKEINTERFACE)) {
-            return false;
-        }
-
-        INVOKEINTERFACE invoke = (INVOKEINTERFACE) ins;
-
-        String methodName = invoke.getMethodName(cpg);
-        String methodSignature = invoke.getSignature(cpg);
-        String interfaceName = invoke.getClassName(cpg);
-        if (methodName.equals("prepareStatement") && interfaceName.equals("java.sql.Connection")
-                && methodSignature.startsWith("(Ljava/lang/String;")) {
-            return true;
-        }
-
-        return false;
-    }
-
-    private boolean isExecuteDatabaseSink(InvokeInstruction ins, ConstantPoolGen cpg) {
-        if (!(ins instanceof INVOKEINTERFACE)) {
-            return false;
-        }
-
-        INVOKEINTERFACE invoke = (INVOKEINTERFACE) ins;
-
-        String methodName = invoke.getMethodName(cpg);
-        String methodSignature = invoke.getSignature(cpg);
-        String interfaceName = invoke.getClassName(cpg);
-        if (methodName.startsWith("execute") && interfaceName.equals("java.sql.Statement")
-                && methodSignature.startsWith("(Ljava/lang/String;")) {
-            return true;
-        }
-
-        return false;
-    }
-
-    private boolean isDatabaseSink(InvokeInstruction ins, ConstantPoolGen cpg) {
-        return isPreparedStatementDatabaseSink(ins, cpg) || isExecuteDatabaseSink(ins, cpg);
-    }
-
     private StringAppendState getStringAppendState(CFG cfg, ConstantPoolGen cpg) throws CFGBuilderException {
         StringAppendState stringAppendState = new StringAppendState();
         String sig = method.getSignature();
@@ -322,8 +334,8 @@ public class FindSqlInjection implements Detector {
                 if (sig2.indexOf("java/lang/String") >= 0) {
                     String methodName = inv.getMethodName(cpg);
                     String className = inv.getClassName(cpg);
-                    if (methodName.equals("valueOf") && className.equals("java.lang.String")
-                            && sig1.equals("(Ljava/lang/Object;)Ljava/lang/String;")) {
+                    if ("valueOf".equals(methodName) && "java.lang.String".equals(className)
+                            && "(Ljava/lang/Object;)Ljava/lang/String;".equals(sig1)) {
                         try {
                             TypeDataflow typeDataflow = classContext.getTypeDataflow(method);
                             TypeFrame frame = typeDataflow.getFactAtLocation(location);
@@ -337,16 +349,16 @@ public class FindSqlInjection implements Detector {
                                 continue;
                             }
                             String sig3 = operandType.getSignature();
-                            if (!sig3.equals("Ljava/lang/String;")) {
+                            if (!"Ljava/lang/String;".equals(sig3)) {
                                 stringAppendState.setSawTaint(handle);
                             }
                         } catch (CheckedAnalysisException e) {
                             stringAppendState.setSawTaint(handle);
                         }
-                    } else if (className.startsWith("java.lang.String") || className.equals("java.lang.Long")
-                            || className.equals("java.lang.Integer") || className.equals("java.lang.Float")
-                            || className.equals("java.lang.Double") || className.equals("java.lang.Short")
-                            || className.equals("java.lang.Byte") || className.equals("java.lang.Character")) {
+                    } else if (className.startsWith("java.lang.String") || "java.lang.Long".equals(className)
+                            || "java.lang.Integer".equals(className) || "java.lang.Float".equals(className)
+                            || "java.lang.Double".equals(className) || "java.lang.Short".equals(className)
+                            || "java.lang.Byte".equals(className) || "java.lang.Character".equals(className)) {
                         // ignore it
                         assert true;
                     } else if (methodName.startsWith("to") && methodName.endsWith("String") && methodName.length() > 8) {
@@ -391,7 +403,7 @@ public class FindSqlInjection implements Detector {
                 Location prev2 = getPreviousLocation(cfg, prev, true);
                 if (prev2 != null && prev2.getHandle().getInstruction() instanceof GETSTATIC) {
                     GETSTATIC getStatic = (GETSTATIC) prev2.getHandle().getInstruction();
-                    if (getStatic.getSignature(cpg).equals("[Ljava/lang/String;")) {
+                    if ("[Ljava/lang/String;".equals(getStatic.getSignature(cpg))) {
                         return true;
                     }
                 }
@@ -433,9 +445,7 @@ public class FindSqlInjection implements Detector {
     }
 
     private BugInstance generateBugInstance(JavaClass javaClass, MethodGen methodGen, InstructionHandle handle,
-            StringAppendState stringAppendState) {
-        Instruction instruction = handle.getInstruction();
-        ConstantPoolGen cpg = methodGen.getConstantPool();
+            StringAppendState stringAppendState, boolean isExecute) {
         int priority = LOW_PRIORITY;
         boolean sawSeriousTaint = false;
         if (stringAppendState.getSawAppend(handle)) {
@@ -456,15 +466,15 @@ public class FindSqlInjection implements Detector {
         }
 
         String description = "TESTING";
-        if (instruction instanceof InvokeInstruction && isExecuteDatabaseSink((InvokeInstruction) instruction, cpg)) {
+        if (isExecute) {
             description = "SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE";
-        } else if (isPreparedStatementDatabaseSink(instruction, cpg)) {
+        } else {
             description = "SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING";
         }
 
         BugInstance bug = new BugInstance(this, description, priority);
         bug.addClassAndMethod(methodGen, javaClass.getSourceFileName());
-        if (description.equals("TESTING")) {
+        if ("TESTING".equals(description)) {
             bug.addString("Incomplete report invoking non-constant SQL string");
         }
         if (sawSeriousTaint) {
@@ -500,27 +510,43 @@ public class FindSqlInjection implements Detector {
                 continue;
             }
             InvokeInstruction invoke = (InvokeInstruction) ins;
-            if (isDatabaseSink(invoke, cpg)) {
-                ConstantFrame frame = dataflow.getFactAtLocation(location);
-                int numArguments = frame.getNumArguments(invoke, cpg);
-                Constant value = frame.getStackValue(numArguments - 1);
-
-                if (!value.isConstantString()) {
-                    // TODO: verify it's the same string represented by
-                    // stringAppendState
-                    // FIXME: will false positive on const/static strings
-                    // returns by methods
-                    Location prev = getPreviousLocation(cfg, location, true);
-                    if (prev == null || !isSafeValue(prev, cpg)) {
-                        BugInstance bug = generateBugInstance(javaClass, methodGen, location.getHandle(), stringAppendState);
-                        if(!testingEnabled && "TESTING".equals(bug.getType())){
-                            continue;
-                        }
-                        bugAccumulator.accumulateBug(
-                                bug,
-                                SourceLineAnnotation.fromVisitedInstruction(classContext, methodGen,
-                                        javaClass.getSourceFileName(), location.getHandle()));
+            MethodDescriptor md = new MethodDescriptor(invoke, cpg);
+            boolean executeMethod;
+            int[] params = preparedStatementMethods.get(md);
+            int paramNumber;
+            // Currently only one method parameter is checked, though it's the most common case
+            // TODO: support methods which take several SQL statements
+            if(params != null) {
+                executeMethod = false;
+                paramNumber = params[0];
+            } else {
+                params = executeMethods.get(md);
+                if(params != null) {
+                    executeMethod = true;
+                    paramNumber = params[0];
+                } else {
+                    continue;
+                }
+            }
+            ConstantFrame frame = dataflow.getFactAtLocation(location);
+            int numArguments = frame.getNumArguments(invoke, cpg);
+            Constant value = frame.getStackValue(numArguments - 1 - paramNumber);
+
+            if (!value.isConstantString()) {
+                // TODO: verify it's the same string represented by
+                // stringAppendState
+                // FIXME: will false positive on const/static strings
+                // returns by methods
+                Location prev = getPreviousLocation(cfg, location, true);
+                if (prev == null || !isSafeValue(prev, cpg)) {
+                    BugInstance bug = generateBugInstance(javaClass, methodGen, location.getHandle(), stringAppendState, executeMethod);
+                    if(!testingEnabled && "TESTING".equals(bug.getType())){
+                        continue;
                     }
+                    bugAccumulator.accumulateBug(
+                            bug,
+                            SourceLineAnnotation.fromVisitedInstruction(classContext, methodGen,
+                                    javaClass.getSourceFileName(), location.getHandle()));
                 }
             }
         }
diff --git a/FindTwoLockWait.java b/FindTwoLockWait.java
index 0c2423d4b4bb8f2bbe1c8477fd7010ea3db69eef..e812086408585c25e05e32de4164eb697714f456 100644
--- a/FindTwoLockWait.java
+++ b/FindTwoLockWait.java
@@ -129,7 +129,7 @@ public final class FindTwoLockWait implements Detector, StatelessDetector {
             } else if (ins instanceof INVOKEVIRTUAL) {
                 INVOKEVIRTUAL inv = (INVOKEVIRTUAL) ins;
                 String methodName = inv.getMethodName(cpg);
-                if (methodName.equals("wait") || methodName.startsWith("notify")) {
+                if ("wait".equals(methodName) || methodName.startsWith("notify")) {
                     sawWaitOrNotify = true;
                 }
             }
diff --git a/FindUncalledPrivateMethods.java b/FindUncalledPrivateMethods.java
index 8f4dd27e4bfaa1ab2488885cfa9725dd1f704676..d1ea93ae91c93c9846f60d6204dd85c9e7a187e9 100644
--- a/FindUncalledPrivateMethods.java
+++ b/FindUncalledPrivateMethods.java
@@ -22,6 +22,12 @@ package edu.umd.cs.findbugs.detect;
 import java.util.HashSet;
 
 import org.apache.bcel.classfile.AnnotationEntry;
+import org.apache.bcel.classfile.Constant;
+import org.apache.bcel.classfile.ConstantCP;
+import org.apache.bcel.classfile.ConstantMethodHandle;
+import org.apache.bcel.classfile.ConstantNameAndType;
+import org.apache.bcel.classfile.ConstantPool;
+import org.apache.bcel.classfile.ConstantUtf8;
 import org.apache.bcel.classfile.Method;
 
 import edu.umd.cs.findbugs.BugInstance;
@@ -30,6 +36,7 @@ import edu.umd.cs.findbugs.BytecodeScanningDetector;
 import edu.umd.cs.findbugs.MethodAnnotation;
 import edu.umd.cs.findbugs.StatelessDetector;
 import edu.umd.cs.findbugs.ba.ClassContext;
+import edu.umd.cs.findbugs.util.ClassName;
 
 /**
  * Detector to find private methods that are never called.
@@ -54,16 +61,16 @@ public class FindUncalledPrivateMethods extends BytecodeScanningDetector impleme
         }
         super.visitMethod(obj);
         String methodName = getMethodName();
-        if (!methodName.equals("writeReplace") && !methodName.equals("readResolve")
-                && !methodName.equals("readObject") && !methodName.equals("readObjectNoData")
-                && !methodName.equals("writeObject")
+        if (!"writeReplace".equals(methodName) && !"readResolve".equals(methodName)
+                && !"readObject".equals(methodName) && !"readObjectNoData".equals(methodName)
+                && !"writeObject".equals(methodName)
                 && methodName.indexOf("debug") == -1 && methodName.indexOf("Debug") == -1
                 && methodName.indexOf("trace") == -1 && methodName.indexOf("Trace") == -1
-                && !methodName.equals("<init>") && !methodName.equals("<clinit>")) {
+                && !"<init>".equals(methodName) && !"<clinit>".equals(methodName)) {
             for(AnnotationEntry a : obj.getAnnotationEntries()) {
                 String typeName =  a.getAnnotationType();
-                if (typeName.equals("Ljavax/annotation/PostConstruct;")
-                        || typeName.equals("Ljavax/annotation/PreDestroy;")) {
+                if ("Ljavax/annotation/PostConstruct;".equals(typeName)
+                        || "Ljavax/annotation/PreDestroy;".equals(typeName)) {
                     return;
                 }
             }
@@ -83,8 +90,6 @@ public class FindUncalledPrivateMethods extends BytecodeScanningDetector impleme
                         seen == INVOKESTATIC);
                 calledMethods.add(called);
                 calledMethodNames.add(getNameConstantOperand().toLowerCase());
-                // System.out.println("Saw call to " + called);
-
             }
             break;
         default:
@@ -100,6 +105,26 @@ public class FindUncalledPrivateMethods extends BytecodeScanningDetector impleme
         className = classContext.getJavaClass().getClassName();
         String[] parts = className.split("[$+.]");
         String simpleClassName = parts[parts.length - 1];
+
+        ConstantPool cp = classContext.getJavaClass().getConstantPool();
+        for(Constant constant : cp.getConstantPool()) {
+            if(constant instanceof ConstantMethodHandle) {
+                int kind = ((ConstantMethodHandle) constant).getReferenceKind();
+                if(kind >= 5 && kind <= 9) {
+                    Constant ref = cp.getConstant(((ConstantMethodHandle)constant).getReferenceIndex());
+                    if(ref instanceof ConstantCP) {
+                        String className = cp.getConstantString(((ConstantCP) ref).getClassIndex(), CONSTANT_Class);
+                        ConstantNameAndType nameAndType = (ConstantNameAndType) cp.getConstant(((ConstantCP) ref).getNameAndTypeIndex());
+                        String name = ((ConstantUtf8)cp.getConstant(nameAndType.getNameIndex())).getBytes();
+                        String signature = ((ConstantUtf8)cp.getConstant(nameAndType.getSignatureIndex())).getBytes();
+                        MethodAnnotation called = new MethodAnnotation(ClassName.toDottedClassName(className), name, signature, kind==6 /* invokestatic */);
+                        calledMethods.add(called);
+                        calledMethodNames.add(name.toLowerCase());
+                    }
+                }
+            }
+        }
+
         super.visitClassContext(classContext);
 
         definedPrivateMethods.removeAll(calledMethods);
@@ -108,7 +133,7 @@ public class FindUncalledPrivateMethods extends BytecodeScanningDetector impleme
             // System.out.println("Checking " + m);
             int priority = LOW_PRIORITY;
             String methodName = m.getMethodName();
-            if (methodName.equals(simpleClassName) && m.getMethodSignature().equals("()V")) {
+            if (methodName.equals(simpleClassName) && "()V".equals(m.getMethodSignature())) {
                 continue;
             }
             if (methodName.length() > 1 && calledMethodNames.contains(methodName.toLowerCase())) {
diff --git a/FindUnconditionalWait.java b/FindUnconditionalWait.java
index bac09fd10cd6530e2b81ba3f9271c452918f2334..023685175e7663caad58df1f8a336eee4c68d78d 100644
--- a/FindUnconditionalWait.java
+++ b/FindUnconditionalWait.java
@@ -63,9 +63,9 @@ public class FindUnconditionalWait extends BytecodeScanningDetector implements S
             }
             break;
         case 1:
-            if (seen == INVOKEVIRTUAL && getNameConstantOperand().equals("wait")) {
+            if (seen == INVOKEVIRTUAL && "wait".equals(getNameConstantOperand())) {
                 bugReporter.reportBug(new BugInstance(this, "UW_UNCOND_WAIT",
-                        getSigConstantOperand().equals("()V") ? NORMAL_PRIORITY : LOW_PRIORITY).addClassAndMethod(this)
+                        "()V".equals(getSigConstantOperand()) ? NORMAL_PRIORITY : LOW_PRIORITY).addClassAndMethod(this)
                         .addSourceLine(this));
                 stage = 2;
             }
diff --git a/FindUninitializedGet.java b/FindUninitializedGet.java
index 25544a205d39f7494737c46d4dd7b0750ecbea4a..47153580d2e062548b0dfa4ca9019bf801e73043 100644
--- a/FindUninitializedGet.java
+++ b/FindUninitializedGet.java
@@ -97,7 +97,7 @@ public class FindUninitializedGet extends BytecodeScanningDetector implements St
         initializedFields.clear();
 
         thisOnTOS = false;
-        inConstructor = getMethodName().equals("<init>") && getMethodSig().indexOf(getClassName()) == -1;
+        inConstructor = "<init>".equals(getMethodName()) && getMethodSig().indexOf(getClassName()) == -1;
 
     }
 
@@ -181,12 +181,11 @@ public class FindUninitializedGet extends BytecodeScanningDetector implements St
                 }
                 initializedFields.add(f);
             }
-        } else if ((seen == INVOKESPECIAL && !(getNameConstantOperand().equals("<init>") && !getClassConstantOperand().equals(
+        } else if ((seen == INVOKESPECIAL && !("<init>".equals(getNameConstantOperand()) && !getClassConstantOperand().equals(
                 getClassName())))
-                || (seen == INVOKESTATIC && getNameConstantOperand().equals("doPrivileged") && getClassConstantOperand().equals(
-                        "java/security/AccessController"))
+                || (seen == INVOKESTATIC && "doPrivileged".equals(getNameConstantOperand()) && "java/security/AccessController".equals(getClassConstantOperand()))
                         || (seen == INVOKEVIRTUAL && getClassConstantOperand().equals(getClassName()))
-                        || (seen == INVOKEVIRTUAL && getNameConstantOperand().equals("start"))) {
+                        || (seen == INVOKEVIRTUAL && "start".equals(getNameConstantOperand()))) {
 
             inConstructor = false;
         }
diff --git a/FindUnrelatedTypesInGenericContainer.java b/FindUnrelatedTypesInGenericContainer.java
index de490bf39e323793de2dd6ecf69b7c8c18bca166..b0b409a8a88a9c390d4ae01fae21ffd7752ce898 100644
--- a/FindUnrelatedTypesInGenericContainer.java
+++ b/FindUnrelatedTypesInGenericContainer.java
@@ -437,8 +437,8 @@ public class FindUnrelatedTypesInGenericContainer implements Detector {
                         continue;
                     }
                 } catch (ClassNotFoundException e) {
-                    if (info.interfaceForCall.getClassName().equals("java/util/Collection")
-                            && invokedMethod.getClassName().equals("com.google.common.collect.Multiset")) {
+                    if ("java/util/Collection".equals(info.interfaceForCall.getClassName())
+                            && "com.google.common.collect.Multiset".equals(invokedMethod.getClassName())) {
                         assert true;
                         // we know this is OK without needing to find definition of Multiset
                     } else {
@@ -500,7 +500,7 @@ public class FindUnrelatedTypesInGenericContainer implements Detector {
                 if (objectVN.equals(argVN)) {
                     String bugPattern = "DMI_COLLECTIONS_SHOULD_NOT_CONTAIN_THEMSELVES";
                     int priority = HIGH_PRIORITY;
-                    if (invokedMethodName.equals("removeAll")) {
+                    if ("removeAll".equals(invokedMethodName)) {
                         bugPattern = "DMI_USING_REMOVEALL_TO_CLEAR_COLLECTION";
                         priority = NORMAL_PRIORITY;
                     } else if (invokedMethodName.endsWith("All")) {
@@ -514,7 +514,7 @@ public class FindUnrelatedTypesInGenericContainer implements Detector {
 
                             if (nextIns instanceof InvokeInstruction) {
                                 XMethod nextMethod = XFactory.createXMethod((InvokeInstruction) nextIns, cpg);
-                                if (nextMethod.getName().equals("assertFalse")) {
+                                if ("assertFalse".equals(nextMethod.getName())) {
                                     continue;
                                 }
                             }
@@ -540,9 +540,9 @@ public class FindUnrelatedTypesInGenericContainer implements Detector {
 
                 int expectedTypeParameters = 1;
                 String simpleName = info.interfaceForCall.getSimpleName();
-                if ( simpleName.toLowerCase().endsWith("map") || simpleName.equals("Hashtable")) {
+                if ( simpleName.toLowerCase().endsWith("map") || "Hashtable".equals(simpleName)) {
                     expectedTypeParameters = 2;
-                } else if (simpleName.equals("Table")) {
+                } else if ("Table".equals(simpleName)) {
                     expectedTypeParameters = 3;
                 }
 
@@ -581,7 +581,7 @@ public class FindUnrelatedTypesInGenericContainer implements Detector {
 
                 IncompatibleTypes matchResult = compareTypes(expectedType, actualType, allMethod);
 
-                boolean parmIsObject = expectedType.getSignature().equals("Ljava/lang/Object;");
+                boolean parmIsObject = "Ljava/lang/Object;".equals(expectedType.getSignature());
                 boolean selfOperation = !allMethod && operand.equals(actualType) && !parmIsObject;
                 if (!allMethod && !parmIsObject && actualType instanceof GenericObjectType) {
 
@@ -596,33 +596,33 @@ public class FindUnrelatedTypesInGenericContainer implements Detector {
                     continue;
                 }
 
-                if (invokedMethodName.startsWith("contains") || invokedMethodName.equals("remove")) {
+                if (invokedMethodName.startsWith("contains") || "remove".equals(invokedMethodName)) {
                     InstructionHandle next = handle.getNext();
                     if (next != null) {
                         Instruction nextIns = next.getInstruction();
 
                         if (nextIns instanceof InvokeInstruction) {
                             XMethod nextMethod = XFactory.createXMethod((InvokeInstruction) nextIns, cpg);
-                            if (nextMethod.getName().equals("assertFalse")) {
+                            if ("assertFalse".equals(nextMethod.getName())) {
                                 continue;
                             }
                         }
                     }
-                } else if (invokedMethodName.equals("get") || invokedMethodName.equals("remove")) {
+                } else if ("get".equals(invokedMethodName) || "remove".equals(invokedMethodName)) {
                     InstructionHandle next = handle.getNext();
                     if (next != null) {
                         Instruction nextIns = next.getInstruction();
 
                         if (nextIns instanceof InvokeInstruction) {
                             XMethod nextMethod = XFactory.createXMethod((InvokeInstruction) nextIns, cpg);
-                            if (nextMethod.getName().equals("assertNull")) {
+                            if ("assertNull".equals(nextMethod.getName())) {
                                 continue;
                             }
                         }
                     }
                 }
                 boolean noisy = false;
-                if (invokedMethodName.equals("get")) {
+                if ("get".equals(invokedMethodName)) {
                     UnconditionalValueDerefDataflow unconditionalValueDerefDataflow = classContext
                             .getUnconditionalValueDerefDataflow(method);
 
@@ -740,6 +740,9 @@ public class FindUnrelatedTypesInGenericContainer implements Detector {
         if (actualString.equals(objString) && expectedCat == TypeCategory.TYPE_VARIABLE) {
             return IncompatibleTypes.SEEMS_OK;
         }
+        if (expectedCat == TypeCategory.WILDCARD) {
+            return IncompatibleTypes.SEEMS_OK;
+        }
         if (ignoreBaseType) {
             if (expectedCat == TypeCategory.PARAMETERIZED && argCat == TypeCategory.PARAMETERIZED) {
                 GenericObjectType parmGeneric = (GenericObjectType) expectedType;
diff --git a/FindUnreleasedLock.java b/FindUnreleasedLock.java
index 1752ce703b83255e3b26015eb0573fa138814ec3..51e2313723023056022cfc7bb9b174655576d1a0 100644
--- a/FindUnreleasedLock.java
+++ b/FindUnreleasedLock.java
@@ -213,7 +213,7 @@ public class FindUnreleasedLock extends ResourceTrackingDetector<Lock, FindUnrel
             String methodSig = inv.getSignature(cpg);
 
             try {
-                if (methodName.equals("lock") && methodSig.equals("()V")
+                if ("lock".equals(methodName) && "()V".equals(methodSig)
                         && Hierarchy.isSubtype(className, "java.util.concurrent.locks.Lock")) {
 
                     Location location = new Location(handle, basicBlock);
@@ -246,7 +246,7 @@ public class FindUnreleasedLock extends ResourceTrackingDetector<Lock, FindUnrel
             String methodSig = inv.getSignature(cpg);
 
             try {
-                if (methodName.equals("unlock") && methodSig.equals("()V")
+                if ("unlock".equals(methodName) && "()V".equals(methodSig)
                         && Hierarchy.isSubtype(className, "java.util.concurrent.locks.Lock")) {
 
                     return true;
@@ -300,7 +300,7 @@ public class FindUnreleasedLock extends ResourceTrackingDetector<Lock, FindUnrel
                     }
                     // Ignore exceptions from getfield instructions where the
                     // object reference is known not to be null
-                    if (fieldName.equals("lock")) {
+                    if ("lock".equals(fieldName)) {
                         return true;
                     }
                     IsNullValueFrame frame = isNullDataflow.getFactAtLocation(location);
@@ -320,10 +320,10 @@ public class FindUnreleasedLock extends ResourceTrackingDetector<Lock, FindUnrel
                     if (methodName.startsWith("access$")) {
                         return true;
                     }
-                    if (methodName.equals("readLock") || methodName.equals("writeLock")) {
+                    if ("readLock".equals(methodName) || "writeLock".equals(methodName)) {
                         return true;
                     }
-                    if (methodName.equals("lock") || methodName.equals("unlock")) {
+                    if ("lock".equals(methodName) || "unlock".equals(methodName)) {
                         return true;
                     }
                 }
diff --git a/FindUnsatisfiedObligation.java b/FindUnsatisfiedObligation.java
index 98bdaef2dc6951dfe6797b3aec4a4c35cdd269fb..a4e523a275ec13952152bacf3bb250c114c32667 100644
--- a/FindUnsatisfiedObligation.java
+++ b/FindUnsatisfiedObligation.java
@@ -45,6 +45,7 @@ import edu.umd.cs.findbugs.IntAnnotation;
 import edu.umd.cs.findbugs.SourceLineAnnotation;
 import edu.umd.cs.findbugs.StringAnnotation;
 import edu.umd.cs.findbugs.SystemProperties;
+import edu.umd.cs.findbugs.ba.AnalysisContext;
 import edu.umd.cs.findbugs.ba.BasicBlock;
 import edu.umd.cs.findbugs.ba.CFG;
 import edu.umd.cs.findbugs.ba.DataflowAnalysisException;
@@ -67,6 +68,7 @@ import edu.umd.cs.findbugs.ba.type.TypeFrame;
 import edu.umd.cs.findbugs.bcel.CFGDetector;
 import edu.umd.cs.findbugs.classfile.CheckedAnalysisException;
 import edu.umd.cs.findbugs.classfile.ClassDescriptor;
+import edu.umd.cs.findbugs.classfile.DescriptorFactory;
 import edu.umd.cs.findbugs.classfile.Global;
 import edu.umd.cs.findbugs.classfile.IAnalysisCache;
 import edu.umd.cs.findbugs.classfile.MethodDescriptor;
@@ -311,13 +313,25 @@ public class FindUnsatisfiedObligation extends CFGDetector {
         private void reportWarning(Obligation obligation, State state, StateSet factAtExit) {
             String className = obligation.getClassName();
 
-            if (methodDescriptor.isStatic() && methodDescriptor.getName().equals("main")
-                    && methodDescriptor.getSignature().equals("([Ljava/lang/String;)V")
+            if (methodDescriptor.isStatic() && "main".equals(methodDescriptor.getName())
+                    && "([Ljava/lang/String;)V".equals(methodDescriptor.getSignature())
                     && (className.contains("InputStream") || className.contains("Reader") || factAtExit.isOnExceptionPath())) {
                 // Don't report unclosed input streams and readers in main()
                 // methods
                 return;
             }
+
+            if (methodDescriptor.getName().equals("<init>")) {
+                try {
+
+                    if (subtypes2.isSubtype(methodDescriptor.getClassDescriptor(), DescriptorFactory.createClassDescriptorFromDottedClassName(obligation.getClassName()))) {
+                        return;
+                    }
+
+                } catch (Exception e) {
+                    AnalysisContext.logError("huh", e);
+                }
+            }
             String bugPattern = factAtExit.isOnExceptionPath() ? "OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE" : "OBL_UNSATISFIED_OBLIGATION";
             BugInstance bugInstance = new BugInstance(FindUnsatisfiedObligation.this, bugPattern,
                     NORMAL_PRIORITY).addClassAndMethod(methodDescriptor).addClass(className).describe("CLASS_REFTYPE");
@@ -514,7 +528,7 @@ public class FindUnsatisfiedObligation extends CFGDetector {
                 }
 
                 String methodName = inv.getMethodName(cpg);
-                Type producedType = methodName.equals("<init>") ? inv.getReferenceType(cpg) : inv.getReturnType(cpg);
+                Type producedType = "<init>".equals(methodName) ? inv.getReferenceType(cpg) : inv.getReturnType(cpg);
 
                 if (DEBUG_FP && !(producedType instanceof ObjectType)) {
                     System.out.println("Produced type " + producedType + " not an ObjectType");
diff --git a/FindUseOfNonSerializableValue.java b/FindUseOfNonSerializableValue.java
index 0f7aba1a234d0c6f29fef911132c8decc59a6c58..f763bb9266b74b95eacb31525c043acd6eae4e5a 100644
--- a/FindUseOfNonSerializableValue.java
+++ b/FindUseOfNonSerializableValue.java
@@ -64,9 +64,9 @@ public class FindUseOfNonSerializableValue implements Detector {
                 @DottedClassName String clazz = m.getClass(constantPool);
                 ConstantNameAndType nt = (ConstantNameAndType) constantPool.getConstant(m.getNameAndTypeIndex(), Constants.CONSTANT_NameAndType);
                 String name = nt.getName(constantPool);
-                if (name.equals("setAttribute") && clazz.equals("javax.servlet.http.HttpSession") || (name.equals("writeObject")
-                        && (clazz.equals("java.io.ObjectOutput")
-                                || clazz.equals("java.io.ObjectOutputStream")))) {
+                if ("setAttribute".equals(name) && "javax.servlet.http.HttpSession".equals(clazz) || ("writeObject".equals(name)
+                        && ("java.io.ObjectOutput".equals(clazz)
+                                || "java.io.ObjectOutputStream".equals(clazz)))) {
                     if (DEBUG) {
                         System.out.println("Found call to " + clazz + "." + name);
                     }
@@ -111,12 +111,12 @@ public class FindUseOfNonSerializableValue implements Detector {
             String mName = invoke.getMethodName(cpg);
             String cName = invoke.getClassName(cpg);
 
-            if (mName.equals("setAttribute") && cName.equals("javax.servlet.http.HttpSession")) {
+            if ("setAttribute".equals(mName) && "javax.servlet.http.HttpSession".equals(cName)) {
                 return Use.STORE_INTO_HTTP_SESSION;
             }
-            if (mName.equals("writeObject")
-                    && (cName.equals("java.io.ObjectOutput")
-                            || cName.equals("java.io.ObjectOutputStream"))) {
+            if ("writeObject".equals(mName)
+                    && ("java.io.ObjectOutput".equals(cName)
+                            || "java.io.ObjectOutputStream".equals(cName))) {
                 return Use.PASSED_TO_WRITE_OBJECT;
             }
         }
diff --git a/FindUselessObjects.java b/FindUselessObjects.java
new file mode 100644
index 0000000000000000000000000000000000000000..93e8164c17091df1c6695c6f0a2aa95b86b58369
--- /dev/null
+++ b/FindUselessObjects.java
@@ -0,0 +1,703 @@
+/*
+ * FindBugs - Find Bugs in Java programs
+ * Copyright (C) 2003-2008 University of Maryland
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+package edu.umd.cs.findbugs.detect;
+
+import static org.apache.bcel.Constants.*;
+
+import java.util.BitSet;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.NoSuchElementException;
+import java.util.Set;
+
+import org.apache.bcel.classfile.LocalVariable;
+import org.apache.bcel.classfile.LocalVariableTable;
+import org.apache.bcel.classfile.Method;
+import org.apache.bcel.generic.ANEWARRAY;
+import org.apache.bcel.generic.ConstantPoolGen;
+import org.apache.bcel.generic.IINC;
+import org.apache.bcel.generic.INVOKESPECIAL;
+import org.apache.bcel.generic.Instruction;
+import org.apache.bcel.generic.InstructionHandle;
+import org.apache.bcel.generic.InvokeInstruction;
+import org.apache.bcel.generic.MULTIANEWARRAY;
+import org.apache.bcel.generic.NEWARRAY;
+import org.apache.bcel.generic.POP;
+import org.apache.bcel.generic.POP2;
+import org.apache.bcel.generic.StoreInstruction;
+import org.apache.bcel.generic.Type;
+
+import edu.umd.cs.findbugs.BugInstance;
+import edu.umd.cs.findbugs.BugReporter;
+import edu.umd.cs.findbugs.Detector;
+import edu.umd.cs.findbugs.StringAnnotation;
+import edu.umd.cs.findbugs.ba.BasicBlock;
+import edu.umd.cs.findbugs.ba.CFG;
+import edu.umd.cs.findbugs.ba.ClassContext;
+import edu.umd.cs.findbugs.ba.DataflowAnalysisException;
+import edu.umd.cs.findbugs.ba.EdgeTypes;
+import edu.umd.cs.findbugs.ba.Location;
+import edu.umd.cs.findbugs.ba.XClass;
+import edu.umd.cs.findbugs.ba.XMethod;
+import edu.umd.cs.findbugs.ba.type.TypeAnalysis;
+import edu.umd.cs.findbugs.ba.type.TypeFrame;
+import edu.umd.cs.findbugs.ba.vna.ValueNumber;
+import edu.umd.cs.findbugs.ba.vna.ValueNumberAnalysis;
+import edu.umd.cs.findbugs.ba.vna.ValueNumberFrame;
+import edu.umd.cs.findbugs.classfile.CheckedAnalysisException;
+import edu.umd.cs.findbugs.classfile.DescriptorFactory;
+import edu.umd.cs.findbugs.classfile.Global;
+import edu.umd.cs.findbugs.classfile.MethodDescriptor;
+import edu.umd.cs.findbugs.detect.FindNoSideEffectMethods.MethodSideEffectStatus;
+import edu.umd.cs.findbugs.detect.FindNoSideEffectMethods.NoSideEffectMethodsDatabase;
+
+/**
+ * @author Tagir Valeev
+ */
+public class FindUselessObjects implements Detector {
+    private final BugReporter reporter;
+    private final NoSideEffectMethodsDatabase noSideEffectMethods;
+
+    private static class ValueInfo {
+        Location created;
+        String var;
+        int origValue;
+        boolean hasObjectOnlyCall;
+        boolean escaped;
+        boolean used;
+        boolean derivedEscaped;
+        public BitSet origValues;
+        public BitSet derivedValues = new BitSet();
+        Type type;
+
+        public ValueInfo(int origValue, Location location, Type type) {
+            this.created = location;
+            this.origValue = origValue;
+            this.type = type;
+        }
+
+        @Override
+        public String toString() {
+            return "[" + (escaped ? "E" : "-") + (hasObjectOnlyCall ? "O" : "-") + (used ? "U" : "-")
+                    + (derivedEscaped ? "D" : "-") + "] " + (var == null ? "" : var + " ") + type + " " + created;
+        }
+    }
+
+    private class UselessValuesContext {
+        ValueNumberAnalysis vna;
+        TypeAnalysis ta;
+        CFG cfg;
+        int count;
+        Map<Integer, ValueInfo> observedValues = new HashMap<>();
+        ConstantPoolGen cpg;
+        Map<Integer, Set<ValueInfo>> values;
+        ValueNumber thisValue;
+        ClassContext classContext;
+        Method method;
+
+        UselessValuesContext(ClassContext classContext, Method method) throws CheckedAnalysisException {
+            this.classContext = classContext;
+            this.method = method;
+            cfg = classContext.getCFG(method);
+            cpg = cfg.getMethodGen().getConstantPool();
+            ta = classContext.getTypeDataflow(method).getAnalysis();
+            vna = classContext.getValueNumberDataflow(method).getAnalysis();
+        }
+
+        void initObservedValues() throws DataflowAnalysisException {
+            for(Iterator<Location> iterator = cfg.locationIterator(); iterator.hasNext(); ) {
+                Location location = iterator.next();
+                Instruction instruction = location.getHandle().getInstruction();
+                if(instruction instanceof ANEWARRAY || instruction instanceof NEWARRAY || instruction instanceof MULTIANEWARRAY) {
+                    int number = vna.getFactAfterLocation(location).getTopValue().getNumber();
+                    TypeFrame typeFrame = ta.getFactAfterLocation(location);
+                    if(typeFrame.isValid()) {
+                        Type type = typeFrame.getTopValue();
+                        observedValues.put(number, new ValueInfo(number, location, type));
+                    }
+                } else if(instruction instanceof INVOKESPECIAL) {
+                    InvokeInstruction inv = (InvokeInstruction) instruction;
+                    if (inv.getMethodName(cpg).equals("<init>")
+                            && noSideEffectMethods.hasNoSideEffect(new MethodDescriptor(inv, cpg))) {
+                        int number = vna.getFactAtLocation(location).getStackValue(inv.consumeStack(cpg)-1).getNumber();
+                        TypeFrame typeFrame = ta.getFactAtLocation(location);
+                        if(typeFrame.isValid()) {
+                            Type type = typeFrame.getStackValue(inv.consumeStack(cpg)-1);
+                            observedValues.put(number, new ValueInfo(number, location, type));
+                        }
+                    }
+                }
+            }
+            thisValue = vna.getThisValue();
+            if(thisValue != null) {
+                observedValues.remove(thisValue.getNumber());
+            }
+            count = observedValues.size();
+        }
+
+        void enhanceViaMergeTree() {
+            values = new HashMap<>();
+            for (Entry<Integer, ValueInfo> entry : observedValues.entrySet()) {
+                BitSet outputSet = vna.getMergeTree().getTransitiveOutputSet(entry.getKey());
+                outputSet.set(entry.getKey());
+                entry.getValue().origValues = outputSet;
+                for (int i = outputSet.nextSetBit(0); i >= 0; i = outputSet.nextSetBit(i+1)) {
+                    Set<ValueInfo> list = values.get(i);
+                    if(list == null) {
+                        list = new HashSet<>();
+                        values.put(i, list);
+                    }
+                    list.add(entry.getValue());
+                }
+            }
+        }
+
+        boolean setEscape(Set<ValueInfo> vals) {
+            boolean result = false;
+            for(ValueInfo vi : vals) {
+                result |= !vi.escaped;
+                vi.escaped = true;
+                count--;
+            }
+            return result;
+        }
+
+        boolean setDerivedEscape(Set<ValueInfo> vals, ValueNumber vn) {
+            boolean result = false;
+            for(ValueInfo vi : vals) {
+                if(vi.origValues.get(vn.getNumber())) {
+                    result |= !vi.derivedEscaped;
+                    vi.derivedEscaped = true;
+                }
+            }
+            return result;
+        }
+
+        boolean setUsed(Set<ValueInfo> vals) {
+            boolean result = false;
+            for(ValueInfo vi : vals) {
+                result |= !vi.used;
+                vi.used = true;
+            }
+            return result;
+        }
+
+        boolean setObjectOnly(Set<ValueInfo> vals, ValueNumber vn) {
+            boolean result = false;
+            for(ValueInfo vi : vals) {
+                if(vi.origValues.get(vn.getNumber()) || (!vi.derivedEscaped && vi.derivedValues.get(vn.getNumber()))) {
+                    result |= !vi.hasObjectOnlyCall;
+                    vi.hasObjectOnlyCall = true;
+                } else {
+                    result |= !vi.escaped;
+                    vi.escaped = true;
+                    count--;
+                }
+            }
+            return result;
+        }
+
+        boolean propagateValues(Set<ValueInfo> vals, ValueNumber origNumber, ValueNumber vn) {
+            int number = vn.getNumber();
+            if(vals.size() == 1 && vals.iterator().next().origValue == number) {
+                return false;
+            }
+            boolean result = setUsed(vals);
+            if(origNumber != null) {
+                for(ValueInfo vi : vals) {
+                    if(vi.origValues.get(origNumber.getNumber()) && !vi.derivedValues.get(number)) {
+                        vi.derivedValues.set(number);
+                        result = true;
+                    }
+                }
+            }
+            Set<ValueInfo> list = values.get(number);
+            if(list == null) {
+                list = new HashSet<>();
+                values.put(number, list);
+            }
+            result |= list.addAll(vals);
+            BitSet outputSet = vna.getMergeTree().getTransitiveOutputSet(number);
+            for (int i = outputSet.nextSetBit(0); i >= 0; i = outputSet.nextSetBit(i+1)) {
+                list = values.get(i);
+                if(list == null) {
+                    list = new HashSet<>();
+                    values.put(i, list);
+                }
+                result |= list.addAll(vals);
+            }
+            return result;
+        }
+
+        boolean propagateToReturnValue(Set<ValueInfo> vals, ValueNumber vn, GenLocation location, MethodDescriptor m)
+                throws DataflowAnalysisException {
+            for(ValueInfo vi : vals) {
+                if(vi.type.getSignature().startsWith("[") && vi.hasObjectOnlyCall && vi.var == null && vn.getNumber() == vi.origValue) {
+                    // Ignore initialized arrays passed to methods
+                    vi.escaped = true;
+                    count--;
+                }
+            }
+            if (Type.getReturnType(m.getSignature()) == Type.VOID || location instanceof ExceptionLocation) {
+                return false;
+            }
+            InstructionHandle nextHandle = location.getHandle().getNext();
+            if (nextHandle == null || (nextHandle.getInstruction() instanceof POP || nextHandle.getInstruction() instanceof POP2)) {
+                return false;
+            }
+            return propagateValues(vals, null, location.frameAfter().getTopValue());
+        }
+
+        boolean isEmpty() {
+            return count == 0;
+        }
+
+        Iterator<GenLocation> genIterator() {
+            return new Iterator<FindUselessObjects.GenLocation>() {
+                Iterator<Location> locIterator = cfg.locationIterator();
+                Iterator<BasicBlock> blockIterator = cfg.blockIterator();
+                GenLocation next = advance();
+
+                private GenLocation advance() {
+                    if(locIterator.hasNext()) {
+                        return new RegularLocation(ta, vna, locIterator.next());
+                    }
+                    while(blockIterator.hasNext()) {
+                        BasicBlock block = blockIterator.next();
+                        if(block.isExceptionThrower() && cfg.getOutgoingEdgeWithType(block, EdgeTypes.FALL_THROUGH_EDGE) == null) {
+                            return new ExceptionLocation(ta, vna, block);
+                        }
+                    }
+                    return null;
+                }
+
+                @Override
+                public boolean hasNext() {
+                    return next != null;
+                }
+
+                @Override
+                public GenLocation next() {
+                    if (!hasNext()) {
+                        throw new NoSuchElementException();
+                    }
+                    GenLocation cur = next;
+                    next = advance();
+                    return cur;
+                }
+
+                @Override
+                public void remove() {
+                    throw new UnsupportedOperationException();
+                }
+            };
+        }
+
+        boolean escaped(ValueNumber vn) {
+            Set<ValueInfo> vals = values.get(vn.getNumber());
+            if(vals == null) {
+                return true;
+            }
+            for(ValueInfo vi : vals) {
+                if(vi.escaped) {
+                    return true;
+                }
+            }
+            return false;
+        }
+
+        Set<ValueInfo> getLiveVals(ValueNumber vn) {
+            Set<ValueInfo> vals = this.values.get(vn.getNumber());
+            if(vals == null) {
+                return null;
+            }
+            if(vals.size() == 1) {
+                return vals.iterator().next().escaped ? null : vals;
+            }
+            Set<ValueInfo> result = new HashSet<>();
+            for(ValueInfo vi : vals) {
+                if(!vi.escaped) {
+                    result.add(vi);
+                }
+            }
+            return result.isEmpty() ? null : result;
+        }
+
+        void report() {
+            for(ValueInfo vi : observedValues.values()) {
+                if(!vi.escaped) {
+                    if(vi.hasObjectOnlyCall && vi.used && vi.var == null) {
+                        continue;
+                    }
+                    if(vi.hasObjectOnlyCall || (vi.used && vi.var != null)) {
+                        BugInstance bug = new BugInstance(vi.var == null ? "UC_USELESS_OBJECT_STACK" : "UC_USELESS_OBJECT",
+                                NORMAL_PRIORITY).addClassAndMethod(classContext.getJavaClass(), method);
+                        if(vi.var != null) {
+                            bug.add(new StringAnnotation(vi.var));
+                        }
+                        reporter.reportBug(bug.addType(vi.type).addSourceLine(classContext, method, vi.created));
+                    }
+                }
+            }
+        }
+    }
+
+    private static interface GenLocation {
+        InstructionHandle getHandle();
+        TypeFrame typeFrameBefore() throws DataflowAnalysisException;
+        ValueNumberFrame frameBefore();
+        ValueNumberFrame frameAfter();
+    }
+
+    private static class RegularLocation implements GenLocation {
+        Location loc;
+        ValueNumberAnalysis vna;
+        TypeAnalysis ta;
+
+        public RegularLocation(TypeAnalysis ta, ValueNumberAnalysis vna, Location loc) {
+            this.ta = ta;
+            this.vna = vna;
+            this.loc = loc;
+        }
+
+        @Override
+        public InstructionHandle getHandle() {
+            return loc.getHandle();
+        }
+
+        @Override
+        public ValueNumberFrame frameBefore() {
+            return vna.getFactAtLocation(loc);
+        }
+
+        @Override
+        public ValueNumberFrame frameAfter() {
+            return vna.getFactAfterLocation(loc);
+        }
+
+        @Override
+        public TypeFrame typeFrameBefore() throws DataflowAnalysisException {
+            return ta.getFactAtLocation(loc);
+        }
+
+        @Override
+        public String toString() {
+            return loc.toString();
+        }
+    }
+
+    private static class ExceptionLocation implements GenLocation {
+        BasicBlock b;
+        ValueNumberAnalysis vna;
+        TypeAnalysis ta;
+
+        public ExceptionLocation(TypeAnalysis ta, ValueNumberAnalysis vna, BasicBlock block) {
+            this.vna = vna;
+            this.ta = ta;
+            this.b = block;
+        }
+
+        @Override
+        public InstructionHandle getHandle() {
+            return b.getExceptionThrower();
+        }
+
+        @Override
+        public ValueNumberFrame frameBefore() {
+            return vna.getStartFact(b);
+        }
+
+        @Override
+        public ValueNumberFrame frameAfter() {
+            return vna.getResultFact(b);
+        }
+
+        @Override
+        public TypeFrame typeFrameBefore() {
+            return ta.getStartFact(b);
+        }
+
+        @Override
+        public String toString() {
+            return "ex: "+b.getExceptionThrower()+" at "+b;
+        }
+    }
+
+    public FindUselessObjects(BugReporter reporter) {
+        this.reporter = reporter;
+        this.noSideEffectMethods = Global.getAnalysisCache().getDatabase(NoSideEffectMethodsDatabase.class);
+    }
+
+    @Override
+    public void visitClassContext(ClassContext classContext) {
+        for(Method method : classContext.getMethodsInCallOrder()) {
+            if(method.isAbstract() || method.isNative()) {
+                continue;
+            }
+            try {
+                analyzeMethod(classContext, method);
+            } catch (CheckedAnalysisException e) {
+                reporter.logError("Error analyzing "+method+" (class: "+classContext.getJavaClass().getClassName()+")", e);
+            }
+        }
+    }
+
+    private void analyzeMethod(ClassContext classContext, Method method) throws CheckedAnalysisException {
+        LocalVariableTable lvt = method.getLocalVariableTable();
+        UselessValuesContext context = new UselessValuesContext(classContext, method);
+        context.initObservedValues();
+        if(context.isEmpty()) {
+            return;
+        }
+        context.enhanceViaMergeTree();
+        boolean changed;
+        do {
+            changed = false;
+            for(Iterator<GenLocation> iterator = context.genIterator(); iterator.hasNext() && !context.isEmpty(); ) {
+                GenLocation location = iterator.next();
+                Instruction inst = location.getHandle().getInstruction();
+                ValueNumberFrame before = location.frameBefore();
+                if (!before.isValid()) {
+                    continue;
+                }
+                if(inst instanceof IINC) {
+                    int index = ((IINC)inst).getIndex();
+                    Set<ValueInfo> vals = context.getLiveVals(before.getValue(index));
+                    if(vals != null) {
+                        changed |= context.propagateValues(vals, null, location.frameAfter().getValue(index));
+                    }
+                    continue;
+                }
+                int nconsumed = inst.consumeStack(context.cpg);
+                if(nconsumed > 0) {
+                    ValueNumber[] vns = new ValueNumber[nconsumed];
+                    before.getTopStackWords(vns);
+                    for(int i=0; i<nconsumed; i++) {
+                        ValueNumber vn = vns[i];
+                        Set<ValueInfo> vals = context.getLiveVals(vn);
+                        if(vals != null) {
+                            switch(inst.getOpcode()) {
+                            case ASTORE:
+                            case ASTORE_0:
+                            case ASTORE_1:
+                            case ASTORE_2:
+                            case ASTORE_3:
+                                for(ValueInfo vi : vals) {
+                                    if(vi.var == null && vi.origValue == vn.getNumber()) {
+                                        int index = ((StoreInstruction)inst).getIndex();
+                                        LocalVariable lv = lvt == null ? null : lvt.getLocalVariable(index, location.getHandle().getNext().getPosition());
+                                        vi.var = lv == null ? "var$"+index : lv.getName();
+                                        vi.hasObjectOnlyCall = false;
+                                        changed = true;
+                                    }
+                                }
+                                break;
+                            case POP:
+                            case POP2:
+                            case DUP:
+                            case DUP2:
+                            case DUP_X1:
+                            case DUP2_X1:
+                            case ISTORE:
+                            case ISTORE_0:
+                            case ISTORE_1:
+                            case ISTORE_2:
+                            case ISTORE_3:
+                            case LSTORE:
+                            case LSTORE_0:
+                            case LSTORE_1:
+                            case LSTORE_2:
+                            case LSTORE_3:
+                            case FSTORE:
+                            case FSTORE_0:
+                            case FSTORE_1:
+                            case FSTORE_2:
+                            case FSTORE_3:
+                            case DSTORE:
+                            case DSTORE_0:
+                            case DSTORE_1:
+                            case DSTORE_2:
+                            case DSTORE_3:
+                            case SWAP:
+                            case IMPDEP1:
+                            case IMPDEP2:
+                            case CHECKCAST:
+                            case MONITORENTER:
+                                break;
+                            case IADD:
+                            case LADD:
+                            case FADD:
+                            case DADD:
+                            case ISUB:
+                            case LSUB:
+                            case FSUB:
+                            case DSUB:
+                            case IMUL:
+                            case DMUL:
+                            case LMUL:
+                            case FMUL:
+                            case IDIV:
+                            case DDIV:
+                            case LDIV:
+                            case FDIV:
+                            case INEG:
+                            case LNEG:
+                            case FNEG:
+                            case DNEG:
+                            case IREM:
+                            case LREM:
+                            case FREM:
+                            case DREM:
+                            case ISHL:
+                            case LSHL:
+                            case ISHR:
+                            case LSHR:
+                            case IUSHR:
+                            case LUSHR:
+                            case IAND:
+                            case LAND:
+                            case IOR:
+                            case LOR:
+                            case IXOR:
+                            case LXOR:
+                            case I2L:
+                            case I2F:
+                            case I2D:
+                            case L2I:
+                            case L2F:
+                            case L2D:
+                            case F2I:
+                            case F2L:
+                            case F2D:
+                            case D2I:
+                            case D2L:
+                            case D2F:
+                            case I2B:
+                            case I2C:
+                            case I2S:
+                            case LCMP:
+                            case FCMPL:
+                            case FCMPG:
+                            case DCMPL:
+                            case DCMPG:
+                            case ARRAYLENGTH:
+                                changed |= context.propagateValues(vals, null, location.frameAfter().getTopValue());
+                                break;
+                            case GETFIELD:
+                            case AALOAD:
+                            case DALOAD:
+                            case BALOAD:
+                            case CALOAD:
+                            case LALOAD:
+                            case SALOAD:
+                            case IALOAD:
+                                changed |= context.propagateValues(vals, vn, location.frameAfter().getTopValue());
+                                break;
+                            case AASTORE:
+                            case DASTORE:
+                            case BASTORE:
+                            case CASTORE:
+                            case LASTORE:
+                            case SASTORE:
+                            case IASTORE:
+                            case PUTFIELD:
+                                if(i == 0) {
+                                    ValueNumber value = vns[vns.length-1];
+                                    if(!value.hasFlag(ValueNumber.CONSTANT_VALUE) && !value.hasFlag(ValueNumber.CONSTANT_CLASS_OBJECT) &&
+                                            !context.observedValues.containsKey(value.getNumber())) {
+                                        changed |= context.setDerivedEscape(vals, vn);
+                                    }
+                                    changed |= context.setObjectOnly(vals, vn);
+                                } else {
+                                    if(context.escaped(vns[0])) {
+                                        changed |= context.setEscape(vals);
+                                    } else {
+                                        changed |= context.propagateValues(vals, null, vns[0]);
+                                    }
+                                }
+                                break;
+                            case INVOKESTATIC:
+                            case INVOKESPECIAL:
+                            case INVOKEINTERFACE:
+                            case INVOKEVIRTUAL:
+                                MethodDescriptor m = new MethodDescriptor((InvokeInstruction) inst, context.cpg);
+                                XMethod xMethod = null;
+                                try {
+                                    Type type = location.typeFrameBefore().getStackValue(nconsumed-1);
+                                    xMethod = Global
+                                            .getAnalysisCache()
+                                            .getClassAnalysis(XClass.class,
+                                                    DescriptorFactory.createClassDescriptorFromSignature(type.getSignature()))
+                                                    .findMatchingMethod(m);
+                                } catch (CheckedAnalysisException e) {
+                                    // ignore
+                                }
+                                if(xMethod != null) {
+                                    m = xMethod.getMethodDescriptor();
+                                }
+                                MethodSideEffectStatus status = noSideEffectMethods.status(m);
+                                if(status == MethodSideEffectStatus.NSE || status == MethodSideEffectStatus.SE_CLINIT) {
+                                    if(m.getName().equals("<init>")) {
+                                        if(vns[0].equals(context.thisValue)) {
+                                            changed |= context.setEscape(vals);
+                                        } else {
+                                            changed |= context.propagateValues(vals, null, vns[0]);
+                                        }
+                                    } else {
+                                        changed |= context.propagateToReturnValue(vals, vn, location, m);
+                                    }
+                                    break;
+                                }
+                                if(status == MethodSideEffectStatus.OBJ) {
+                                    if(i == 0) {
+                                        changed |= context.setDerivedEscape(vals, vn);
+                                        changed |= context.propagateToReturnValue(vals, vn, location, m);
+                                        changed |= context.setObjectOnly(vals, vn);
+                                        break;
+                                    } else {
+                                        if(!context.escaped(vns[0])) {
+                                            changed |= context.propagateValues(vals, null, vns[0]);
+                                            changed |= context.propagateToReturnValue(vals, vn, location, m);
+                                            break;
+                                        }
+                                    }
+                                }
+                                changed |= context.setEscape(vals);
+                                break;
+                            default:
+                                changed |= context.setEscape(vals);
+                                break;
+                            }
+                        }
+                    }
+                }
+            }
+        } while(changed);
+        context.report();
+    }
+
+    @Override
+    public void report() {
+    }
+
+}
diff --git a/FormatStringChecker.java b/FormatStringChecker.java
index 292ae0ee2fededc1ac6f3de63ec51b293254f934..55c8737223d02d47db16bf5f5365d065ca8cbf6c 100644
--- a/FormatStringChecker.java
+++ b/FormatStringChecker.java
@@ -158,8 +158,10 @@ public class FormatStringChecker extends OpcodeStackDetector {
                             assert argDescriptor != null : "sig started with L, should get descriptor";
                             String arg = argDescriptor.toDottedClassName();
                             try {
-                                if (Hierarchy.isSubtype(arg,  java.util.Date.class.getName())
-                                        || Hierarchy.isSubtype(arg,  java.util.Calendar.class.getName())) {
+                                if (arg.equals("java.time.LocalDate")
+                                        || Hierarchy.isSubtype(arg,  java.util.Date.class.getName())
+                                        || Hierarchy.isSubtype(arg,  java.util.Calendar.class.getName())
+                                        || Hierarchy.isSubtype(arg,  "java.time.temporal.TemporalAccessor")) {
                                     return;
                                 }
                             } catch (ClassNotFoundException e1) {
diff --git a/FunctionsThatMightBeMistakenForProcedures.java b/FunctionsThatMightBeMistakenForProcedures.java
index 457c66f04a732db0961c1f1ed4f4b343db4be6d5..eb22744a2244599cfcfca8f7f0760d544678a52e 100644
--- a/FunctionsThatMightBeMistakenForProcedures.java
+++ b/FunctionsThatMightBeMistakenForProcedures.java
@@ -71,7 +71,7 @@ public class FunctionsThatMightBeMistakenForProcedures extends OpcodeStackDetect
 
     @Override
     public void visit(Field obj) {
-        if (obj.getName().equals("this$0")) {
+        if ("this$0".equals(obj.getName())) {
             isInnerClass = true;
         }
         if (!obj.isFinal() && !obj.isStatic() && !BCELUtil.isSynthetic(obj)) {
@@ -244,12 +244,12 @@ public class FunctionsThatMightBeMistakenForProcedures extends OpcodeStackDetect
                 returnSelf++;
                 break;
             }
-            if (xMethod.getName().equals("<init>")) {
+            if ("<init>".equals(xMethod.getName())) {
                 String sig = xMethod.getSignature();
                 // returning a newly constructed value
                 boolean voidConstructor;
                 if (!isInnerClass) {
-                    voidConstructor = sig.equals("()V");
+                    voidConstructor = "()V".equals(sig);
                 } else {
                     SignatureParser parser = new SignatureParser(sig);
                     voidConstructor = parser.getNumParameters()  <= 1;
@@ -269,12 +269,12 @@ public class FunctionsThatMightBeMistakenForProcedures extends OpcodeStackDetect
                 returnUnknown++;
                 break;
             }
-            if (xMethod.getName().equals("<init>") || doNotIgnoreHigh.contains(xMethod)) {
+            if ("<init>".equals(xMethod.getName()) || doNotIgnoreHigh.contains(xMethod)) {
                 returnOther++;
                 // System.out.println("  calls " + xMethod);
                 // System.out.println("  at " +
                 // MethodAnnotation.fromXMethod(xMethod).getSourceLines());
-                if (xMethod.getName().equals("<init>") || doNotIgnore.contains(xMethod)) {
+                if ("<init>".equals(xMethod.getName()) || doNotIgnore.contains(xMethod)) {
                     returnNew++;
                 }
             } else if (doNotIgnore.contains(xMethod)) {
diff --git a/IDivResultCastToDouble.java b/IDivResultCastToDouble.java
index 81ddd179048adee5e6f98098e8733633120e04a7..0c7f401fe946d5406621820d99e0c88efc62e027 100644
--- a/IDivResultCastToDouble.java
+++ b/IDivResultCastToDouble.java
@@ -48,13 +48,13 @@ public class IDivResultCastToDouble extends BytecodeScanningDetector {
         }
 
         if ((prevOpCode == I2D || prevOpCode == L2D) && seen == INVOKESTATIC && ClassName.isMathClass(getClassConstantOperand())
-                && getNameConstantOperand().equals("ceil")) {
+                && "ceil".equals(getNameConstantOperand())) {
             bugAccumulator
             .accumulateBug(new BugInstance(this, "ICAST_INT_CAST_TO_DOUBLE_PASSED_TO_CEIL", HIGH_PRIORITY)
             .addClassAndMethod(this), this);
             pendingIdivCastToDivBugLocation = null;
         } else if ((prevOpCode == I2F || prevOpCode == L2F) && seen == INVOKESTATIC
-                && ClassName.isMathClass(getClassConstantOperand()) && getNameConstantOperand().equals("round")) {
+                && ClassName.isMathClass(getClassConstantOperand()) && "round".equals(getNameConstantOperand())) {
             bugAccumulator.accumulateBug(
                     new BugInstance(this, "ICAST_INT_CAST_TO_FLOAT_PASSED_TO_ROUND", NORMAL_PRIORITY).addClassAndMethod(this),
                     this);
diff --git a/IncompatMask.java b/IncompatMask.java
index 4746860517497a04fdc67b1f43b219cf59eac31c..4312ef995ea068c861ffead763e4be56b2bec4e3 100644
--- a/IncompatMask.java
+++ b/IncompatMask.java
@@ -163,7 +163,7 @@ public class IncompatMask extends BytecodeScanningDetector implements StatelessD
         case IFLT:
         case IFGT:
         case IFGE:
-            if (state == 3 && isLong || state == 2 & !isLong) {
+            if (state == 3 && isLong || state == 2 && !isLong) {
                 long bits = getFlagBits(isLong, arg0);
                 boolean highbit = !isLong && (bits & 0x80000000) != 0 || isLong && bits < 0 && bits << 1 == 0;
                 boolean onlyLowBits = bits >>> 12 == 0;
@@ -223,7 +223,7 @@ public class IncompatMask extends BytecodeScanningDetector implements StatelessD
         if (dif != 0) {
             // System.out.println("Match at offset " + getPC());
             BugInstance bug = new BugInstance(this, t, HIGH_PRIORITY).addClassAndMethod(this);
-            if (!t.equals("BIT_AND_ZZ")) {
+            if (!"BIT_AND_ZZ".equals(t)) {
                 bug.addString("0x" + Long.toHexString(arg0)).addString("0x" + Long.toHexString(arg1));
             }
 
diff --git a/InefficientIndexOf.java b/InefficientIndexOf.java
index 9890d8c30cacfb808eea6289cc417cf4fd7219cf..0840f891bbeec90e4e295595bfab22e641773614 100644
--- a/InefficientIndexOf.java
+++ b/InefficientIndexOf.java
@@ -19,11 +19,16 @@
 
 package edu.umd.cs.findbugs.detect;
 
+import java.util.Arrays;
+import java.util.List;
+
 import edu.umd.cs.findbugs.BugInstance;
 import edu.umd.cs.findbugs.BugReporter;
 import edu.umd.cs.findbugs.OpcodeStack;
 import edu.umd.cs.findbugs.StringAnnotation;
+import edu.umd.cs.findbugs.ba.ClassContext;
 import edu.umd.cs.findbugs.bcel.OpcodeStackDetector;
+import edu.umd.cs.findbugs.classfile.MethodDescriptor;
 
 /**
  * Use whenever possible String.indexOf(int) instead of String.indexOf(String),
@@ -34,21 +39,35 @@ import edu.umd.cs.findbugs.bcel.OpcodeStackDetector;
 public class InefficientIndexOf extends OpcodeStackDetector {
     private final BugReporter bugReporter;
 
+    private static final List<MethodDescriptor> methods = Arrays.asList(
+            new MethodDescriptor("java/lang/String", "indexOf", "(Ljava/lang/String;)I"),
+            new MethodDescriptor("java/lang/String", "lastIndexOf", "(Ljava/lang/String;)I"),
+            new MethodDescriptor("java/lang/String", "indexOf", "(Ljava/lang/String;I)I"),
+            new MethodDescriptor("java/lang/String", "lastIndexOf", "(Ljava/lang/String;I)I")
+            );
+
     public InefficientIndexOf(BugReporter bugReporter) {
         this.bugReporter = bugReporter;
     }
 
     @Override
+    public void visitClassContext(ClassContext classContext) {
+        if(hasInterestingMethod(classContext.getJavaClass().getConstantPool(), methods)) {
+            super.visitClassContext(classContext);
+        }
+    }
+
+    @Override
     public void sawOpcode(int seen) {
-        if (seen == INVOKEVIRTUAL && stack.getStackDepth() > 0 && getClassConstantOperand().equals("java/lang/String")) {
+        if (seen == INVOKEVIRTUAL && stack.getStackDepth() > 0 && "java/lang/String".equals(getClassConstantOperand())) {
 
-            boolean lastIndexOf = getNameConstantOperand().equals("lastIndexOf");
-            if (lastIndexOf || getNameConstantOperand().equals("indexOf")) {
+            boolean lastIndexOf = "lastIndexOf".equals(getNameConstantOperand());
+            if (lastIndexOf || "indexOf".equals(getNameConstantOperand())) {
 
                 int stackOff = -1;
-                if (getSigConstantOperand().equals("(Ljava/lang/String;)I")) { // sig: String
+                if ("(Ljava/lang/String;)I".equals(getSigConstantOperand())) { // sig: String
                     stackOff = 0;
-                } else if (getSigConstantOperand().equals("(Ljava/lang/String;I)I")) { // sig: String, int
+                } else if ("(Ljava/lang/String;I)I".equals(getSigConstantOperand())) { // sig: String, int
                     stackOff = 1;
                 }
                 if (stackOff > -1) {
diff --git a/InefficientInitializationInsideLoop.java b/InefficientInitializationInsideLoop.java
new file mode 100644
index 0000000000000000000000000000000000000000..b9d04589939534d7bf9ec20411e53f833f6fa747
--- /dev/null
+++ b/InefficientInitializationInsideLoop.java
@@ -0,0 +1,181 @@
+/*
+ * FindBugs - Find Bugs in Java programs
+ * Copyright (C) 2003-2008 University of Maryland
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+package edu.umd.cs.findbugs.detect;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map.Entry;
+import java.util.Set;
+import java.util.SortedMap;
+import java.util.TreeMap;
+
+import org.apache.bcel.classfile.Method;
+
+import edu.umd.cs.findbugs.BugInstance;
+import edu.umd.cs.findbugs.BugReporter;
+import edu.umd.cs.findbugs.OpcodeStack.Item;
+import edu.umd.cs.findbugs.StringAnnotation;
+import edu.umd.cs.findbugs.ba.ClassContext;
+import edu.umd.cs.findbugs.ba.XMethod;
+import edu.umd.cs.findbugs.bcel.OpcodeStackDetector;
+import edu.umd.cs.findbugs.classfile.MethodDescriptor;
+
+/**
+ * @author Tagir Valeev
+ */
+public class InefficientInitializationInsideLoop extends OpcodeStackDetector {
+    private static final MethodDescriptor NODELIST_GET_LENGTH = new MethodDescriptor("org/w3c/dom/NodeList", "getLength", "()I");
+    private static final MethodDescriptor PATTERN_COMPILE = new MethodDescriptor("java/util/regex/Pattern", "compile", "(Ljava/lang/String;)Ljava/util/regex/Pattern;", true);
+    private static final MethodDescriptor PATTERN_COMPILE_2 = new MethodDescriptor("java/util/regex/Pattern", "compile", "(Ljava/lang/String;I)Ljava/util/regex/Pattern;", true);
+    private static final MethodDescriptor PATTERN_MATCHES = new MethodDescriptor("java/util/regex/Pattern", "matches", "(Ljava/lang/String;Ljava/lang/CharSequence;)Z", true);
+    private static final MethodDescriptor STRING_REPLACEALL = new MethodDescriptor("java/lang/String", "replaceAll", "(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;");
+    private static final MethodDescriptor STRING_REPLACEFIRST = new MethodDescriptor("java/lang/String", "replaceFirst", "(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;");
+    private static final MethodDescriptor STRING_MATCHES = new MethodDescriptor("java/lang/String", "matches", "(Ljava/lang/String;)Z");
+    private static final MethodDescriptor STRING_SPLIT = new MethodDescriptor("java/lang/String", "split", "(Ljava/lang/String;)[Ljava/lang/String;");
+    private static final MethodDescriptor STRING_SPLIT_2 = new MethodDescriptor("java/lang/String", "split", "(Ljava/lang/String;I)[Ljava/lang/String;");
+
+    private static final Set<MethodDescriptor> implicitPatternMethods = new HashSet<>(Arrays.asList(PATTERN_MATCHES,
+            STRING_MATCHES, STRING_REPLACEALL, STRING_REPLACEFIRST, STRING_SPLIT, STRING_SPLIT_2));
+
+    private static final List<MethodDescriptor> methods = new ArrayList<>();
+
+    static {
+        methods.add(NODELIST_GET_LENGTH);
+        methods.add(PATTERN_COMPILE);
+        methods.add(PATTERN_COMPILE_2);
+        methods.addAll(implicitPatternMethods);
+    }
+
+    private SortedMap<Integer, BugInstance> matched;
+
+    private SortedMap<Integer, Integer> conditions;
+
+    private SortedMap<Integer, Integer> sources;
+
+    private final BugReporter bugReporter;
+
+    public InefficientInitializationInsideLoop(BugReporter bugReporter) {
+        this.bugReporter = bugReporter;
+    }
+
+    @Override
+    public void visitClassContext(ClassContext classContext) {
+        if (hasInterestingMethod(classContext.getJavaClass().getConstantPool(), methods)
+                || hasInterestingClass(classContext.getJavaClass().getConstantPool(),
+                        Collections.singleton("java/sql/Connection"))) {
+            super.visitClassContext(classContext);
+        }
+    }
+
+    @Override
+    public void visitMethod(Method obj) {
+        matched = new TreeMap<>();
+        conditions = new TreeMap<>();
+        sources = new TreeMap<>();
+        super.visitMethod(obj);
+    }
+
+    /**
+     * Since JDK 1.7 there's a special branch in String.split which works very fast for one-character pattern
+     * We do not report a bug if this case takes place
+     * (in fact precompilation will make split much slower since this fast path doesn't use regexp engine at all)
+     * @param regex regex to test whether it's suitable for the fast path
+     * @return true if fast path is possible
+     */
+    private boolean isFastPath(String regex) {
+        char ch;
+        return (((regex.length() == 1 && ".$|()[{^?*+\\".indexOf(ch = regex.charAt(0)) == -1) || (regex.length() == 2
+                && regex.charAt(0) == '\\' && (((ch = regex.charAt(1)) - '0') | ('9' - ch)) < 0 && ((ch - 'a') | ('z' - ch)) < 0 && ((ch - 'A') | ('Z' - ch)) < 0)) && (ch < Character.MIN_HIGH_SURROGATE || ch > Character.MAX_LOW_SURROGATE));
+    }
+
+    @Override
+    public void sawOpcode(int seen) {
+        if (seen == INVOKEINTERFACE && getClassConstantOperand().equals("java/sql/Connection")
+                && getMethodDescriptorOperand().getName().equals("prepareStatement") && hasConstantArguments()) {
+            matched.put(getPC(), new BugInstance(this, "IIL_PREPARE_STATEMENT_IN_LOOP", NORMAL_PRIORITY).addClassAndMethod(this)
+                    .addSourceLine(this, getPC()).addCalledMethod(this));
+        } else if (seen == INVOKEINTERFACE && getMethodDescriptorOperand().equals(NODELIST_GET_LENGTH)) {
+            Item item = getStack().getStackItem(0);
+            XMethod returnValueOf = item.getReturnValueOf();
+            if(returnValueOf != null && returnValueOf.getClassName().startsWith("org.w3c.dom.") && returnValueOf.getName().startsWith("getElementsByTagName")) {
+                matched.put(getPC(),
+                        new BugInstance(this, "IIL_ELEMENTS_GET_LENGTH_IN_LOOP", NORMAL_PRIORITY).addClassAndMethod(this)
+                        .addSourceLine(this, getPC()).addCalledMethod(this));
+                sources.put(getPC(), item.getPC());
+            }
+        } else if (seen == INVOKESTATIC
+                && (getMethodDescriptorOperand().equals(PATTERN_COMPILE) || getMethodDescriptorOperand()
+                        .equals(PATTERN_COMPILE_2)) && hasConstantArguments()) {
+            String regex = getFirstArgument();
+            matched.put(getPC(), new BugInstance(this, "IIL_PATTERN_COMPILE_IN_LOOP", NORMAL_PRIORITY).addClassAndMethod(this)
+                    .addSourceLine(this, getPC()).addCalledMethod(this).addString(regex).describe(StringAnnotation.REGEX_ROLE));
+        } else if ((seen == INVOKESTATIC || seen == INVOKEVIRTUAL) && implicitPatternMethods.contains(getMethodDescriptorOperand())) {
+            String regex = getFirstArgument();
+            if (regex != null && !(getNameConstantOperand().equals("split") && isFastPath(regex))) {
+                BugInstance bug = new BugInstance(this, "IIL_PATTERN_COMPILE_IN_LOOP_INDIRECT", LOW_PRIORITY)
+                .addClassAndMethod(this).addSourceLine(this, getPC()).addCalledMethod(this).addString(regex)
+                .describe(StringAnnotation.REGEX_ROLE);
+                matched.put(getPC(), bug);
+            }
+        } else if (isBranch(seen) && getBranchOffset() > 0) {
+            conditions.put(getPC(), getBranchTarget());
+        } else if (!matched.isEmpty() && isBranch(seen) && getBranchOffset() < 0) {
+            for (Entry<Integer, BugInstance> entry : matched.tailMap(getBranchTarget()).entrySet()) {
+                Integer source = sources.get(entry.getKey());
+                if(source != null && (source > getBranchTarget() && source < getPC())) {
+                    // Object was created in the same loop: ignore
+                    return;
+                }
+                for (int target : conditions.subMap(getBranchTarget(), entry.getKey()).values()) {
+                    if (target > entry.getKey() && target < getPC()) {
+                        return;
+                    }
+                }
+                bugReporter.reportBug(entry.getValue());
+            }
+        }
+    }
+
+    /**
+     * @return first argument of the called method if it's a constant
+     */
+    private String getFirstArgument() {
+        Object value = getStack().getStackItem(getNumberArguments(getMethodDescriptorOperand().getSignature()) - 1)
+                .getConstant();
+        return value == null ? null : value.toString();
+    }
+
+    /**
+     * @return true if only constants are passed to the called method
+     */
+    private boolean hasConstantArguments() {
+        int nArgs = getNumberArguments(getMethodDescriptorOperand().getSignature());
+        for (int i = 0; i < nArgs; i++) {
+            if (getStack().getStackItem(i).getConstant() == null) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+}
diff --git a/InefficientMemberAccess.java b/InefficientMemberAccess.java
index 28b3abc62d2a9114dc968d143fb505b470835cea..138e9a15d1d15ca21055e785086dbd6b32229f34 100644
--- a/InefficientMemberAccess.java
+++ b/InefficientMemberAccess.java
@@ -29,6 +29,7 @@ import edu.umd.cs.findbugs.StatelessDetector;
 import edu.umd.cs.findbugs.ba.AnalysisContext;
 import edu.umd.cs.findbugs.ba.ClassContext;
 import edu.umd.cs.findbugs.ba.InnerClassAccess;
+import edu.umd.cs.findbugs.ba.SignatureParser;
 
 public class InefficientMemberAccess extends BytecodeScanningDetector implements StatelessDetector {
 
@@ -73,7 +74,7 @@ public class InefficientMemberAccess extends BytecodeScanningDetector implements
             if (!parCls.equals(getClassConstantOperand())) {
                 return;
             }
-            if ((argTypes.length == 2) && !argTypes[1].getSignature().equals(Type.getReturnType(methodSig).getSignature())) {
+            if ((argTypes.length == 2) && !argTypes[1].getSignature().equals(new SignatureParser(methodSig).getReturnTypeSignature())) {
                 return;
             }
 
diff --git a/InefficientToArray.java b/InefficientToArray.java
index 5741d904d4c196f59ccfbd436dbf3358ef3e325b..e578f469ec499bae7af5d8ed066247428d39be60 100644
--- a/InefficientToArray.java
+++ b/InefficientToArray.java
@@ -20,6 +20,9 @@
 
 package edu.umd.cs.findbugs.detect;
 
+import java.util.Collections;
+import java.util.List;
+
 import org.apache.bcel.Repository;
 import org.apache.bcel.classfile.Code;
 import org.apache.bcel.classfile.JavaClass;
@@ -33,6 +36,7 @@ import edu.umd.cs.findbugs.StatelessDetector;
 import edu.umd.cs.findbugs.SystemProperties;
 import edu.umd.cs.findbugs.ba.AnalysisContext;
 import edu.umd.cs.findbugs.ba.ClassContext;
+import edu.umd.cs.findbugs.classfile.MethodDescriptor;
 
 /**
  * Find occurrences of collection.toArray( new Foo[0] ); This causes another
@@ -44,6 +48,9 @@ import edu.umd.cs.findbugs.ba.ClassContext;
 public class InefficientToArray extends BytecodeScanningDetector implements StatelessDetector {
     private static final boolean DEBUG = SystemProperties.getBoolean("ita.debug");
 
+    private static final List<MethodDescriptor> methods = Collections.singletonList(new MethodDescriptor("", "toArray",
+            "([Ljava/lang/Object;)[Ljava/lang/Object;"));
+
     static final int SEEN_NOTHING = 0;
 
     static final int SEEN_ICONST_0 = 1;
@@ -75,7 +82,7 @@ public class InefficientToArray extends BytecodeScanningDetector implements Stat
 
     @Override
     public void visitClassContext(ClassContext classContext) {
-        if (collectionClass != null) {
+        if (collectionClass != null && hasInterestingMethod(classContext.getJavaClass().getConstantPool(), methods)) {
             classContext.getJavaClass().accept(this);
         }
     }
@@ -118,8 +125,8 @@ public class InefficientToArray extends BytecodeScanningDetector implements Stat
             break;
 
         case SEEN_ANEWARRAY:
-            if (((seen == INVOKEVIRTUAL) || (seen == INVOKEINTERFACE)) && (getNameConstantOperand().equals("toArray"))
-                    && (getSigConstantOperand().equals("([Ljava/lang/Object;)[Ljava/lang/Object;"))) {
+            if (((seen == INVOKEVIRTUAL) || (seen == INVOKEINTERFACE)) && ("toArray".equals(getNameConstantOperand()))
+                    && ("([Ljava/lang/Object;)[Ljava/lang/Object;".equals(getSigConstantOperand()))) {
                 try {
                     String clsName = getDottedClassConstantOperand();
                     JavaClass cls = Repository.lookupClass(clsName);
diff --git a/InfiniteLoop.java b/InfiniteLoop.java
index 3053516bee113d2ded60dbddefad20184531500d..905f9d89d9f83a22aaea710f8769dabd8e5803c4 100644
--- a/InfiniteLoop.java
+++ b/InfiniteLoop.java
@@ -154,7 +154,7 @@ public class InfiniteLoop extends OpcodeStackDetector {
                 return false;
             }
             ForwardConditionalBranch that = (ForwardConditionalBranch) o;
-            return this.item0.equals(that.item0) && this.item1.equals(that.item1);
+            return this.item0.sameValue(that.item0) && this.item1.sameValue(that.item1);
         }
 
     }
@@ -507,7 +507,7 @@ public class InfiniteLoop extends OpcodeStackDetector {
                 bug.lowerPriorityALot();
             } else {
                 LocalVariableAnnotation lv = bug.getPrimaryLocalVariableAnnotation();
-                if (lv == null && getMethodName().equals("run")) {
+                if (lv == null && "run".equals(getMethodName())) {
                     bug.lowerPriority();
                 }
             }
diff --git a/InfiniteRecursiveLoop.java b/InfiniteRecursiveLoop.java
index 966d4d1541b073fa2bcd58923d4447c0c381f9a2..84cb4d16649d99a5eee45fb83f2fbcf7d5d9787a 100644
--- a/InfiniteRecursiveLoop.java
+++ b/InfiniteRecursiveLoop.java
@@ -93,8 +93,8 @@ public class InfiniteRecursiveLoop extends OpcodeStackDetector implements Statel
             System.out.println(getPC() + " : " + OPCODE_NAMES[seen]);
         }
 
-        if ((seen == INVOKEVIRTUAL || seen == INVOKEINTERFACE) && getNameConstantOperand().equals("add")
-                && getSigConstantOperand().equals("(Ljava/lang/Object;)Z") && stack.getStackDepth() >= 2) {
+        if ((seen == INVOKEVIRTUAL || seen == INVOKEINTERFACE) && "add".equals(getNameConstantOperand())
+                && "(Ljava/lang/Object;)Z".equals(getSigConstantOperand()) && stack.getStackDepth() >= 2) {
             OpcodeStack.Item it0 = stack.getStackItem(0);
             int r0 = it0.getRegisterNumber();
             OpcodeStack.Item it1 = stack.getStackItem(1);
@@ -109,8 +109,7 @@ public class InfiniteRecursiveLoop extends OpcodeStackDetector implements Statel
                 && getNameConstantOperand().equals(getMethodName())
                 && getSigConstantOperand().equals(getMethodSig())
                 && (seen == INVOKESTATIC) == getMethod().isStatic()
-                && (seen == INVOKESPECIAL) == (getMethod().isPrivate() && !getMethod().isStatic() || getMethodName().equals(
-                        "<init>"))) {
+                && (seen == INVOKESPECIAL) == (getMethod().isPrivate() && !getMethod().isStatic() || "<init>".equals(getMethodName()))) {
             Type arguments[] = getMethod().getArgumentTypes();
             // stack.getStackDepth() >= parameters
             int parameters = arguments.length;
@@ -128,7 +127,7 @@ public class InfiniteRecursiveLoop extends OpcodeStackDetector implements Statel
                 // Invocation of same method
                 // Now need to see if parameters are the same
                 int firstParameter = 0;
-                if (getMethodName().equals("<init>")) {
+                if ("<init>".equals(getMethodName())) {
                     firstParameter = 1;
                 }
 
@@ -148,7 +147,7 @@ public class InfiniteRecursiveLoop extends OpcodeStackDetector implements Statel
                     }
                 }
 
-                boolean sameMethod = seen == INVOKESTATIC || getNameConstantOperand().equals("<init>");
+                boolean sameMethod = seen == INVOKESTATIC || "<init>".equals(getNameConstantOperand());
                 if (!sameMethod) {
                     // Have to check if first parmeter is the same
                     // know there must be a this argument
@@ -221,8 +220,8 @@ public class InfiniteRecursiveLoop extends OpcodeStackDetector implements Statel
         case INVOKESPECIAL:
         case INVOKEINTERFACE:
         case INVOKESTATIC:
-            if (getNameConstantOperand().equals("print") || getNameConstantOperand().equals("println")
-                    || getNameConstantOperand().equals("log") || getNameConstantOperand().equals("toString")) {
+            if ("print".equals(getNameConstantOperand()) || "println".equals(getNameConstantOperand())
+                    || "log".equals(getNameConstantOperand()) || "toString".equals(getNameConstantOperand())) {
                 break;
             }
             seenStateChange = true;
diff --git a/InheritanceUnsafeGetResource.java b/InheritanceUnsafeGetResource.java
index 2eca2a7635070d8971fcf79bf290f96b215b1aca..f16bec7723509fee7c7d18a901483b40d3e660b8 100644
--- a/InheritanceUnsafeGetResource.java
+++ b/InheritanceUnsafeGetResource.java
@@ -95,8 +95,8 @@ public class InheritanceUnsafeGetResource extends BytecodeScanningDetector imple
             state = 1;
             break;
         case INVOKEVIRTUAL:
-            if (getClassConstantOperand().equals("java/lang/Class")
-                    && (getNameConstantOperand().equals("getResource") || getNameConstantOperand().equals("getResourceAsStream"))
+            if ("java/lang/Class".equals(getClassConstantOperand())
+                    && ("getResource".equals(getNameConstantOperand()) || "getResourceAsStream".equals(getNameConstantOperand()))
                     && sawGetClass + 10 >= getPC()) {
                 int priority = NORMAL_PRIORITY;
                 if (prevOpcode == LDC && stringConstant != null && stringConstant.length() > 0 && stringConstant.charAt(0) == '/') {
@@ -109,7 +109,7 @@ public class InheritanceUnsafeGetResource extends BytecodeScanningDetector imple
                 reportedForThisClass = true;
 
             } else if (state == 1 && !methodIsStatic && !classIsFinal && classIsVisibleToOtherPackages
-                    && getNameConstantOperand().equals("getClass") && getSigConstantOperand().equals("()Ljava/lang/Class;")) {
+                    && "getClass".equals(getNameConstantOperand()) && "()Ljava/lang/Class;".equals(getSigConstantOperand())) {
                 sawGetClass = getPC();
             }
             state = 0;
diff --git a/InitializationChain.java b/InitializationChain.java
index c42f48e8d2b45d8639555da36a7b223008482adb..ace6e89534a37c4b692cd528840706f718090850 100644
--- a/InitializationChain.java
+++ b/InitializationChain.java
@@ -24,6 +24,7 @@ import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.Map.Entry;
 import java.util.Set;
 import java.util.TreeMap;
 import java.util.TreeSet;
@@ -82,9 +83,9 @@ public class InitializationChain extends BytecodeScanningDetector {
         Method staticInitializer = null;
         for(Method m : obj.getMethods()) {
             String name = m.getName();
-            if (name.equals("<clinit>")) {
+            if ("<clinit>".equals(name)) {
                 staticInitializer = m;
-            } else if (name.equals("<init>")) {
+            } else if ("<init>".equals(name)) {
                 visitOrder.add(m);
             }
 
@@ -102,7 +103,7 @@ public class InitializationChain extends BytecodeScanningDetector {
         super.visit(obj);
         staticFieldsRead.put(getXMethod(), fieldsReadInThisConstructor);
         requires.remove(getDottedClassName());
-        if (getDottedClassName().equals("java.lang.System")) {
+        if ("java.lang.System".equals(getDottedClassName())) {
             requires.add("java.io.FileInputStream");
             requires.add("java.io.FileOutputStream");
             requires.add("java.io.BufferedInputStream");
@@ -133,7 +134,7 @@ public class InitializationChain extends BytecodeScanningDetector {
     public void sawOpcode(int seen) {
         InvocationInfo prev = lastInvocation;
         lastInvocation = null;
-        if (getMethodName().equals("<init>")) {
+        if ("<init>".equals(getMethodName())) {
             if (seen == GETSTATIC && getClassConstantOperand().equals(getClassName())) {
                 staticFieldsReadInAnyConstructor.add(getXFieldOperand());
                 fieldsReadInThisConstructor.add(getXFieldOperand());
@@ -141,7 +142,7 @@ public class InitializationChain extends BytecodeScanningDetector {
             return;
         }
 
-        if (seen == INVOKESPECIAL && getNameConstantOperand().equals("<init>") &&  getClassConstantOperand().equals(getClassName())) {
+        if (seen == INVOKESPECIAL && "<init>".equals(getNameConstantOperand()) &&  getClassConstantOperand().equals(getClassName())) {
 
             XMethod m = getXMethodOperand();
             Set<XField> read = staticFieldsRead.get(m);
@@ -218,13 +219,13 @@ public class InitializationChain extends BytecodeScanningDetector {
         compute();
         compute();
         compute();
-        Set<String> allClasses = classRequires.keySet();
 
-        for (String c : allClasses) {
+        for (Entry<String, Set<String>> entry : classRequires.entrySet()) {
+            String c = entry.getKey();
             if (DEBUG) {
                 System.out.println("Class " + c + " requires:");
             }
-            for (String needs : (classRequires.get(c))) {
+            for (String needs : entry.getValue()) {
                 if (DEBUG) {
                     System.out.println("  " + needs);
                 }
diff --git a/InitializeNonnullFieldsInConstructor.java b/InitializeNonnullFieldsInConstructor.java
index b72ad0d888b3bf575b63e46e17f25bfd71a2dc98..1958f18d62836f2f1bd46cb5cf7c61df45a3b9b4 100644
--- a/InitializeNonnullFieldsInConstructor.java
+++ b/InitializeNonnullFieldsInConstructor.java
@@ -89,7 +89,7 @@ public class InitializeNonnullFieldsInConstructor extends OpcodeStackDetector {
 
     @Override
     public void visit(Code code) {
-        boolean interesting = getMethodName().equals("<init>") || getMethodName().equals("<clinit>");
+        boolean interesting = "<init>".equals(getMethodName()) || "<clinit>".equals(getMethodName());
         if (!interesting) {
             return;
         }
@@ -133,7 +133,7 @@ public class InitializeNonnullFieldsInConstructor extends OpcodeStackDetector {
 
         switch (seen) {
         case Constants.INVOKESPECIAL:
-            if (!getMethod().isStatic() && getNameConstantOperand().equals("<init>") && isSelfOperation()) {
+            if (!getMethod().isStatic() && "<init>".equals(getNameConstantOperand()) && isSelfOperation()) {
                 OpcodeStack.Item invokedOn = stack.getItemMethodInvokedOn(this);
                 if (invokedOn.isInitialParameter() && invokedOn.getRegisterNumber() == 0) {
                     secondaryConstructor = true;
diff --git a/InstantiateStaticClass.java b/InstantiateStaticClass.java
index 3838553b4f0c47021e955715d370112c63602272..6c1d6fb020d521e8e673695136a7f89e6a135727 100644
--- a/InstantiateStaticClass.java
+++ b/InstantiateStaticClass.java
@@ -40,23 +40,23 @@ public class InstantiateStaticClass extends BytecodeScanningDetector {
     @Override
     public void sawOpcode(int seen) {
 
-        if ((seen == INVOKESPECIAL) && getNameConstantOperand().equals("<init>") && getSigConstantOperand().equals("()V")) {
+        if ((seen == INVOKESPECIAL) && "<init>".equals(getNameConstantOperand()) && "()V".equals(getSigConstantOperand())) {
             XClass xClass = getXClassOperand();
             if (xClass == null) {
                 return;
             }
             String clsName = getClassConstantOperand();
-            if (clsName.equals("java/lang/Object")) {
+            if ("java/lang/Object".equals(clsName)) {
                 return;
             }
 
             // ignore superclass synthesized ctor calls
-            if (getMethodName().equals("<init>") && (getPC() == 1)) {
+            if ("<init>".equals(getMethodName()) && (getPC() == 1)) {
                 return;
             }
 
             // ignore the typesafe enumerated constant pattern
-            if (getMethodName().equals("<clinit>") && (getClassName().equals(clsName))) {
+            if ("<clinit>".equals(getMethodName()) && (getClassName().equals(clsName))) {
                 return;
             }
 
@@ -78,7 +78,7 @@ public class InstantiateStaticClass extends BytecodeScanningDetector {
             return false;
         }
         String superClassName = superclassDescriptor.getClassName();
-        if (!superClassName.equals("java/lang/Object")) {
+        if (!"java/lang/Object".equals(superClassName)) {
             return false;
         }
         int staticCount = 0;
@@ -88,7 +88,7 @@ public class InstantiateStaticClass extends BytecodeScanningDetector {
             // !m.isSynthetic(): bug #1282: No warning should be generated if only static methods are synthetic
             if (m.isStatic() && !m.isSynthetic()) {
                 staticCount++;
-            } else if (!m.getName().equals("<init>") || !m.getSignature().equals("()V")) {
+            } else if (!"<init>".equals(m.getName()) || !"()V".equals(m.getSignature())) {
                 return false;
             }
         }
diff --git a/IteratorIdioms.java b/IteratorIdioms.java
index 60748d20295905824eb336d0c250aaac08efe53b..d02cf3f6b3b732bf37e26f1f467e27c774f37239 100644
--- a/IteratorIdioms.java
+++ b/IteratorIdioms.java
@@ -63,7 +63,7 @@ public class IteratorIdioms extends BytecodeScanningDetector implements Stateles
 
     @Override
     public void visit(Method method) {
-        if(method.isPublic() && method.getName().equals("next") && method.getArgumentTypes().length == 0){
+        if(method.isPublic() && "next".equals(method.getName()) && method.getArgumentTypes().length == 0){
             shouldVisitCode = true;
             super.visit(method);
         } else {
@@ -88,7 +88,7 @@ public class IteratorIdioms extends BytecodeScanningDetector implements Stateles
 
     @Override
     public void sawOpcode(int seen) {
-        if (seen == NEW && getClassConstantOperand().equals("java/util/NoSuchElementException")) {
+        if (seen == NEW && "java/util/NoSuchElementException".equals(getClassConstantOperand())) {
             sawNoSuchElement = true;
         } else if (seen == INVOKESPECIAL || seen == INVOKEVIRTUAL || seen == INVOKEINTERFACE) {
             sawCall = true;
diff --git a/LazyInit.java b/LazyInit.java
index 63d9fdb10a15429a67e2b4c4da6911b69fde8c18..6c6a787ff481b6009393a27ca364ef02a0eb5265 100644
--- a/LazyInit.java
+++ b/LazyInit.java
@@ -122,7 +122,7 @@ public final class LazyInit extends ByteCodePatternDetector implements Stateless
 
     @Override
     public boolean prescreen(Method method, ClassContext classContext) {
-        if (method.getName().equals("<clinit>")) {
+        if ("<clinit>".equals(method.getName())) {
             return false;
         }
 
@@ -197,7 +197,7 @@ public final class LazyInit extends ByteCodePatternDetector implements Stateless
         }
 
         // Strings are (mostly) safe to pass by data race in 1.5
-        if (signature.equals("Ljava/lang/String;")) {
+        if ("Ljava/lang/String;".equals(signature)) {
             return;
         }
 
@@ -218,7 +218,7 @@ public final class LazyInit extends ByteCodePatternDetector implements Stateless
                 if (name.startsWith("java/awt") || name.startsWith("javax/swing")) {
                     return;
                 }
-                if (name.equals("java/lang/Object")) {
+                if ("java/lang/Object".equals(name)) {
                     break;
                 }
                 fieldType = fieldClass.getSuperclassDescriptor();
diff --git a/LoadOfKnownNullValue.java b/LoadOfKnownNullValue.java
index 38c7df2a0525ed66485b8f2e94c0d217aeae0884..baf6b4d12f2179b7f978506c4ec2532bb899b1ff 100644
--- a/LoadOfKnownNullValue.java
+++ b/LoadOfKnownNullValue.java
@@ -290,10 +290,10 @@ public class LoadOfKnownNullValue implements Detector {
         INVOKEVIRTUAL invokeVirtual = (INVOKEVIRTUAL) nextNextNextInstruction;
         String methodName = invokeVirtual.getMethodName(classContext.getConstantPoolGen());
         String methodSig = invokeVirtual.getSignature(classContext.getConstantPoolGen());
-        if (!methodName.equals("close")) {
+        if (!"close".equals(methodName)) {
             return false;
         }
-        if (!methodSig.equals("()V")) {
+        if (!"()V".equals(methodSig)) {
             return false;
         }
         InstructionHandle nextNextNextNextHandle = nextNextNextHandle.getNext(); // after
diff --git a/LostLoggerDueToWeakReference.java b/LostLoggerDueToWeakReference.java
index 670dded37c2556ae266dec77276341528954687c..e51548419540bb20e7dced5b185e2326d7d042f1 100644
--- a/LostLoggerDueToWeakReference.java
+++ b/LostLoggerDueToWeakReference.java
@@ -19,7 +19,9 @@
 
 package edu.umd.cs.findbugs.detect;
 
+import java.util.Arrays;
 import java.util.HashSet;
+import java.util.List;
 
 import org.apache.bcel.classfile.Code;
 
@@ -27,7 +29,9 @@ import edu.umd.cs.findbugs.BugAccumulator;
 import edu.umd.cs.findbugs.BugInstance;
 import edu.umd.cs.findbugs.BugReporter;
 import edu.umd.cs.findbugs.OpcodeStack;
+import edu.umd.cs.findbugs.ba.ClassContext;
 import edu.umd.cs.findbugs.bcel.OpcodeStackDetector;
+import edu.umd.cs.findbugs.classfile.MethodDescriptor;
 import edu.umd.cs.findbugs.visitclass.PreorderVisitor;
 
 /**
@@ -40,6 +44,9 @@ import edu.umd.cs.findbugs.visitclass.PreorderVisitor;
  * that memory, which means that the logger configuration is lost.
  */
 public class LostLoggerDueToWeakReference extends OpcodeStackDetector {
+    private static final List<MethodDescriptor> methods = Arrays.asList(
+            new MethodDescriptor("java/util/logging/Logger", "getLogger", "(Ljava/lang/String;)Ljava/util/logging/Logger;", true),
+            new MethodDescriptor("java/util/logging/Logger", "getLogger", "(Ljava/lang/String;Ljava/lang/String;)Ljava/util/logging/Logger;", true));
 
     //    final BugReporter bugReporter;
 
@@ -57,6 +64,13 @@ public class LostLoggerDueToWeakReference extends OpcodeStackDetector {
     }
 
     @Override
+    public void visitClassContext(ClassContext classContext) {
+        if(hasInterestingMethod(classContext.getJavaClass().getConstantPool(), methods)) {
+            super.visitClassContext(classContext);
+        }
+    }
+
+    @Override
     public void visit(Code code) {
         if (getMethodSig().indexOf("Logger") == -1) {
             sawGetLogger = -1;
@@ -89,7 +103,7 @@ public class LostLoggerDueToWeakReference extends OpcodeStackDetector {
         }
         switch (seen) {
         case INVOKESTATIC:
-            if (getClassConstantOperand().equals("java/util/logging/Logger") && getNameConstantOperand().equals("getLogger")) {
+            if ("java/util/logging/Logger".equals(getClassConstantOperand()) && "getLogger".equals(getNameConstantOperand())) {
                 OpcodeStack.Item item = stack.getStackItem(0);
                 if (!"".equals(item.getConstant())) {
                     sawGetLogger = getPC();
@@ -99,10 +113,10 @@ public class LostLoggerDueToWeakReference extends OpcodeStackDetector {
             checkForImport();
             break;
         case INVOKEVIRTUAL:
-            if (getClassConstantOperand().equals("java/util/logging/Logger")
+            if ("java/util/logging/Logger".equals(getClassConstantOperand())
                     && namesOfSetterMethods.contains(getNameConstantOperand())) {
                 int priority = HIGH_PRIORITY;
-                if (getMethod().isStatic() && getMethodName().equals("main") && getMethodSig().equals("([Ljava/lang/String;)V")) {
+                if (getMethod().isStatic() && "main".equals(getMethodName()) && "([Ljava/lang/String;)V".equals(getMethodSig())) {
                     priority = NORMAL_PRIORITY;
                 }
 
diff --git a/MethodReturnCheck.java b/MethodReturnCheck.java
index 13344113aeb20336fb62c09312b4305acd657cf9..95a78346664ee1ee1415bf29ae746bd93f607f59 100644
--- a/MethodReturnCheck.java
+++ b/MethodReturnCheck.java
@@ -22,6 +22,7 @@ import java.util.BitSet;
 
 import org.apache.bcel.Constants;
 import org.apache.bcel.classfile.Code;
+import org.apache.bcel.generic.Type;
 
 import edu.umd.cs.findbugs.BugAccumulator;
 import edu.umd.cs.findbugs.BugInstance;
@@ -38,7 +39,11 @@ import edu.umd.cs.findbugs.ba.CheckReturnValueAnnotation;
 import edu.umd.cs.findbugs.ba.ClassContext;
 import edu.umd.cs.findbugs.ba.XFactory;
 import edu.umd.cs.findbugs.ba.XMethod;
+import edu.umd.cs.findbugs.ba.ch.Subtypes2;
 import edu.umd.cs.findbugs.bcel.OpcodeStackDetector;
+import edu.umd.cs.findbugs.classfile.Global;
+import edu.umd.cs.findbugs.detect.FindNoSideEffectMethods.NoSideEffectMethodsDatabase;
+import edu.umd.cs.findbugs.util.ClassName;
 import edu.umd.cs.findbugs.visitclass.PreorderVisitor;
 
 /**
@@ -75,8 +80,13 @@ public class MethodReturnCheck extends OpcodeStackDetector implements UseAnnotat
 
     private int callPC;
 
+    private final NoSideEffectMethodsDatabase noSideEffectMethods;
+
+    private boolean sawExcludedNSECall;
+
     public MethodReturnCheck(BugReporter bugReporter) {
         this.bugAccumulator = new BugAccumulator(bugReporter);
+        this.noSideEffectMethods = Global.getAnalysisCache().getDatabase(NoSideEffectMethodsDatabase.class);
     }
 
     @Override
@@ -87,6 +97,14 @@ public class MethodReturnCheck extends OpcodeStackDetector implements UseAnnotat
 
     @Override
     public void visitAfter(Code code) {
+        if(bugAccumulator.getLastBugLocation() == null && !sawExcludedNSECall && noSideEffectMethods.useless(getMethodDescriptor())) {
+            // Do not report UC_USELESS_VOID_METHOD if something was already reported inside the current method
+            // it's likely that UC_USELESS_VOID_METHOD is just the consequence of the previous report
+            bugAccumulator.accumulateBug(new BugInstance(this, "UC_USELESS_VOID_METHOD",
+                    code.getCode().length > 40 ? HIGH_PRIORITY : code.getCode().length > 15 ? NORMAL_PRIORITY : LOW_PRIORITY)
+            .addClassAndMethod(getMethodDescriptor()), this);
+        }
+        sawExcludedNSECall = false;
         bugAccumulator.reportAccumulatedBugs();
     }
 
@@ -112,15 +130,15 @@ public class MethodReturnCheck extends OpcodeStackDetector implements UseAnnotat
 
 
         if (m.isStatic() || !m.isResolved()) {
-            if (name.equals("compare") && m.getClassName().startsWith("com.google.common.primitives.")) {
+            if ("compare".equals(name) && m.getClassName().startsWith("com.google.common.primitives.")) {
                 return true;
             }
         }
         if (!m.isStatic() || !m.isResolved()) {
-            if (name.equals("compareTo") && m.getSignature().equals("(Ljava/lang/Object;)I")) {
+            if ("compareTo".equals(name) && "(Ljava/lang/Object;)I".equals(m.getSignature())) {
                 return true;
             }
-            if (name.equals("compare") && m.getSignature().equals("(Ljava/lang/Object;Ljava/lang/Object;)I")) {
+            if ("compare".equals(name) && "(Ljava/lang/Object;Ljava/lang/Object;)I".equals(m.getSignature())) {
                 return true;
             }
         }
@@ -157,10 +175,10 @@ public class MethodReturnCheck extends OpcodeStackDetector implements UseAnnotat
             break;
         }
 
-        checkForInitWithoutCopyOnStack: if (seen == INVOKESPECIAL && getNameConstantOperand().equals("<init>")) {
+        checkForInitWithoutCopyOnStack: if (seen == INVOKESPECIAL && "<init>".equals(getNameConstantOperand())) {
             int arguments = PreorderVisitor.getNumberArguments(getSigConstantOperand());
             OpcodeStack.Item invokedOn = stack.getStackItem(arguments);
-            if (invokedOn.isNewlyAllocated() && (!getMethodName().equals("<init>") || invokedOn.getRegisterNumber() != 0)) {
+            if (invokedOn.isNewlyAllocated() && (!"<init>".equals(getMethodName()) || invokedOn.getRegisterNumber() != 0)) {
 
                 for (int i = arguments + 1; i < stack.getStackDepth(); i++) {
                     OpcodeStack.Item item = stack.getStackItem(i);
@@ -220,10 +238,39 @@ public class MethodReturnCheck extends OpcodeStackDetector implements UseAnnotat
         {
             CheckReturnValueAnnotation annotation = checkReturnAnnotationDatabase.getResolvedAnnotation(callSeen, false);
             if (annotation == null) {
-                XFactory xFactory = AnalysisContext.currentXFactory();
-
-                if (xFactory.isFunctionshatMightBeMistakenForProcedures(callSeen.getMethodDescriptor())) {
-                    annotation = CheckReturnValueAnnotation.CHECK_RETURN_VALUE_INFERRED;
+                if (noSideEffectMethods.excluded(callSeen.getMethodDescriptor())) {
+                    sawExcludedNSECall = true;
+                }
+                if (noSideEffectMethods.hasNoSideEffect(callSeen.getMethodDescriptor())) {
+                    int priority = NORMAL_PRIORITY;
+                    Type callReturnType = Type.getReturnType(callSeen.getMethodDescriptor().getSignature());
+                    Type methodReturnType = Type.getReturnType(getMethodSig());
+                    if(callReturnType.equals(methodReturnType) && callReturnType != Type.BOOLEAN && callReturnType != Type.VOID) {
+                        priority = HIGH_PRIORITY;
+                    } else {
+                        String callReturnClass = callSeen.getName().equals("<init>") ?
+                                callSeen.getClassDescriptor().getClassName() :
+                                    ClassName.fromFieldSignature(callReturnType.getSignature());
+
+                                String methodReturnClass = ClassName.fromFieldSignature(methodReturnType.getSignature());
+                                if(callReturnClass != null && methodReturnClass != null &&
+                                        Subtypes2.instanceOf(ClassName.toDottedClassName(callReturnClass), ClassName.toDottedClassName(methodReturnClass))) {
+                                    priority = HIGH_PRIORITY;
+                                }
+                    }
+                    int catchSize = getSizeOfSurroundingTryBlock(getPC());
+                    if(catchSize <= 2) {
+                        priority++;
+                    }
+                    BugInstance warning = new BugInstance(this, "RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT", priority)
+                    .addClassAndMethod(this).addMethod(callSeen).describe(MethodAnnotation.METHOD_CALLED);
+                    bugAccumulator.accumulateBug(warning, SourceLineAnnotation.fromVisitedInstruction(this, callPC));
+                } else {
+                    XFactory xFactory = AnalysisContext.currentXFactory();
+
+                    if (xFactory.isFunctionshatMightBeMistakenForProcedures(callSeen.getMethodDescriptor())) {
+                        annotation = CheckReturnValueAnnotation.CHECK_RETURN_VALUE_INFERRED;
+                    }
                 }
             }
             if (annotation != null && annotation.getPriority() <= LOW_PRIORITY) {
@@ -246,11 +293,11 @@ public class MethodReturnCheck extends OpcodeStackDetector implements UseAnnotat
                 if (callSeen.isPrivate()) {
                     priority++;
                 }
-                if (callSeen.getName().equals("clone") || callSeen.getName().startsWith("get")) {
+                if ("clone".equals(callSeen.getName()) || callSeen.getName().startsWith("get")) {
                     priority++;
                 }
                 String pattern = annotation.getPattern();
-                if (callSeen.getName().equals("<init>")
+                if ("<init>".equals(callSeen.getName())
                         && (callSeen.getClassName().endsWith("Exception") || callSeen.getClassName().endsWith("Error"))) {
                     pattern = "RV_EXCEPTION_NOT_THROWN";
                 }
diff --git a/MethodReturnValueStreamFactory.java b/MethodReturnValueStreamFactory.java
index f2bde05d7eccf10708b01839bc4d383d1a49ab91..4eb941704378f92b6f9c0a025a891b2d9507d32d 100644
--- a/MethodReturnValueStreamFactory.java
+++ b/MethodReturnValueStreamFactory.java
@@ -127,7 +127,7 @@ public class MethodReturnValueStreamFactory implements StreamFactory {
             }
 
             String streamClass = type.getClassName();
-            if (streamClass.equals("java.sql.CallableStatement")) {
+            if ("java.sql.CallableStatement".equals(streamClass)) {
                 streamClass = "java.sql.PreparedStatement";
             }
             Stream result = new Stream(location, streamClass, streamClass).setIgnoreImplicitExceptions(true).setIsOpenOnCreation(
diff --git a/MultithreadedInstanceAccess.java b/MultithreadedInstanceAccess.java
index 6910717c9590a52fa68fa23e92696c73e3371060..14609183e581f7ba0b5609f036bb658913a941a2 100644
--- a/MultithreadedInstanceAccess.java
+++ b/MultithreadedInstanceAccess.java
@@ -129,7 +129,7 @@ public class MultithreadedInstanceAccess extends OpcodeStackDetector {
 
     @Override
     public boolean shouldVisitCode(Code code) {
-        return !getMethodName().equals("<init>") && !getMethodName().equals("init");
+        return !"<init>".equals(getMethodName()) && !"init".equals(getMethodName());
 
     }
 
diff --git a/MutableEnum.java b/MutableEnum.java
new file mode 100644
index 0000000000000000000000000000000000000000..7bfd5ad80df73ca050b35a2c8509a63e8904a9fb
--- /dev/null
+++ b/MutableEnum.java
@@ -0,0 +1,92 @@
+/*
+ * FindBugs - Find Bugs in Java programs
+ * Copyright (C) 2003-2008 University of Maryland
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+package edu.umd.cs.findbugs.detect;
+
+import org.apache.bcel.classfile.Code;
+
+import edu.umd.cs.findbugs.BugInstance;
+import edu.umd.cs.findbugs.BugReporter;
+import edu.umd.cs.findbugs.OpcodeStack.Item;
+import edu.umd.cs.findbugs.ba.ClassContext;
+import edu.umd.cs.findbugs.ba.XField;
+import edu.umd.cs.findbugs.bcel.OpcodeStackDetector;
+
+/**
+ * @author Tagir Valeev
+ */
+public class MutableEnum extends OpcodeStackDetector {
+
+    private final BugReporter reporter;
+    private boolean skip;
+
+    public MutableEnum(BugReporter reporter) {
+        this.reporter = reporter;
+    }
+
+    @Override
+    public void visitClassContext(ClassContext classContext) {
+        if(!classContext.getJavaClass().isEnum() || !classContext.getJavaClass().isPublic()) {
+            return;
+        }
+        boolean hasInterestingField = false;
+        for(XField field : classContext.getXClass().getXFields()) {
+            if(!field.isStatic() && !field.isFinal() && !field.isSynthetic()) {
+                if(field.isPublic()) {
+                    reporter.reportBug(new BugInstance("ME_MUTABLE_ENUM_FIELD", NORMAL_PRIORITY).addClass(classContext.getJavaClass())
+                            .addField(field));
+                } else {
+                    hasInterestingField = true;
+                }
+            }
+        }
+        if(hasInterestingField) {
+            super.visitClassContext(classContext);
+        }
+    }
+
+    @Override
+    public boolean shouldVisitCode(Code obj) {
+        skip = false;
+        if(getXMethod().isPublic() && getNumberMethodArguments() > 0) {
+            return true;
+        }
+        return false;
+    }
+
+    @Override
+    public void sawOpcode(int seen) {
+        if(skip) {
+            return;
+        }
+        if(isBranch(seen) || seen == ATHROW || isReturn(seen)) {
+            skip = true;
+        }
+        if(seen == PUTFIELD) {
+            XField xField = getXFieldOperand();
+            if(xField != null && xField.getClassDescriptor().getClassName().equals(getClassName())) {
+                Item val = getStack().getStackItem(0);
+                if(val.isInitialParameter()) {
+                    reporter.reportBug(new BugInstance("ME_ENUM_FIELD_SETTER", NORMAL_PRIORITY).addClassAndMethod(this).addField(xField)
+                            .addSourceLine(this));
+                }
+            }
+        }
+    }
+}
diff --git a/MutableStaticFields.java b/MutableStaticFields.java
index ce6ba8a6923ae64d02dcca97cc12333da03ffbc0..29c6df24f8ba38ea855bd29d9765e95bc98cf86d 100644
--- a/MutableStaticFields.java
+++ b/MutableStaticFields.java
@@ -19,6 +19,8 @@
 
 package edu.umd.cs.findbugs.detect;
 
+import java.util.Arrays;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.LinkedList;
@@ -37,10 +39,37 @@ import edu.umd.cs.findbugs.SourceLineAnnotation;
 import edu.umd.cs.findbugs.ba.AnalysisContext;
 import edu.umd.cs.findbugs.ba.XClass;
 import edu.umd.cs.findbugs.ba.XField;
+import edu.umd.cs.findbugs.ba.XMethod;
 import edu.umd.cs.findbugs.classfile.CheckedAnalysisException;
+import edu.umd.cs.findbugs.classfile.ClassDescriptor;
 import edu.umd.cs.findbugs.classfile.Global;
 
 public class MutableStaticFields extends BytecodeScanningDetector {
+    private static final Set<String> COLLECTION_SUPERCLASSES = new HashSet<>(Arrays.asList("java/util/Collection",
+            "java/util/List", "java/util/Set", "java/util/Map", "java/util/AbstractList", "java/util/SortedSet",
+            "java/util/SortedMap", "java/util/NavigableMap", "java/util/Dictionary"));
+
+    private static final Set<String> MUTABLE_COLLECTION_CLASSES = new HashSet<>(Arrays.asList("java/util/ArrayList",
+            "java/util/HashSet", "java/util/HashMap", "java/util/Hashtable", "java/util/IdentityHashMap",
+            "java/util/LinkedHashSet", "java/util/LinkedList", "java/util/LinkedHashMap", "java/util/TreeSet",
+            "java/util/TreeMap", "java/util/Properties"));
+
+    private static enum AllowedParameter {
+        NONE, EMPTY_ARRAY
+    }
+
+    private static final Map<String, Map<String, AllowedParameter>> MUTABLE_COLLECTION_METHODS = new HashMap<>();
+    static {
+        MUTABLE_COLLECTION_METHODS.put("java/util/Arrays", Collections.singletonMap("asList", AllowedParameter.EMPTY_ARRAY));
+        Map<String, AllowedParameter> listsMap = new HashMap<>();
+        listsMap.put("newArrayList", AllowedParameter.NONE);
+        listsMap.put("newLinkedList", AllowedParameter.NONE);
+        MUTABLE_COLLECTION_METHODS.put("com/google/common/collect/Lists", listsMap);
+        Map<String, AllowedParameter> setsMap = new HashMap<>();
+        setsMap.put("newHashSet", AllowedParameter.NONE);
+        setsMap.put("newTreeSet", AllowedParameter.NONE);
+        MUTABLE_COLLECTION_METHODS.put("com/google/common/collect/Sets", setsMap);
+    }
 
     static String extractPackage(String c) {
         int i = c.lastIndexOf('/');
@@ -61,6 +90,8 @@ public class MutableStaticFields extends BytecodeScanningDetector {
 
     boolean publicClass;
 
+    boolean mutableCollectionJustCreated = false;
+
     boolean zeroOnTOS;
 
     boolean emptyArrayOnTOS;
@@ -73,12 +104,16 @@ public class MutableStaticFields extends BytecodeScanningDetector {
 
     Set<XField> unsafeValue = new HashSet<XField>();
 
+    Set<XField> mutableCollection = new HashSet<XField>();
+
     Set<XField> notFinal = new HashSet<XField>();
 
     Set<XField> outsidePackage = new HashSet<XField>();
+
     Set<XField> needsRefactoringToBeFinal = new HashSet<XField>();
 
     Set<XField> writtenInMethod = new HashSet<XField>();
+
     Set<XField> writtenTwiceInMethod = new HashSet<XField>();
 
     Map<XField, SourceLineAnnotation> firstFieldUse = new HashMap<XField, SourceLineAnnotation>();
@@ -142,7 +177,7 @@ public class MutableStaticFields extends BytecodeScanningDetector {
                 break;
             }
 
-            boolean samePackage = packageName.equals(extractPackage(getClassConstantOperand()));
+            boolean samePackage = packageName.equals(extractPackage(xField.getFieldDescriptor().getSlashedClassName()));
             boolean initOnly = seen == GETSTATIC || getClassName().equals(getClassConstantOperand()) && inStaticInitializer;
             boolean safeValue = seen == GETSTATIC || emptyArrayOnTOS
                     || AnalysisContext.currentXFactory().isEmptyArrayField(xField) || !mutableSignature(getSigConstantOperand());
@@ -151,6 +186,9 @@ public class MutableStaticFields extends BytecodeScanningDetector {
                 readAnywhere.add(xField);
             }
             if (seen == PUTSTATIC) {
+                if (xField.isFinal() && mutableCollectionJustCreated) {
+                    mutableCollection.add(xField);
+                }
                 if (!writtenInMethod.add(xField)) {
                     writtenTwiceInMethod.add(xField);
                 }
@@ -187,9 +225,64 @@ public class MutableStaticFields extends BytecodeScanningDetector {
             zeroOnTOS = true;
             emptyArrayOnTOS = false;
             return;
+        case INVOKESPECIAL:
+            if (inStaticInitializer && "<init>".equals(getMethodDescriptorOperand().getName())) {
+                ClassDescriptor classDescriptor = getClassDescriptorOperand();
+                if (MUTABLE_COLLECTION_CLASSES.contains(classDescriptor.getClassName())) {
+                    mutableCollectionJustCreated = true;
+                    return;
+                }
+                try {
+                    /* Check whether it's statically initialized anonymous class like this:
+                     * public static final Map map = new HashMap() {{put("a", "b");}}
+                     * We do not check whether all modification methods are overridden or not for simplicity:
+                     * Skip if there's at least one method is present
+                     */
+                    XClass xClass = classDescriptor.getXClass();
+                    ClassDescriptor superclassDescriptor = xClass.getSuperclassDescriptor();
+                    if (superclassDescriptor != null
+                            && MUTABLE_COLLECTION_CLASSES.contains(superclassDescriptor.getClassName())) {
+                        mutableCollectionJustCreated = true;
+                        for (XMethod xMethod : xClass.getXMethods()) {
+                            if (xMethod != null && !"<init>".equals(xMethod.getName()) && !"<clinit>".equals(xMethod.getName())) {
+                                mutableCollectionJustCreated = false;
+                                break;
+                            }
+                        }
+                        return;
+                    }
+                } catch (CheckedAnalysisException e) {
+                    // ignore
+                }
+            }
+            break;
+        case INVOKESTATIC:
+            if (inStaticInitializer) {
+                Map<String, AllowedParameter> methods = MUTABLE_COLLECTION_METHODS.get(getMethodDescriptorOperand()
+                        .getSlashedClassName());
+                if (methods != null) {
+                    String name = getMethodDescriptorOperand().getName();
+                    AllowedParameter allowedParameter = methods.get(name);
+                    if (allowedParameter == AllowedParameter.NONE
+                            || (allowedParameter == AllowedParameter.EMPTY_ARRAY && !emptyArrayOnTOS)) {
+                        mutableCollectionJustCreated = true;
+                        return;
+                    }
+                }
+            }
+            break;
         }
         zeroOnTOS = false;
         emptyArrayOnTOS = false;
+        mutableCollectionJustCreated = false;
+    }
+
+    private boolean isCollection(String signature) {
+        if (signature.startsWith("L") && signature.endsWith(";")) {
+            String fieldClass = signature.substring(1, signature.length() - 1);
+            return COLLECTION_SUPERCLASSES.contains(fieldClass) || MUTABLE_COLLECTION_CLASSES.contains(fieldClass);
+        }
+        return false;
     }
 
     private boolean interesting(XField f) {
@@ -199,9 +292,11 @@ public class MutableStaticFields extends BytecodeScanningDetector {
         if (!f.isStatic() || f.isSynthetic() || f.isVolatile()) {
             return false;
         }
-        boolean isHashtable = f.getSignature().equals("Ljava/util/Hashtable;");
+        if (!f.isFinal()) {
+            return true;
+        }
         boolean isArray = f.getSignature().charAt(0) == '[';
-        if (f.isFinal() && !(isArray || isHashtable)) {
+        if (!(isArray || isCollection(f.getSignature()))) {
             return false;
         }
         return true;
@@ -227,10 +322,9 @@ public class MutableStaticFields extends BytecodeScanningDetector {
             return;
         }
 
-        boolean isHashtable = getFieldSig().equals("Ljava/util/Hashtable;");
         boolean isArray = getFieldSig().charAt(0) == '[';
 
-        if (isFinal && !(isHashtable || isArray)) {
+        if (isFinal && !(isArray || isCollection(getFieldSig()))) {
             return;
         }
         if (isEclipseNLS && getFieldSig().equals("Ljava/lang/String;")) {
@@ -254,6 +348,7 @@ public class MutableStaticFields extends BytecodeScanningDetector {
             boolean couldBeFinal = !isFinal && !notFinal.contains(f);
             //            boolean isPublic = f.isPublic();
             boolean couldBePackage = !outsidePackage.contains(f);
+            boolean isMutableCollection = mutableCollection.contains(f);
             boolean movedOutofInterface = false;
 
             try {
@@ -271,7 +366,7 @@ public class MutableStaticFields extends BytecodeScanningDetector {
 
             String bugType;
             int priority = NORMAL_PRIORITY;
-            if (isFinal && !isHashtable && !isArray) {
+            if (isFinal && !isHashtable && !isArray && !isMutableCollection) {
                 continue;
             } else if (movedOutofInterface) {
                 bugType = "MS_OOI_PKGPROTECT";
@@ -286,7 +381,7 @@ public class MutableStaticFields extends BytecodeScanningDetector {
                     priority = HIGH_PRIORITY;
                 }
             } else if (couldBePackage) {
-                bugType = "MS_PKGPROTECT";
+                bugType = isMutableCollection ? "MS_MUTABLE_COLLECTION_PKGPROTECT" : "MS_PKGPROTECT";
             } else if (isHashtable) {
                 bugType = "MS_MUTABLE_HASHTABLE";
                 if (!isFinal) {
@@ -297,6 +392,9 @@ public class MutableStaticFields extends BytecodeScanningDetector {
                 if (fieldSig.indexOf('L') >= 0 || !isFinal) {
                     priority = HIGH_PRIORITY;
                 }
+            } else if (isMutableCollection) {
+                bugType = "MS_MUTABLE_COLLECTION";
+                priority = HIGH_PRIORITY;
             } else if (!isFinal) {
                 bugType = "MS_CANNOT_BE_FINAL";
             } else {
diff --git a/Naming.java b/Naming.java
index 86ac893d3a3972a5c40e16cdb07d924e5b5d65cd..58fcd77f338449b51e24f8f433a891b6f95d1cd7 100644
--- a/Naming.java
+++ b/Naming.java
@@ -146,7 +146,7 @@ public class Naming extends PreorderVisitor implements Detector {
         if (m.isStatic()) {
             return false;
         }
-        if (m.getName().equals("<init>") || m.getName().equals("<clinit>")) {
+        if ("<init>".equals(m.getName()) || "<clinit>".equals(m.getName())) {
             return false;
         }
         for (XMethod m2 : others) {
@@ -323,7 +323,7 @@ public class Naming extends PreorderVisitor implements Detector {
         }
 
         String superClassName = obj.getSuperclassName();
-        if (!name.equals("java.lang.Object")) {
+        if (!"java.lang.Object".equals(name)) {
             if (sameSimpleName(superClassName, name)) {
                 bugReporter.reportBug(new BugInstance(this, "NM_SAME_SIMPLE_NAME_AS_SUPERCLASS", HIGH_PRIORITY).addClass(name)
                         .addClass(superClassName));
@@ -339,7 +339,7 @@ public class Naming extends PreorderVisitor implements Detector {
             return;
         }
 
-        if (superClassName.equals("java.lang.Object") && !visited.contains(superClassName)) {
+        if ("java.lang.Object".equals(superClassName) && !visited.contains(superClassName)) {
             try {
                 visitJavaClass(obj.getSuperClass());
             } catch (ClassNotFoundException e) {
@@ -442,7 +442,7 @@ public class Naming extends PreorderVisitor implements Detector {
 
         if (isEclipseNLS) {
             int flags = obj.getAccessFlags();
-            if ((flags & ACC_STATIC) != 0 && ((flags & ACC_PUBLIC) != 0) && getFieldSig().equals("Ljava/lang/String;")) {
+            if ((flags & ACC_STATIC) != 0 && ((flags & ACC_PUBLIC) != 0) && "Ljava/lang/String;".equals(getFieldSig())) {
                 // ignore "public statis String InstallIUCommandTooltip;"
                 // messages from Eclipse NLS bundles
                 return;
@@ -519,11 +519,11 @@ public class Naming extends PreorderVisitor implements Detector {
         if (mName.length() == 1) {
             return;
         }
-        if (mName.equals("isRequestedSessionIdFromURL") || mName.equals("isRequestedSessionIdFromUrl")) {
+        if ("isRequestedSessionIdFromURL".equals(mName) || "isRequestedSessionIdFromUrl".equals(mName)) {
             return;
         }
         String sig = getMethodSig();
-        if (mName.equals(baseClassName) && sig.equals("()V")) {
+        if (mName.equals(baseClassName) && "()V".equals(sig)) {
             Code code = obj.getCode();
             Method realVoidConstructor = findVoidConstructor(getThisClass());
             if (code != null && !markedAsNotUsable(obj)) {
@@ -544,7 +544,7 @@ public class Naming extends PreorderVisitor implements Detector {
                         instanceMembers = true;
                     }
                 }
-                if (!codeDoesSomething(code) && !instanceMembers && getSuperclassName().equals("java/lang/Object")) {
+                if (!codeDoesSomething(code) && !instanceMembers && "java/lang/Object".equals(getSuperclassName())) {
                     priority += 2;
                 }
                 if (hasBadMethodNames) {
@@ -574,23 +574,23 @@ public class Naming extends PreorderVisitor implements Detector {
             return;
         }
 
-        if (mName.equals("equal") && sig.equals("(Ljava/lang/Object;)Z")) {
+        if ("equal".equals(mName) && "(Ljava/lang/Object;)Z".equals(sig)) {
             bugReporter.reportBug(new BugInstance(this, "NM_BAD_EQUAL", HIGH_PRIORITY).addClassAndMethod(this)
                     .lowerPriorityIfDeprecated());
             return;
         }
-        if (mName.equals("hashcode") && sig.equals("()I")) {
+        if ("hashcode".equals(mName) && "()I".equals(sig)) {
             bugReporter.reportBug(new BugInstance(this, "NM_LCASE_HASHCODE", HIGH_PRIORITY).addClassAndMethod(this)
                     .lowerPriorityIfDeprecated());
             return;
         }
-        if (mName.equals("tostring") && sig.equals("()Ljava/lang/String;")) {
+        if ("tostring".equals(mName) && "()Ljava/lang/String;".equals(sig)) {
             bugReporter.reportBug(new BugInstance(this, "NM_LCASE_TOSTRING", HIGH_PRIORITY).addClassAndMethod(this)
                     .lowerPriorityIfDeprecated());
             return;
         }
 
-        if (obj.isPrivate() || obj.isStatic() || mName.equals("<init>")) {
+        if (obj.isPrivate() || obj.isStatic() || "<init>".equals(mName)) {
             return;
         }
 
@@ -614,7 +614,7 @@ public class Naming extends PreorderVisitor implements Detector {
         if (outerClassSignature == null) {
             outerClassSignature = "";
         }
-        return m.getName().equals("<init>") && m.getSignature().equals("(" + outerClassSignature + ")V");
+        return "<init>".equals(m.getName()) && m.getSignature().equals("(" + outerClassSignature + ")V");
     }
 
     private boolean badMethodName(String mName) {
diff --git a/NoiseNullDeref.java b/NoiseNullDeref.java
index 2db12d3620955a57a9e41225bc5517f92b41e080..5ba8c37a26da20b4d59dc782204dada4badec5b8 100644
--- a/NoiseNullDeref.java
+++ b/NoiseNullDeref.java
@@ -274,7 +274,7 @@ public class NoiseNullDeref implements Detector, UseAnnotationDatabase, NullDere
             cause = MethodAnnotation.fromXMethod(invokedMethod);
             cause.setDescription(MethodAnnotation.METHOD_CALLED);
 
-            if (iins.getMethodName(cpg).equals("close") && iins.getSignature(cpg).equals("()V")) {
+            if ("close".equals(iins.getMethodName(cpg)) && "()V".equals(iins.getSignature(cpg))) {
                 propertySet.addProperty(NullDerefProperty.CLOSING_NULL);
             }
         } else if (ins instanceof FieldInstruction) {
diff --git a/NoteAnnotationRetention.java b/NoteAnnotationRetention.java
index 46f003ff6b7eeac78f40879ab6be6568e03d9979..7034376ad3b4936b83001e04c6cb09457f10c4a6 100644
--- a/NoteAnnotationRetention.java
+++ b/NoteAnnotationRetention.java
@@ -44,7 +44,7 @@ public class NoteAnnotationRetention extends AnnotationVisitor implements Detect
     @Override
     public void visitAnnotation(String annotationClass, Map<String, ElementValue> map, boolean runtimeVisible) {
 
-        if (!annotationClass.equals("java.lang.annotation.Retention")) {
+        if (!"java.lang.annotation.Retention".equals(annotationClass)) {
             return;
         }
         EnumElementValue v = (EnumElementValue) map.get("value");
@@ -62,7 +62,7 @@ public class NoteAnnotationRetention extends AnnotationVisitor implements Detect
     @Override
     public void visitAfter(JavaClass obj) {
         for (String i : obj.getInterfaceNames()) {
-            if (i.equals("java.lang.annotation.Annotation")) {
+            if ("java.lang.annotation.Annotation".equals(i)) {
                 AnalysisContext.currentAnalysisContext().getAnnotationRetentionDatabase()
                 .setRuntimeRetention(getDottedClassName(), runtimeRetention);
             }
diff --git a/NumberConstructor.java b/NumberConstructor.java
index 658b6dc55e54e051783ef7d4130b0300dcdc3335..7024e4e5babc1a903446802e3dbdd3d03a635dce 100644
--- a/NumberConstructor.java
+++ b/NumberConstructor.java
@@ -19,7 +19,9 @@
 
 package edu.umd.cs.findbugs.detect;
 
+import java.util.ArrayList;
 import java.util.HashMap;
+import java.util.List;
 import java.util.Map;
 
 import javax.annotation.CheckForNull;
@@ -30,11 +32,9 @@ import edu.umd.cs.findbugs.BugAccumulator;
 import edu.umd.cs.findbugs.BugInstance;
 import edu.umd.cs.findbugs.BugReporter;
 import edu.umd.cs.findbugs.ba.ClassContext;
-import edu.umd.cs.findbugs.ba.XFactory;
-import edu.umd.cs.findbugs.ba.XMethod;
 import edu.umd.cs.findbugs.bcel.OpcodeStackDetector;
+import edu.umd.cs.findbugs.classfile.MethodDescriptor;
 import edu.umd.cs.findbugs.internalAnnotations.SlashedClassName;
-import edu.umd.cs.findbugs.util.ClassName;
 
 /**
  * Detector to find calls to Number constructors with base type argument in Java
@@ -56,15 +56,17 @@ import edu.umd.cs.findbugs.util.ClassName;
 public class NumberConstructor extends OpcodeStackDetector {
 
     static class Pair {
-        final XMethod boxingMethod;
-        public Pair(XMethod boxingMethod, XMethod parsingMethod) {
+        final MethodDescriptor boxingMethod;
+        final MethodDescriptor parsingMethod;
+        public Pair(MethodDescriptor boxingMethod, MethodDescriptor parsingMethod) {
             this.boxingMethod = boxingMethod;
             this.parsingMethod = parsingMethod;
         }
-        final XMethod parsingMethod;
     }
     private final Map<String, Pair> boxClasses = new HashMap<String, Pair>();
 
+    private final List<MethodDescriptor> methods = new ArrayList<>();
+
     private final BugAccumulator bugAccumulator;
 
     /**
@@ -86,9 +88,11 @@ public class NumberConstructor extends OpcodeStackDetector {
     }
 
     private void handle(@SlashedClassName String className, boolean isFloatingPoint, String sig) {
-        XMethod boxingMethod = XFactory.createXMethod(ClassName.toDottedClassName(className), "valueOf", sig + "L" + className +";", true);
-        XMethod parsingMethod = XFactory.createXMethod(ClassName.toDottedClassName(className), "valueOf", "(Ljava/lang/String;)" + "L" + className +";", true);
+        MethodDescriptor boxingMethod = new MethodDescriptor(className, "valueOf", sig + "L" + className +";", true);
+        MethodDescriptor parsingMethod = new MethodDescriptor(className, "valueOf", "(Ljava/lang/String;)" + "L" + className +";", true);
         boxClasses.put(className, new Pair(boxingMethod, parsingMethod));
+        methods.add(new MethodDescriptor(className, "<init>", "(Ljava/lang/String;)V"));
+        methods.add(new MethodDescriptor(className, "<init>", sig+"V"));
     }
 
     /**
@@ -100,7 +104,7 @@ public class NumberConstructor extends OpcodeStackDetector {
     @Override
     public void visitClassContext(ClassContext classContext) {
         int majorVersion = classContext.getJavaClass().getMajor();
-        if (majorVersion >= MAJOR_1_5) {
+        if (majorVersion >= MAJOR_1_5 && hasInterestingMethod(classContext.getJavaClass().getConstantPool(), methods)) {
             super.visitClassContext(classContext);
         }
     }
@@ -117,13 +121,13 @@ public class NumberConstructor extends OpcodeStackDetector {
         return sig2.startsWith(args);
     }
 
-    private @CheckForNull XMethod  getShouldCall() {
+    private @CheckForNull MethodDescriptor getShouldCall() {
         String cls = getClassConstantOperand();
         Pair pair =  boxClasses.get(cls);
         if (pair == null) {
             return null;
         }
-        XMethod shouldCall ;
+        MethodDescriptor shouldCall;
         if (getSigConstantOperand().startsWith("(Ljava/lang/String;)")) {
             shouldCall = pair.parsingMethod;
         } else {
@@ -151,14 +155,14 @@ public class NumberConstructor extends OpcodeStackDetector {
             return;
         }
         @SlashedClassName String cls = getClassConstantOperand();
-        XMethod shouldCall = getShouldCall();
+        MethodDescriptor shouldCall = getShouldCall();
         if (shouldCall == null) {
             return;
         }
 
         int prio;
         String type;
-        if (cls.equals("java/lang/Float") || cls.equals("java/lang/Double")) {
+        if ("java/lang/Float".equals(cls) || "java/lang/Double".equals(cls)) {
             prio = LOW_PRIORITY;
             type = "DM_FP_NUMBER_CTOR";
         } else {
diff --git a/OverridingEqualsNotSymmetrical.java b/OverridingEqualsNotSymmetrical.java
index 37ea077bd80153e2a5fd72ad2ba3bc24260215c5..6fc8316b806018c6d7500fcdc8ad3e8c0cedaef4 100644
--- a/OverridingEqualsNotSymmetrical.java
+++ b/OverridingEqualsNotSymmetrical.java
@@ -78,8 +78,8 @@ public class OverridingEqualsNotSymmetrical extends OpcodeStackDetector implemen
 
     @Override
     public void visit(Code obj) {
-        if (getMethodName().equals(EQUALS_NAME) && !getMethod().isStatic() && getMethod().isPublic()
-                && getMethodSig().equals(EQUALS_SIGNATURE)) {
+        if (EQUALS_NAME.equals(getMethodName()) && !getMethod().isStatic() && getMethod().isPublic()
+                && EQUALS_SIGNATURE.equals(getMethodSig())) {
             sawCheckedCast = sawSuperEquals = sawInstanceOf = sawGetClass = sawReturnSuper = sawCompare = sawReturnNonSuper = prevWasSuperEquals = sawGoodEqualsClass = sawBadEqualsClass = dangerDanger = sawInstanceOfSupertype = alwaysTrue = alwaysFalse = sawStaticDelegate = sawEqualsBuilder = false;
             sawInitialIdentityCheck = obj.getCode().length == 11 || obj.getCode().length == 9;
             equalsCalls = 0;
@@ -154,7 +154,7 @@ public class OverridingEqualsNotSymmetrical extends OpcodeStackDetector implemen
             }
 
             String superClassName = getSuperclassName().replace('/', '.');
-            if (!superClassName.equals("java.lang.Object")) {
+            if (!"java.lang.Object".equals(superClassName)) {
                 parentMap.put(classAnnotation, new ClassAnnotation(superClassName));
             }
             equalsMethod.put(classAnnotation, getMethodDescriptor());
@@ -218,8 +218,8 @@ public class OverridingEqualsNotSymmetrical extends OpcodeStackDetector implemen
         }
 
         if ((seen == INVOKESTATIC || seen == INVOKESPECIAL || seen == INVOKEVIRTUAL)
-                && (getClassConstantOperand().equals("org/apache/commons/lang/builder/EqualsBuilder")
-                        || getClassConstantOperand().equals("org/apache/commons/lang3/builder/EqualsBuilder"))) {
+                && ("org/apache/commons/lang/builder/EqualsBuilder".equals(getClassConstantOperand())
+                        || "org/apache/commons/lang3/builder/EqualsBuilder".equals(getClassConstantOperand()))) {
             sawEqualsBuilder = true;
         }
 
@@ -251,7 +251,7 @@ public class OverridingEqualsNotSymmetrical extends OpcodeStackDetector implemen
             }
         }
 
-        if ((seen == INVOKEINTERFACE || seen == INVOKEVIRTUAL) && getNameConstantOperand().equals("compare")
+        if ((seen == INVOKEINTERFACE || seen == INVOKEVIRTUAL) && "compare".equals(getNameConstantOperand())
                 && stack.getStackDepth() >= 2) {
             Item left = stack.getStackItem(1);
             Item right = stack.getStackItem(0);
@@ -261,20 +261,20 @@ public class OverridingEqualsNotSymmetrical extends OpcodeStackDetector implemen
         }
         dangerDanger = false;
 
-        if (seen == INVOKEVIRTUAL && getClassConstantOperand().equals("java/lang/Class")
-                && getNameConstantOperand().equals("getName") && getSigConstantOperand().equals("()Ljava/lang/String;")
+        if (seen == INVOKEVIRTUAL && "java/lang/Class".equals(getClassConstantOperand())
+                && "getName".equals(getNameConstantOperand()) && "()Ljava/lang/String;".equals(getSigConstantOperand())
                 && stack.getStackDepth() >= 2) {
             Item left = stack.getStackItem(1);
             XMethod leftM = left.getReturnValueOf();
             Item right = stack.getStackItem(0);
             XMethod rightM = right.getReturnValueOf();
-            if (leftM != null && rightM != null && leftM.getName().equals("getName") && rightM.getName().equals("getClass")) {
+            if (leftM != null && rightM != null && "getName".equals(leftM.getName()) && "getClass".equals(rightM.getName())) {
                 dangerDanger = true;
             }
 
         }
-        if (seen == INVOKESPECIAL && getNameConstantOperand().equals(EQUALS_NAME)
-                && getSigConstantOperand().equals(EQUALS_SIGNATURE)) {
+        if (seen == INVOKESPECIAL && EQUALS_NAME.equals(getNameConstantOperand())
+                && EQUALS_SIGNATURE.equals(getSigConstantOperand())) {
             sawSuperEquals = prevWasSuperEquals = true;
         } else {
             if (seen == IRETURN) {
@@ -315,8 +315,8 @@ public class OverridingEqualsNotSymmetrical extends OpcodeStackDetector implemen
                 sawCheckedCast = true;
             }
         }
-        if (seen == INVOKEVIRTUAL && getNameConstantOperand().equals("getClass")
-                && getSigConstantOperand().equals("()Ljava/lang/Class;")) {
+        if (seen == INVOKEVIRTUAL && "getClass".equals(getNameConstantOperand())
+                && "()Ljava/lang/Class;".equals(getSigConstantOperand())) {
             sawGetClass = true;
         }
 
@@ -324,7 +324,7 @@ public class OverridingEqualsNotSymmetrical extends OpcodeStackDetector implemen
 
     private boolean callToInvoke(int seen) {
         if (seen == INVOKEVIRTUAL || seen == INVOKEINTERFACE || seen == INVOKESPECIAL) {
-            return invokesMethodWithEqualLikeName() && getSigConstantOperand().equals(EQUALS_SIGNATURE);
+            return invokesMethodWithEqualLikeName() && EQUALS_SIGNATURE.equals(getSigConstantOperand());
         }
         if (seen == INVOKESTATIC) {
             String sig = getSigConstantOperand();
@@ -348,9 +348,9 @@ public class OverridingEqualsNotSymmetrical extends OpcodeStackDetector implemen
             XMethod leftM = left.getReturnValueOf();
             Item right = stack.getStackItem(0);
             XMethod rightM = right.getReturnValueOf();
-            if (left.getSignature().equals("Ljava/lang/Class;") && right.getSignature().equals("Ljava/lang/Class;")) {
-                boolean leftMatch = leftM != null && leftM.getName().equals("getClass");
-                boolean rightMatch = rightM != null && rightM.getName().equals("getClass");
+            if ("Ljava/lang/Class;".equals(left.getSignature()) && "Ljava/lang/Class;".equals(right.getSignature())) {
+                boolean leftMatch = leftM != null && "getClass".equals(leftM.getName());
+                boolean rightMatch = rightM != null && "getClass".equals(rightM.getName());
                 if (leftMatch && rightMatch) {
                     sawGoodEqualsClass = true;
                 } else {
diff --git a/PreferZeroLengthArrays.java b/PreferZeroLengthArrays.java
index 1d39e0e77b86089692c9e65367ae5d1404929839..922c09de3945a5d4740e9995c44df9201c93c392 100644
--- a/PreferZeroLengthArrays.java
+++ b/PreferZeroLengthArrays.java
@@ -46,7 +46,7 @@ public class PreferZeroLengthArrays extends BytecodeScanningDetector implements
         found.clear();
         // Solution to sourceforge bug 1765925; returning null is the
         // convention used by java.io.File.listFiles()
-        if (getMethodName().equals("listFiles")) {
+        if ("listFiles".equals(getMethodName())) {
             return;
         }
         String returnType = getMethodSig().substring(getMethodSig().indexOf(')') + 1);
diff --git a/PublicSemaphores.java b/PublicSemaphores.java
index 3c100445e433db0d65d3a38fe2925fe3b2c9e51f..0e445bbb7d098b4f2572ed9bcbc1000a96a583de 100644
--- a/PublicSemaphores.java
+++ b/PublicSemaphores.java
@@ -87,7 +87,7 @@ public class PublicSemaphores extends BytecodeScanningDetector implements Statel
             break;
 
         case SEEN_ALOAD_0:
-            if ((seen == INVOKEVIRTUAL) && getClassConstantOperand().equals("java/lang/Object")) {
+            if ((seen == INVOKEVIRTUAL) && "java/lang/Object".equals(getClassConstantOperand())) {
                 String methodName = getNameConstantOperand();
                 if ("wait".equals(methodName) || "notify".equals(methodName) || "notifyAll".equals(methodName)) {
                     bugReporter.reportBug(new BugInstance(this, "PS_PUBLIC_SEMAPHORES", NORMAL_PRIORITY).addClassAndMethod(this)
diff --git a/QuestionableBooleanAssignment.java b/QuestionableBooleanAssignment.java
index bbc33c215506872617335bb8a833d4d6d3b3c10a..0b394beb0f1c33e520c9b755978027900f2111ec 100644
--- a/QuestionableBooleanAssignment.java
+++ b/QuestionableBooleanAssignment.java
@@ -98,7 +98,7 @@ public class QuestionableBooleanAssignment extends BytecodeScanningDetector impl
                 state = SEEN_NOTHING;
                 if (seen == NEW) {
                     String cName = getClassConstantOperand();
-                    if (cName.equals("java/lang/AssertionError")) {
+                    if ("java/lang/AssertionError".equals(cName)) {
                         break;
                     }
                 }
diff --git a/ReadOfInstanceFieldInMethodInvokedByConstructorInSuperclass.java b/ReadOfInstanceFieldInMethodInvokedByConstructorInSuperclass.java
index 38e49dc7a981b0414d611c1de274b6c2f5d06159..196f7982fed72edeffd84060133443dab5ca26d7 100644
--- a/ReadOfInstanceFieldInMethodInvokedByConstructorInSuperclass.java
+++ b/ReadOfInstanceFieldInMethodInvokedByConstructorInSuperclass.java
@@ -167,9 +167,9 @@ public class ReadOfInstanceFieldInMethodInvokedByConstructorInSuperclass extends
     XMethod getConstructorThatCallsSuperConstructor(XMethod superConstructor) {
         FieldSummary fieldSummary = AnalysisContext.currentAnalysisContext().getFieldSummary();
 
-        XMethod lookfor = superConstructor.getSignature().equals("()V") ? null : superConstructor;
+        XMethod lookfor = "()V".equals(superConstructor.getSignature()) ? null : superConstructor;
         for (XMethod m : getXClass().getXMethods()) {
-            if (m.getName().equals("<init>")) {
+            if ("<init>".equals(m.getName())) {
                 if (fieldSummary.getSuperCall(m) == lookfor) {
                     return m;
                 }
diff --git a/ReadReturnShouldBeChecked.java b/ReadReturnShouldBeChecked.java
index 23b4e6088f87f45a404e3fe3317f02130be7dcb2..89ead5175b37ca9eb83a58708112f64793396703 100644
--- a/ReadReturnShouldBeChecked.java
+++ b/ReadReturnShouldBeChecked.java
@@ -104,20 +104,20 @@ public class ReadReturnShouldBeChecked extends BytecodeScanningDetector implemen
         }
 
         if (seen == INVOKEVIRTUAL || seen == INVOKEINTERFACE) {
-            if (getNameConstantOperand().equals("available") && getSigConstantOperand().equals("()I")
+            if ("available".equals(getNameConstantOperand()) && "()I".equals(getSigConstantOperand())
                     || getNameConstantOperand().startsWith("get") && getNameConstantOperand().endsWith("Length")
-                    && getSigConstantOperand().equals("()I") || getClassConstantOperand().equals("java/io/File")
-                    && getNameConstantOperand().equals("length") && getSigConstantOperand().equals("()J")) {
+                    && "()I".equals(getSigConstantOperand()) || "java/io/File".equals(getClassConstantOperand())
+                    && "length".equals(getNameConstantOperand()) && "()J".equals(getSigConstantOperand())) {
                 sawAvailable = 70;
                 return;
             }
         }
         sawAvailable--;
         if ((seen == INVOKEVIRTUAL || seen == INVOKEINTERFACE)
-                && getNameConstantOperand().equals("read")
+                && "read".equals(getNameConstantOperand())
 
-                && (getSigConstantOperand().equals("([B)I") || getSigConstantOperand().equals("([BII)I")
-                        || getSigConstantOperand().equals("([C)I") || getSigConstantOperand().equals("([CII)I"))
+                && ("([B)I".equals(getSigConstantOperand()) || "([BII)I".equals(getSigConstantOperand())
+                        || "([C)I".equals(getSigConstantOperand()) || "([CII)I".equals(getSigConstantOperand()))
                         && isInputStream()) {
             sawRead = true;
             recentCallToAvailable = sawAvailable > 0;
@@ -125,8 +125,7 @@ public class ReadReturnShouldBeChecked extends BytecodeScanningDetector implemen
             return;
         }
         if ((seen == INVOKEVIRTUAL || seen == INVOKEINTERFACE)
-                && (getNameConstantOperand().equals("skip") && getSigConstantOperand().equals("(J)J") || getNameConstantOperand()
-                        .equals("skipBytes") && getSigConstantOperand().equals("(I)I")) && isInputStream()
+                && ("skip".equals(getNameConstantOperand()) && "(J)J".equals(getSigConstantOperand()) || "skipBytes".equals(getNameConstantOperand()) && "(I)I".equals(getSigConstantOperand())) && isInputStream()
                         && !isImageIOInputStream()) {
             // if not ByteArrayInput Stream
             // and either no recent calls to length
diff --git a/RedundantConditions.java b/RedundantConditions.java
new file mode 100644
index 0000000000000000000000000000000000000000..87b01dbac83bcadc397deb411e4aa9dbd54d7d41
--- /dev/null
+++ b/RedundantConditions.java
@@ -0,0 +1,236 @@
+/*
+ * FindBugs - Find Bugs in Java programs
+ * Copyright (C) 2003-2008 University of Maryland
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+package edu.umd.cs.findbugs.detect;
+
+import org.apache.bcel.Constants;
+import org.apache.bcel.classfile.Method;
+import org.apache.bcel.generic.BranchInstruction;
+import org.apache.bcel.generic.ConstantPoolGen;
+import org.apache.bcel.generic.GOTO;
+import org.apache.bcel.generic.GotoInstruction;
+import org.apache.bcel.generic.ICONST;
+import org.apache.bcel.generic.IfInstruction;
+import org.apache.bcel.generic.Instruction;
+import org.apache.bcel.generic.InstructionHandle;
+import org.apache.bcel.generic.InvokeInstruction;
+import org.apache.bcel.generic.MethodGen;
+
+import edu.umd.cs.findbugs.BugAccumulator;
+import edu.umd.cs.findbugs.BugInstance;
+import edu.umd.cs.findbugs.BugReporter;
+import edu.umd.cs.findbugs.Detector;
+import edu.umd.cs.findbugs.SourceLineAnnotation;
+import edu.umd.cs.findbugs.StringAnnotation;
+import edu.umd.cs.findbugs.ba.ClassContext;
+import edu.umd.cs.findbugs.bcel.BCELUtil;
+import edu.umd.cs.findbugs.classfile.CheckedAnalysisException;
+import edu.umd.cs.findbugs.classfile.Global;
+import edu.umd.cs.findbugs.classfile.MethodDescriptor;
+import edu.umd.cs.findbugs.classfile.engine.bcel.ValueRangeAnalysisFactory.RedundantCondition;
+import edu.umd.cs.findbugs.classfile.engine.bcel.ValueRangeAnalysisFactory.ValueRangeAnalysis;
+
+/**
+ * @author Tagir Valeev
+ */
+public class RedundantConditions implements Detector {
+    private final BugAccumulator bugAccumulator;
+    private final BugReporter bugReporter;
+
+    public RedundantConditions(BugReporter bugReporter) {
+        this.bugReporter = bugReporter;
+        this.bugAccumulator = new BugAccumulator(bugReporter);
+    }
+
+    @Override
+    public void visitClassContext(ClassContext classContext) {
+        for(Method method : classContext.getJavaClass().getMethods()) {
+            MethodDescriptor methodDescriptor = BCELUtil.getMethodDescriptor(classContext.getJavaClass(), method);
+            ValueRangeAnalysis analysis;
+            try {
+                analysis = Global.getAnalysisCache().getMethodAnalysis(ValueRangeAnalysis.class, methodDescriptor);
+            } catch (CheckedAnalysisException e) {
+                bugReporter.logError("ValueRangeAnalysis failed for "+methodDescriptor, e);
+                continue;
+            }
+            if(analysis == null) {
+                continue;
+            }
+            for(RedundantCondition condition : analysis.getRedundantConditions()) {
+                int priority = getPriority(methodDescriptor, condition);
+                SourceLineAnnotation sourceLineAnnotation = SourceLineAnnotation.fromVisitedInstruction(classContext, method,
+                        condition.getLocation().getHandle().getPosition());
+                BugInstance bug = new BugInstance(condition.isByType()?"UC_USELESS_CONDITION_TYPE":"UC_USELESS_CONDITION", priority)
+                .addClassAndMethod(methodDescriptor).add(new StringAnnotation(normalize(condition.getTrueCondition())));
+                if(condition.isByType()) {
+                    bug.addType(condition.getSignature());
+                }
+                if(condition.isDeadCodeUnreachable() && condition.getDeadCodeLocation() != null && priority == HIGH_PRIORITY) {
+                    bug.addSourceLine(methodDescriptor, condition.getDeadCodeLocation()).describe(SourceLineAnnotation.ROLE_UNREACHABLE_CODE);
+                }
+                bugAccumulator.accumulateBug(bug, sourceLineAnnotation);
+            }
+            bugAccumulator.reportAccumulatedBugs();
+        }
+
+    }
+
+    private String normalize(String condition) {
+        if(condition.startsWith("this.this$")) {
+            return condition.substring("this.".length());
+        }
+        if(condition.startsWith("this.val$")) {
+            return condition.substring("this.val$".length());
+        }
+        return condition;
+    }
+
+    private int getPriority(MethodDescriptor methodDescriptor, RedundantCondition condition) {
+        if(condition.isByType()) {
+            // Skip reports which should be reported by another detector
+            long number = condition.getNumber().longValue();
+            switch(condition.getSignature()) {
+            case "I":
+                if(number == Integer.MIN_VALUE || number == Integer.MAX_VALUE) {
+                    // Will be reported as INT_VACUOUS_COMPARISON
+                    return IGNORE_PRIORITY;
+                }
+                break;
+            case "C":
+                if(number <= 0) {
+                    // Will be reported as INT_BAD_COMPARISON_WITH_NONNEGATIVE_VALUE
+                    return IGNORE_PRIORITY;
+                }
+                break;
+            case "B":
+                if(number < Byte.MIN_VALUE || number >= Byte.MAX_VALUE) {
+                    // Will be reported as INT_BAD_COMPARISON_WITH_SIGNED_BYTE
+                    return IGNORE_PRIORITY;
+                }
+                break;
+            default:
+                break;
+            }
+        }
+        int priority = condition.isDeadCodeUnreachable() ? HIGH_PRIORITY : condition.isBorder()
+                || condition.getSignature().equals("Z") ? LOW_PRIORITY : NORMAL_PRIORITY;
+        // check for boolean conversion
+        if(condition.getDeadCodeLocation() != null && condition.getLiveCodeLocation() != null && condition.isDeadCodeUnreachable()) {
+            InstructionHandle deadHandle = condition.getDeadCodeLocation().getHandle();
+            InstructionHandle liveHandle = condition.getLiveCodeLocation().getHandle();
+            int deadValue = getIntValue(deadHandle);
+            int liveValue = getIntValue(liveHandle);
+            if((deadValue == 0 && liveValue == 1) || (deadValue == 1 && liveValue == 0)) {
+                InstructionHandle deadNext = deadHandle.getNext();
+                InstructionHandle liveNext = liveHandle.getNext();
+                if(deadNext != null && liveNext != null) {
+                    InstructionHandle middle, after;
+                    if(deadNext.getNext() == liveHandle) {
+                        middle = deadNext;
+                        after = liveNext;
+                    } else if(liveNext.getNext() == deadHandle) {
+                        middle = liveNext;
+                        after = deadNext;
+                    } else {
+                        return priority;
+                    }
+                    if(!(middle.getInstruction() instanceof GOTO) || ((GOTO)middle.getInstruction()).getTarget() != after) {
+                        return priority;
+                    }
+                    MethodGen methodGen;
+                    try {
+                        methodGen = Global.getAnalysisCache().getMethodAnalysis(MethodGen.class, methodDescriptor);
+                    } catch (CheckedAnalysisException e) {
+                        return priority;
+                    }
+                    InstructionHandle consumer = getConsumer(methodGen, after);
+                    Instruction consumerInst = consumer == null ? null : consumer.getInstruction();
+                    if(consumerInst != null) {
+                        short opcode = consumerInst.getOpcode();
+                        if(opcode == Constants.IADD || opcode == Constants.ISUB || opcode == Constants.IMUL
+                                || opcode == Constants.ISHR || opcode == Constants.ISHL || opcode == Constants.IUSHR) {
+                            // It's actually integer expression with explicit ? 1 : 0 or ? 0 : 1 operation
+                            return priority;
+                        }
+                    }
+                    if(condition.getSignature().equals("Z")) {
+                        // Ignore !flag when flag value is known
+                        return IGNORE_PRIORITY;
+                    }
+                    priority = condition.isBorder() ? LOW_PRIORITY : NORMAL_PRIORITY;
+                    if(consumerInst instanceof InvokeInstruction) {
+                        ConstantPoolGen constantPool = methodGen.getConstantPool();
+                        String methodName = ((InvokeInstruction)consumerInst).getMethodName(constantPool);
+                        // Ignore values conditions used in assertion methods
+                        if((methodName.equals("assertTrue") || methodName.equals("checkArgument") || methodName.equals("isLegal")
+                                || methodName.equals("isTrue"))) {
+                            return liveValue == 1 ? condition.isBorder() ? IGNORE_PRIORITY : LOW_PRIORITY : HIGH_PRIORITY;
+                        }
+                        if((methodName.equals("assertFalse") || methodName.equals("isFalse"))) {
+                            return liveValue == 0 ? condition.isBorder() ? IGNORE_PRIORITY : LOW_PRIORITY : HIGH_PRIORITY;
+                        }
+                    }
+                }
+            }
+        }
+        return priority;
+    }
+
+    /**
+     * @param methodGen method
+     * @param start instruction to scan
+     * @return instruction which consumes value which was on top of stack before start instruction
+     * or null if cannot be determined
+     */
+    private InstructionHandle getConsumer(MethodGen methodGen, InstructionHandle start) {
+        int depth = 1;
+        InstructionHandle cur = start;
+        while(cur != null) {
+            Instruction inst = cur.getInstruction();
+            depth -= inst.consumeStack(methodGen.getConstantPool());
+            if(depth <= 0) {
+                return cur;
+            }
+            depth += inst.produceStack(methodGen.getConstantPool());
+            if(inst instanceof BranchInstruction) {
+                if(inst instanceof GotoInstruction) {
+                    cur = ((GotoInstruction)inst).getTarget();
+                    continue;
+                }
+                if(!(inst instanceof IfInstruction)) {
+                    return null;
+                }
+            }
+            cur = cur.getNext();
+        }
+        return null;
+    }
+
+    private int getIntValue(InstructionHandle handle) {
+        Instruction instruction = handle.getInstruction();
+        if(instruction instanceof ICONST) {
+            return ((ICONST)instruction).getValue().intValue();
+        }
+        return -1;
+    }
+
+    @Override
+    public void report() {
+    }
+}
diff --git a/RedundantInterfaces.java b/RedundantInterfaces.java
index f2ce355f3dd51fd6862df56c8578fc61bede67ea..7b55a396d6ee6968d2f02f20d1f2c2eeec208250 100644
--- a/RedundantInterfaces.java
+++ b/RedundantInterfaces.java
@@ -44,7 +44,7 @@ public class RedundantInterfaces extends PreorderVisitor implements Detector, St
         JavaClass obj = classContext.getJavaClass();
 
         String superClassName = obj.getSuperclassName();
-        if (superClassName.equals("java.lang.Object")) {
+        if ("java.lang.Object".equals(superClassName)) {
             return;
         }
 
diff --git a/ReflectiveClasses.java b/ReflectiveClasses.java
index f669c5fbd808273f00e8dc62e427efb7ba2fd9ad..fa4abcffca3bff6e2e3f8169f1ba23d78e92bbe0 100644
--- a/ReflectiveClasses.java
+++ b/ReflectiveClasses.java
@@ -57,8 +57,8 @@ public class ReflectiveClasses extends BytecodeScanningDetector implements NonRe
         if (seen == INVOKESTATIC) {
             // System.out.println(getClassConstantOperand()+ "." +
             // getNameConstantOperand());
-            if (constantString != null && getClassConstantOperand().equals("java/lang/Class")
-                    && getNameConstantOperand().equals("forName")) {
+            if (constantString != null && "java/lang/Class".equals(getClassConstantOperand())
+                    && "forName".equals(getNameConstantOperand())) {
                 process(ClassName.toSlashedClassName(constantString));
             }
 
diff --git a/RepeatedConditionals.java b/RepeatedConditionals.java
index 6b4429bb41944e31608cbe12a599558d4ea96b18..341cd5e8bdfa88f996054425e50f7181eb60654d 100644
--- a/RepeatedConditionals.java
+++ b/RepeatedConditionals.java
@@ -24,19 +24,29 @@ import java.util.LinkedList;
 import java.util.Map;
 
 import org.apache.bcel.classfile.Code;
+import org.apache.bcel.generic.BranchInstruction;
+import org.apache.bcel.generic.Instruction;
+import org.apache.bcel.generic.InstructionHandle;
+import org.apache.bcel.generic.MethodGen;
 import org.objectweb.asm.Opcodes;
 
 import edu.umd.cs.findbugs.BugInstance;
 import edu.umd.cs.findbugs.BugReporter;
 import edu.umd.cs.findbugs.SourceLineAnnotation;
 import edu.umd.cs.findbugs.bcel.OpcodeStackDetector;
+import edu.umd.cs.findbugs.classfile.CheckedAnalysisException;
+import edu.umd.cs.findbugs.classfile.Global;
+import edu.umd.cs.findbugs.detect.FindNoSideEffectMethods.MethodSideEffectStatus;
+import edu.umd.cs.findbugs.detect.FindNoSideEffectMethods.NoSideEffectMethodsDatabase;
 
 public class RepeatedConditionals extends OpcodeStackDetector {
-
     BugReporter bugReporter;
 
+    private final NoSideEffectMethodsDatabase noSideEffectMethods;
+
     public RepeatedConditionals(BugReporter bugReporter) {
         this.bugReporter = bugReporter;
+        this.noSideEffectMethods = Global.getAnalysisCache().getDatabase(NoSideEffectMethodsDatabase.class);
         reset();
     }
 
@@ -70,80 +80,147 @@ public class RepeatedConditionals extends OpcodeStackDetector {
 
     @Override
     public void sawOpcode(int seen) {
-        if (isRegisterStore() || isReturn(seen) || isSwitch(seen) || seen == INVOKEINTERFACE || seen == INVOKESPECIAL
-                || seen == INVOKESTATIC || seen == INVOKEVIRTUAL || seen == PUTFIELD || seen == PUTSTATIC) {
+        if (hasSideEffect(seen)) {
             reset();
         } else if (stack.getStackDepth() == 0) {
-            check: if (emptyStackLocations.size() > 1) {
-                int first = emptyStackLocations.get(emptyStackLocations.size() - 2);
-                int second = emptyStackLocations.get(emptyStackLocations.size() - 1);
-                int third = getPC();
-                if (third - second == second - first) {
-                    int endOfFirstSegment = prevOpcodeLocations.get(emptyStackLocations.size() - 1);
-                    int endOfSecondSegment = oldPC;
-                    int opcodeAtEndOfFirst = getCodeByte(endOfFirstSegment);
-                    int opcodeAtEndOfSecond = getCodeByte(endOfSecondSegment);
-
-                    if (!isBranch(opcodeAtEndOfFirst) || !isBranch(opcodeAtEndOfSecond)) {
-                        break check;
-                    }
-                    if (opcodeAtEndOfFirst == Opcodes.GOTO || opcodeAtEndOfSecond == Opcodes.GOTO) {
-                        break check;
-                    }
-                    if (opcodeAtEndOfFirst != opcodeAtEndOfSecond
-                            && !areOppositeBranches(opcodeAtEndOfFirst, opcodeAtEndOfSecond)) {
-                        break check;
-                    }
+            if (emptyStackLocations.size() > 1) {
+                for(int n=1; n<=emptyStackLocations.size()/2; n++) {
+                    int first = emptyStackLocations.get(emptyStackLocations.size() - 2*n);
+                    int second = emptyStackLocations.get(emptyStackLocations.size() - n);
+                    int third = getPC();
+                    if (third - second == second - first) {
+                        int endOfFirstSegment = prevOpcodeLocations.get(emptyStackLocations.size() - n);
+                        int endOfSecondSegment = oldPC;
+                        int opcodeAtEndOfFirst = getCodeByte(endOfFirstSegment);
+                        int opcodeAtEndOfSecond = getCodeByte(endOfSecondSegment);
+
+                        if (!isBranch(opcodeAtEndOfFirst) || !isBranch(opcodeAtEndOfSecond)) {
+                            continue;
+                        }
+                        if (opcodeAtEndOfFirst == Opcodes.GOTO || opcodeAtEndOfSecond == Opcodes.GOTO) {
+                            continue;
+                        }
+                        if (opcodeAtEndOfFirst != opcodeAtEndOfSecond
+                                && !areOppositeBranches(opcodeAtEndOfFirst, opcodeAtEndOfSecond)) {
+                            continue;
+                        }
 
-                    byte[] code = getCode().getCode();
-                    if (first == endOfFirstSegment) {
-                        break check;
-                    }
-                    for (int i = first; i < endOfFirstSegment; i++) {
-                        if (code[i] != code[i - first + second]) {
-                            break check;
+                        if (first == endOfFirstSegment) {
+                            continue;
                         }
+                        Integer firstTarget = branchTargets.get(endOfFirstSegment);
+                        Integer secondTarget = branchTargets.get(endOfSecondSegment);
+                        if (firstTarget == null || secondTarget == null) {
+                            continue;
+                        }
+                        if (firstTarget >= second && firstTarget <= endOfSecondSegment) {
+                            // first jumps inside second
+                            continue;
+                        }
+                        boolean identicalCheck = firstTarget.equals(secondTarget) && opcodeAtEndOfFirst == opcodeAtEndOfSecond
+                                || (firstTarget.intValue() == getPC() && opcodeAtEndOfFirst != opcodeAtEndOfSecond);
+                        if(!compareCode(first, endOfFirstSegment, second, endOfSecondSegment, !identicalCheck)) {
+                            continue;
+                        }
+                        SourceLineAnnotation firstSourceLine = SourceLineAnnotation.fromVisitedInstructionRange(getClassContext(),
+                                this, first, endOfFirstSegment - 1);
+                        SourceLineAnnotation secondSourceLine = SourceLineAnnotation.fromVisitedInstructionRange(getClassContext(),
+                                this, second, endOfSecondSegment - 1);
+
+                        int priority = HIGH_PRIORITY;
+                        if (firstSourceLine.getStartLine() == -1 || firstSourceLine.getStartLine() != secondSourceLine.getEndLine()) {
+                            priority++;
+                        }
+                        if (stack.isJumpTarget(second)) {
+                            priority++;
+                        }
+                        if (!identicalCheck) {
+                            // opposite checks
+                            priority += 2;
+                        }
+
+                        BugInstance bug = new BugInstance(this, "RpC_REPEATED_CONDITIONAL_TEST", priority).addClassAndMethod(this)
+                                .add(firstSourceLine).add(secondSourceLine);
+                        bugReporter.reportBug(bug);
                     }
-                    if (false) {
-                        System.out.println(getFullyQualifiedMethodName());
-                        System.out.println(first + " ... " + endOfFirstSegment + " : " + OPCODE_NAMES[opcodeAtEndOfFirst]);
-                        System.out.println(second + " ... " + endOfSecondSegment + " : " + OPCODE_NAMES[opcodeAtEndOfSecond]);
-                    }
-                    SourceLineAnnotation firstSourceLine = SourceLineAnnotation.fromVisitedInstructionRange(getClassContext(),
-                            this, first, endOfFirstSegment - 1);
-                    SourceLineAnnotation secondSourceLine = SourceLineAnnotation.fromVisitedInstructionRange(getClassContext(),
-                            this, second, endOfSecondSegment - 1);
-
-                    int priority = HIGH_PRIORITY;
-                    if (firstSourceLine.getStartLine() == -1 || firstSourceLine.getStartLine() != secondSourceLine.getEndLine()) {
-                        priority++;
-                    }
-                    if (stack.isJumpTarget(second)) {
-                        priority++;
-                    }
-                    Integer firstTarget = branchTargets.get(endOfFirstSegment);
-                    Integer secondTarget = branchTargets.get(endOfSecondSegment);
-                    if (firstTarget == null || secondTarget == null) {
-                        break check;
+                }
+            }
+            emptyStackLocations.add(getPC());
+            prevOpcodeLocations.add(oldPC);
+
+        }
+        oldPC = getPC();
+    }
+
+    private boolean compareCode(int first, int endOfFirstSegment, int second,
+            int endOfSecondSegment, boolean oppositeChecks) {
+        if(endOfFirstSegment-first != endOfSecondSegment-second) {
+            return false;
+        }
+        MethodGen methodGen = null;
+        try {
+            methodGen = Global.getAnalysisCache().getMethodAnalysis(MethodGen.class, getMethodDescriptor());
+        } catch (CheckedAnalysisException e) {
+            // Ignore
+        }
+        if(methodGen == null) {
+            // MethodGen is absent for some reason: fallback to byte-to-byte comparison
+            byte[] code = getCode().getCode();
+            for (int i = first; i < endOfFirstSegment; i++) {
+                if (code[i] != code[i - first + second]) {
+                    return false;
+                }
+            }
+            return true;
+        }
+        InstructionHandle firstHandle = methodGen.getInstructionList().findHandle(first);
+        InstructionHandle secondHandle = methodGen.getInstructionList().findHandle(second);
+        while(true) {
+            if(firstHandle == null || secondHandle == null) {
+                return false;
+            }
+            if(firstHandle.getPosition() >= endOfFirstSegment) {
+                return secondHandle.getPosition() >= endOfSecondSegment;
+            }
+            if(secondHandle.getPosition() >= endOfSecondSegment) {
+                return firstHandle.getPosition() >= endOfFirstSegment;
+            }
+            Instruction firstInstruction = firstHandle.getInstruction();
+            Instruction secondInstruction = secondHandle.getInstruction();
+            if(firstInstruction instanceof BranchInstruction && secondInstruction instanceof BranchInstruction) {
+                int firstOpcode = firstInstruction.getOpcode();
+                int secondOpcode = secondInstruction.getOpcode();
+                if(firstOpcode != secondOpcode) {
+                    return false;
+                }
+                int firstTarget = ((BranchInstruction)firstInstruction).getTarget().getPosition();
+                int secondTarget = ((BranchInstruction)secondInstruction).getTarget().getPosition();
+                if(firstTarget == second) {
+                    if(oppositeChecks || secondTarget <= endOfSecondSegment) {
+                        return false;
                     }
-                    if (firstTarget.equals(secondTarget) && opcodeAtEndOfFirst == opcodeAtEndOfSecond
-                            || firstTarget.intValue() == getPC()) {
-                        // identical checks;
-                    } else {
-                        // opposite checks
-                        priority += 2;
+                } else {
+                    if(!((firstTarget >= first && firstTarget <= endOfFirstSegment && firstTarget - first == secondTarget - second)
+                            || firstTarget == secondTarget)) {
+                        return false;
                     }
-
-                    BugInstance bug = new BugInstance(this, "RpC_REPEATED_CONDITIONAL_TEST", priority).addClassAndMethod(this)
-                            .add(firstSourceLine).add(secondSourceLine);
-                    bugReporter.reportBug(bug);
+                }
+            } else {
+                if(!firstInstruction.equals(secondInstruction)) {
+                    return false;
                 }
             }
-        emptyStackLocations.add(getPC());
-        prevOpcodeLocations.add(oldPC);
+            firstHandle = firstHandle.getNext();
+            secondHandle = secondHandle.getNext();
+        }
+    }
 
+    private boolean hasSideEffect(int seen) {
+        if(seen == INVOKEVIRTUAL || seen == INVOKESPECIAL || seen == INVOKEINTERFACE || seen == INVOKESTATIC) {
+            return noSideEffectMethods.is(getMethodDescriptorOperand(), MethodSideEffectStatus.SE, MethodSideEffectStatus.OBJ);
         }
-        oldPC = getPC();
+        return isRegisterStore() || isReturn(seen) || isSwitch(seen) || seen == INVOKEDYNAMIC || seen == PUTFIELD
+                || seen == PUTSTATIC;
     }
 
     private void reset() {
diff --git a/RuntimeExceptionCapture.java b/RuntimeExceptionCapture.java
index 3d3e6a2b8489577fae4a47688ddeaa115b5bb07e..327c83ce5511f1405e8c637950a05ad91a1f4f43 100644
--- a/RuntimeExceptionCapture.java
+++ b/RuntimeExceptionCapture.java
@@ -131,14 +131,14 @@ public class RuntimeExceptionCapture extends OpcodeStackDetector implements Stat
                 }
             }
             int catchClauses = 0;
-            if (caughtException.exceptionClass.equals("java.lang.Exception") && !caughtException.seen) {
+            if ("java.lang.Exception".equals(caughtException.exceptionClass) && !caughtException.seen) {
                 // Now we have a case where Exception is caught, but not thrown
                 boolean rteCaught = false;
                 for (ExceptionCaught otherException : catchList) {
                     if (otherException.startOffset == caughtException.startOffset
                             && otherException.endOffset == caughtException.endOffset) {
                         catchClauses++;
-                        if (otherException.exceptionClass.equals("java.lang.RuntimeException")) {
+                        if ("java.lang.RuntimeException".equals(otherException.exceptionClass)) {
                             rteCaught = true;
                         }
                     }
diff --git a/SerializableIdiom.java b/SerializableIdiom.java
index 9ac462b864aed60da766c892cc903cf6d748b7b8..47dd3d47f73cf24779565d52e3f104cee80d5b7c 100644
--- a/SerializableIdiom.java
+++ b/SerializableIdiom.java
@@ -159,7 +159,7 @@ public class SerializableIdiom extends OpcodeStackDetector {
         String superClassname = obj.getSuperclassName();
         // System.out.println("superclass of " + getClassName() + " is " +
         // superClassname);
-        isEnum = superClassname.equals("java.lang.Enum");
+        isEnum = "java.lang.Enum".equals(superClassname);
         if (isEnum) {
             return;
         }
@@ -168,7 +168,7 @@ public class SerializableIdiom extends OpcodeStackDetector {
         isAnonymousInnerClass = anonymousInnerClassNamePattern.matcher(getClassName()).matches();
         innerClassHasOuterInstance = false;
         for (Field f : obj.getFields()) {
-            if (f.getName().equals("this$0")) {
+            if ("this$0".equals(f.getName())) {
                 innerClassHasOuterInstance = true;
                 break;
             }
@@ -192,13 +192,13 @@ public class SerializableIdiom extends OpcodeStackDetector {
         // Does this class directly implement Serializable?
         String[] interface_names = obj.getInterfaceNames();
         for (String interface_name : interface_names) {
-            if (interface_name.equals("java.io.Externalizable")) {
+            if ("java.io.Externalizable".equals(interface_name)) {
                 directlyImplementsExternalizable = true;
                 isExternalizable = true;
                 if (DEBUG) {
                     System.out.println("Directly implements Externalizable: " + getClassName());
                 }
-            } else if (interface_name.equals("java.io.Serializable")) {
+            } else if ("java.io.Serializable".equals(interface_name)) {
                 implementsSerializableDirectly = true;
                 isSerializable = true;
                 if (DEBUG) {
@@ -240,10 +240,10 @@ public class SerializableIdiom extends OpcodeStackDetector {
                                     DescriptorFactory.createClassDescriptor(java.io.Serializable.class));
                     superClassHasVoidConstructor = false;
                     for (XMethod m : superXClass.getXMethods()) {
-                        if (m.getName().equals("<init>") && m.getSignature().equals("()V") && !m.isPrivate()) {
+                        if ("<init>".equals(m.getName()) && "()V".equals(m.getSignature()) && !m.isPrivate()) {
                             superClassHasVoidConstructor = true;
                         }
-                        if (m.getName().equals("readObject") && m.getSignature().equals("(Ljava/io/ObjectInputStream;)V")
+                        if ("readObject".equals(m.getName()) && "(Ljava/io/ObjectInputStream;)V".equals(m.getSignature())
                                 && m.isPrivate()) {
                             superClassHasReadObject = true;
                         }
@@ -292,13 +292,13 @@ public class SerializableIdiom extends OpcodeStackDetector {
         if (isSerializable) {
             for (Method m : obj.getMethods()) {
 
-                if (m.getName().equals("readObject") && m.getSignature().equals("(Ljava/io/ObjectInputStream;)V")) {
+                if ("readObject".equals(m.getName()) && "(Ljava/io/ObjectInputStream;)V".equals(m.getSignature())) {
                     sawReadObject = true;
-                } else if (m.getName().equals("readResolve") && m.getSignature().startsWith("()")) {
+                } else if ("readResolve".equals(m.getName()) && m.getSignature().startsWith("()")) {
                     sawReadResolve = true;
-                } else if (m.getName().equals("readObjectNoData") && m.getSignature().equals("()V")) {
+                } else if ("readObjectNoData".equals(m.getName()) && "()V".equals(m.getSignature())) {
                     sawReadObject = true;
-                } else if (m.getName().equals("writeObject") && m.getSignature().equals("(Ljava/io/ObjectOutputStream;)V")) {
+                } else if ("writeObject".equals(m.getName()) && "(Ljava/io/ObjectOutputStream;)V".equals(m.getSignature())) {
                     sawWriteObject = true;
                 }
             }
@@ -424,28 +424,28 @@ public class SerializableIdiom extends OpcodeStackDetector {
 
         int accessFlags = obj.getAccessFlags();
         boolean isSynchronized = (accessFlags & ACC_SYNCHRONIZED) != 0;
-        if (getMethodName().equals("<init>") && getMethodSig().equals("()V") && (accessFlags & ACC_PUBLIC) != 0) {
+        if ("<init>".equals(getMethodName()) && "()V".equals(getMethodSig()) && (accessFlags & ACC_PUBLIC) != 0) {
             hasPublicVoidConstructor = true;
         }
-        if (!getMethodName().equals("<init>") && isSynthetic(obj))
+        if (!"<init>".equals(getMethodName()) && isSynthetic(obj))
         {
             foundSynthetic = true;
             // System.out.println(methodName + isSynchronized);
         }
 
-        if (getMethodName().equals("readExternal") && getMethodSig().equals("(Ljava/io/ObjectInput;)V")) {
+        if ("readExternal".equals(getMethodName()) && "(Ljava/io/ObjectInput;)V".equals(getMethodSig())) {
             sawReadExternal = true;
             if (DEBUG && !obj.isPrivate()) {
                 System.out.println("Non-private readExternal method in: " + getDottedClassName());
             }
-        } else if (getMethodName().equals("writeExternal") && getMethodSig().equals("(Ljava/io/Objectoutput;)V")) {
+        } else if ("writeExternal".equals(getMethodName()) && "(Ljava/io/Objectoutput;)V".equals(getMethodSig())) {
             sawWriteExternal = true;
             if (DEBUG && !obj.isPrivate()) {
                 System.out.println("Non-private writeExternal method in: " + getDottedClassName());
             }
-        } else if (getMethodName().equals("readResolve") && getMethodSig().startsWith("()") && isSerializable) {
+        } else if ("readResolve".equals(getMethodName()) && getMethodSig().startsWith("()") && isSerializable) {
             sawReadResolve = true;
-            if (!getMethodSig().equals("()Ljava/lang/Object;")) {
+            if (!"()Ljava/lang/Object;".equals(getMethodSig())) {
                 bugReporter.reportBug(new BugInstance(this, "SE_READ_RESOLVE_MUST_RETURN_OBJECT", HIGH_PRIORITY)
                 .addClassAndMethod(this));
             } else if (obj.isStatic()) {
@@ -482,20 +482,20 @@ public class SerializableIdiom extends OpcodeStackDetector {
                 }
             }
 
-        } else if (getMethodName().equals("readObject") && getMethodSig().equals("(Ljava/io/ObjectInputStream;)V")
+        } else if ("readObject".equals(getMethodName()) && "(Ljava/io/ObjectInputStream;)V".equals(getMethodSig())
                 && isSerializable) {
             sawReadObject = true;
             if (!obj.isPrivate()) {
                 bugReporter.reportBug(new BugInstance(this, "SE_METHOD_MUST_BE_PRIVATE", isExternalizable ? NORMAL_PRIORITY : HIGH_PRIORITY).addClassAndMethod(this));
             }
 
-        } else if (getMethodName().equals("readObjectNoData") && getMethodSig().equals("()V") && isSerializable) {
+        } else if ("readObjectNoData".equals(getMethodName()) && "()V".equals(getMethodSig()) && isSerializable) {
 
             if (!obj.isPrivate()) {
                 bugReporter.reportBug(new BugInstance(this, "SE_METHOD_MUST_BE_PRIVATE", isExternalizable ? NORMAL_PRIORITY : HIGH_PRIORITY).addClassAndMethod(this));
             }
 
-        } else if (getMethodName().equals("writeObject") && getMethodSig().equals("(Ljava/io/ObjectOutputStream;)V")
+        } else if ("writeObject".equals(getMethodName()) && "(Ljava/io/ObjectOutputStream;)V".equals(getMethodSig())
                 && isSerializable) {
             sawWriteObject = true;
             if (!obj.isPrivate()) {
@@ -504,9 +504,9 @@ public class SerializableIdiom extends OpcodeStackDetector {
         }
 
         if (isSynchronized) {
-            if (getMethodName().equals("readObject") && getMethodSig().equals("(Ljava/io/ObjectInputStream;)V") && isSerializable) {
+            if ("readObject".equals(getMethodName()) && "(Ljava/io/ObjectInputStream;)V".equals(getMethodSig()) && isSerializable) {
                 bugReporter.reportBug(new BugInstance(this, "RS_READOBJECT_SYNC",isExternalizable ? LOW_PRIORITY :  NORMAL_PRIORITY).addClassAndMethod(this));
-            } else if (getMethodName().equals("writeObject") && getMethodSig().equals("(Ljava/io/ObjectOutputStream;)V")
+            } else if ("writeObject".equals(getMethodName()) && "(Ljava/io/ObjectOutputStream;)V".equals(getMethodSig())
                     && isSerializable) {
                 writeObjectIsSynchronized = true;
             } else {
@@ -543,7 +543,7 @@ public class SerializableIdiom extends OpcodeStackDetector {
 
                 boolean isPutOfDefaultValue = first.isNull(); // huh?? ||
                 // first.isInitialParameter();
-                if (!isPutOfDefaultValue && first.getConstant() != null) {
+                if (!isPutOfDefaultValue && first.getConstant() != null && !first.isArray()) {
                     Object constant = first.getConstant();
                     if (constant instanceof Number && ((Number) constant).intValue() == 0 || constant.equals(Boolean.FALSE)) {
                         isPutOfDefaultValue = true;
@@ -551,14 +551,14 @@ public class SerializableIdiom extends OpcodeStackDetector {
                 }
 
                 if (isPutOfDefaultValue) {
-                    if (getMethodName().equals("<init>")) {
+                    if ("<init>".equals(getMethodName())) {
                         transientFieldsSetToDefaultValueInConstructor.add(xField);
                     }
                 } else {
                     String nameOfField = getNameConstantOperand();
 
                     if (transientFieldsUpdates.containsKey(xField)) {
-                        if (getMethodName().equals("<init>")) {
+                        if ("<init>".equals(getMethodName())) {
                             transientFieldsSetInConstructor.add(xField);
                         } else {
                             transientFieldsUpdates.put(xField, transientFieldsUpdates.get(xField) + 1);
@@ -582,7 +582,7 @@ public class SerializableIdiom extends OpcodeStackDetector {
                                 String genSig = "L" + classStored.getClassName().replace('.', '/') + ";";
                                 if (!sig.equals(genSig)) {
                                     double bias = 0.0;
-                                    if (!getMethodName().equals("<init>")) {
+                                    if (!"<init>".equals(getMethodName())) {
                                         bias = 1.0;
                                     }
                                     int priority = computePriority(isSerializable, bias);
@@ -692,7 +692,7 @@ public class SerializableIdiom extends OpcodeStackDetector {
                             // seen.
                         }
 
-                        if (obj.getName().equals("this$0")) {
+                        if ("this$0".equals(obj.getName())) {
                             fieldWarningList.add(new BugInstance(this, "SE_BAD_FIELD_INNER_CLASS", priority).addClass(getThisClass()
                                     .getClassName()));
                         } else if (isSerializable < 0.9) {
@@ -701,7 +701,7 @@ public class SerializableIdiom extends OpcodeStackDetector {
                             .addField(xfield).addType(problemType)
                             .describe("TYPE_FOUND"));
                         }
-                    } else if (!isGUIClass && !isEjbImplClass && !isJSPClass && obj.getName().equals("this$0")) {
+                    } else if (!isGUIClass && !isEjbImplClass && !isJSPClass && "this$0".equals(obj.getName())) {
                         fieldWarningList.add(new BugInstance(this, "SE_INNER_CLASS", implementsSerializableDirectly ? NORMAL_PRIORITY
                                 : LOW_PRIORITY).addClass(getThisClass().getClassName()));
                     }
@@ -717,14 +717,14 @@ public class SerializableIdiom extends OpcodeStackDetector {
         if (!getFieldName().startsWith("this") && isSynthetic(obj)) {
             foundSynthetic = true;
         }
-        if (!getFieldName().equals("serialVersionUID")) {
+        if (!"serialVersionUID".equals(getFieldName())) {
             return;
         }
         int mask = ACC_STATIC | ACC_FINAL;
-        if (!fieldSig.equals("I") && !fieldSig.equals("J")) {
+        if (!"I".equals(fieldSig) && !"J".equals(fieldSig)) {
             return;
         }
-        if ((flags & mask) == mask && fieldSig.equals("I")) {
+        if ((flags & mask) == mask && "I".equals(fieldSig)) {
             bugReporter.reportBug(new BugInstance(this, "SE_NONLONG_SERIALVERSIONID", LOW_PRIORITY).addClass(this)
                     .addVisitedField(this));
             sawSerialVersionUID = true;
diff --git a/StartInConstructor.java b/StartInConstructor.java
index d83fafc928aaea4ab03774d2c4593a802c3ca48a..e5bc79d5a53fcb5dba008f47bb910b748b7f6735 100644
--- a/StartInConstructor.java
+++ b/StartInConstructor.java
@@ -54,7 +54,7 @@ public class StartInConstructor extends BytecodeScanningDetector implements Stat
 
     @Override
     public void visit(Code obj) {
-        if (getMethodName().equals("<init>") && (getMethod().isPublic() || getMethod().isProtected())) {
+        if ("<init>".equals(getMethodName()) && (getMethod().isPublic() || getMethod().isProtected())) {
             super.visit(obj);
             bugAccumulator.reportAccumulatedBugs();
         }
@@ -62,7 +62,7 @@ public class StartInConstructor extends BytecodeScanningDetector implements Stat
 
     @Override
     public void sawOpcode(int seen) {
-        if (seen == INVOKEVIRTUAL && getNameConstantOperand().equals("start") && getSigConstantOperand().equals("()V")) {
+        if (seen == INVOKEVIRTUAL && "start".equals(getNameConstantOperand()) && "()V".equals(getSigConstantOperand())) {
             try {
                 if (Hierarchy.isSubtype(getDottedClassConstantOperand(), "java.lang.Thread")) {
                     int priority = Priorities.NORMAL_PRIORITY;
diff --git a/StaticCalendarDetector.java b/StaticCalendarDetector.java
index cccbe604c0d98f86b6d08a7a752a032521b12511..6c04abe612e1f4a379697d1bb14138bc8e395078 100644
--- a/StaticCalendarDetector.java
+++ b/StaticCalendarDetector.java
@@ -138,7 +138,7 @@ public class StaticCalendarDetector extends OpcodeStackDetector {
             if (constant instanceof ConstantClass) {
                 ConstantClass cc = (ConstantClass) constant;
                 @SlashedClassName String className = cc.getBytes(pool);
-                if (className.equals("java/util/Calendar") || className.equals("java/text/DateFormat")) {
+                if ("java/util/Calendar".equals(className) || "java/text/DateFormat".equals(className)) {
                     sawDateClass = true;
                     break;
                 }
@@ -175,7 +175,7 @@ public class StaticCalendarDetector extends OpcodeStackDetector {
             return;
         }
         String superclassName = getSuperclassName();
-        if (!aField.isStatic() && !superclassName.equals("java/lang/Enum")) {
+        if (!aField.isStatic() && !"java/lang/Enum".equals(superclassName)) {
             return;
         }
         if (!aField.isPublic() && !aField.isProtected()) {
@@ -295,14 +295,14 @@ public class StaticCalendarDetector extends OpcodeStackDetector {
                 return;
             }
 
-            if (getMethodName().equals("<clinit>") && field.getClassName().equals(getDottedClassName())) {
+            if ("<clinit>".equals(getMethodName()) && field.getClassName().equals(getDottedClassName())) {
                 return;
             }
             String invokedName = getNameConstantOperand();
             if (invokedName.startsWith("get")) {
                 return;
             }
-            if (invokedName.equals("equals") && numArguments == 1) {
+            if ("equals".equals(invokedName) && numArguments == 1) {
                 OpcodeStack.Item passedAsArgument = stack.getStackItem(0);
                 field = passedAsArgument.getXField();
                 if (field == null || !field.isStatic()) {
@@ -336,8 +336,8 @@ public class StaticCalendarDetector extends OpcodeStackDetector {
                 } else {
                     priority = LOW_PRIORITY;
                 }
-                if (invokedName.startsWith("set") || invokedName.equals("format") || invokedName.equals("add")
-                        || invokedName.equals("clear") || invokedName.equals("parse") || invokedName.equals("applyPattern")) {
+                if (invokedName.startsWith("set") || "format".equals(invokedName) || "add".equals(invokedName)
+                        || "clear".equals(invokedName) || "parse".equals(invokedName) || "applyPattern".equals(invokedName)) {
                     priority--;
                 }
             }
diff --git a/Stream.java b/Stream.java
index eabbf83123fb44edf462ef7aa8b2925610eb83e5..16f177f0f2f3c13b4c2065c54737c39c4d0932c6 100644
--- a/Stream.java
+++ b/Stream.java
@@ -210,7 +210,7 @@ public class Stream extends ResourceCreationPoint implements Comparable<Stream>
             // (Basically, we may not see the exact original stream class,
             // even though it's the same instance.)
 
-            return inv.getName(cpg).equals("close") && inv.getSignature(cpg).equals("()V");
+            return "close".equals(inv.getName(cpg)) && "()V".equals(inv.getSignature(cpg));
 
         }
 
@@ -243,9 +243,9 @@ public class Stream extends ResourceCreationPoint implements Comparable<Stream>
                 if (relatedType(classClosed) ) {
                     return true;
                 }
-                if (classClosed.equals("java.io.ObjectOutput")) {
+                if ("java.io.ObjectOutput".equals(classClosed)) {
                     return relatedType("java.io.ObjectOutputStream");
-                } else if (classClosed.equals("java.io.ObjectInput")) {
+                } else if ("java.io.ObjectInput".equals(classClosed)) {
                     return relatedType("java.io.ObjectInputStream");
                 }
                 return false;
diff --git a/StreamFrameModelingVisitor.java b/StreamFrameModelingVisitor.java
index 82fa569032532260e32f2069280c7c5a3f35e9a3..31056e668a51c6b7af1fed4add80a67532965572 100644
--- a/StreamFrameModelingVisitor.java
+++ b/StreamFrameModelingVisitor.java
@@ -107,12 +107,11 @@ public class StreamFrameModelingVisitor extends ResourceValueFrameModelingVisito
         String methodName = inv.getMethodName(cpg);
         String methodSig = inv.getSignature(cpg);
         if (inv.getOpcode() == Constants.INVOKEVIRTUAL
-                && (methodName.equals("load") || methodName.equals("loadFromXml") || methodName.equals("store") || methodName
-                        .equals("save")) && className.equals("java.util.Properties")) {
+                && ("load".equals(methodName) || "loadFromXml".equals(methodName) || "store".equals(methodName) || "save".equals(methodName)) && "java.util.Properties".equals(className)) {
             escapes = false;
         }
-        if (inv.getOpcode() == Constants.INVOKEVIRTUAL && (methodName.equals("load") || methodName.equals("store"))
-                && className.equals("java.security.KeyStore")) {
+        if (inv.getOpcode() == Constants.INVOKEVIRTUAL && ("load".equals(methodName) || "store".equals(methodName))
+                && "java.security.KeyStore".equals(className)) {
             escapes = false;
         }
         if (inv.getOpcode() == Constants.INVOKEVIRTUAL && "getChannel".equals(methodName)
diff --git a/StringConcatenation.java b/StringConcatenation.java
index 191e8b7c54a9ffe6f8c6485cad1bf2ac5bbaa661..f5266a363da4510b80ee8ba71cdded659329c3e8 100644
--- a/StringConcatenation.java
+++ b/StringConcatenation.java
@@ -22,6 +22,7 @@ package edu.umd.cs.findbugs.detect;
 
 import java.util.HashMap;
 import java.util.Map;
+import java.util.Map.Entry;
 
 import org.apache.bcel.classfile.Method;
 
@@ -220,11 +221,12 @@ public class StringConcatenation extends BytecodeScanningDetector implements Sta
                 // Next check: was the destination register clobbered
                 // elsewhere in this loop?
                 boolean clobberedInLoop = false;
-                for (int reg : clobberedRegisters.keySet()) {
+                for (Entry<Integer, Integer> entry : clobberedRegisters.entrySet()) {
+                    int reg = entry.getKey();
                     if (reg != stringSource) {
                         continue;
                     }
-                    int pc = clobberedRegisters.get(reg);
+                    int pc = entry.getValue();
                     if (pc >= getBranchTarget()) {
                         clobberedInLoop = true;
                         break;
@@ -257,9 +259,9 @@ public class StringConcatenation extends BytecodeScanningDetector implements Sta
             break;
         }
 
-        if (seen == INVOKESTATIC && getNameConstantOperand().equals("valueOf")
-                && getClassConstantOperand().equals("java/lang/String")
-                && getSigConstantOperand().equals("(Ljava/lang/Object;)Ljava/lang/String;")) {
+        if (seen == INVOKESTATIC && "valueOf".equals(getNameConstantOperand())
+                && "java/lang/String".equals(getClassConstantOperand())
+                && "(Ljava/lang/Object;)Ljava/lang/String;".equals(getSigConstantOperand())) {
             // leave registerOnStack unchanged
         } else {
             registerOnStack = -1;
diff --git a/SuspiciousThreadInterrupted.java b/SuspiciousThreadInterrupted.java
index 317adf68dfd6146ec6a23c5a0ca44c190dd9a4da..c99e2f342402a3bfdaa59654aa2f4e9e44a77def 100644
--- a/SuspiciousThreadInterrupted.java
+++ b/SuspiciousThreadInterrupted.java
@@ -21,6 +21,7 @@
 package edu.umd.cs.findbugs.detect;
 
 import java.util.BitSet;
+import java.util.Collections;
 
 import org.apache.bcel.classfile.Method;
 
@@ -28,6 +29,7 @@ import edu.umd.cs.findbugs.BugInstance;
 import edu.umd.cs.findbugs.BugReporter;
 import edu.umd.cs.findbugs.BytecodeScanningDetector;
 import edu.umd.cs.findbugs.StatelessDetector;
+import edu.umd.cs.findbugs.ba.ClassContext;
 
 /**
  * looks for calls to Thread.interrupted from a non static context, especially
@@ -55,6 +57,13 @@ public class SuspiciousThreadInterrupted extends BytecodeScanningDetector implem
     }
 
     @Override
+    public void visitClassContext(ClassContext classContext) {
+        if(hasInterestingClass(classContext.getJavaClass().getConstantPool(), Collections.singleton("java/lang/Thread"))) {
+            super.visitClassContext(classContext);
+        }
+    }
+
+    @Override
     public void visit(Method obj) {
         localsWithCurrentThreadValue = new BitSet();
         state = SEEN_NOTHING;
@@ -74,8 +83,8 @@ public class SuspiciousThreadInterrupted extends BytecodeScanningDetector implem
         }
         switch (state) {
         case SEEN_NOTHING:
-            if ((seen == INVOKESTATIC) && getClassConstantOperand().equals("java/lang/Thread")
-                    && getNameConstantOperand().equals("currentThread") && getSigConstantOperand().equals("()Ljava/lang/Thread;")) {
+            if ((seen == INVOKESTATIC) && "java/lang/Thread".equals(getClassConstantOperand())
+                    && "currentThread".equals(getNameConstantOperand()) && "()Ljava/lang/Thread;".equals(getSigConstantOperand())) {
                 state = SEEN_CURRENTTHREAD;
             } else if ((seen == INVOKESTATIC || seen == INVOKEINTERFACE || seen == INVOKEVIRTUAL || seen == INVOKESPECIAL)
                     && getSigConstantOperand().endsWith("Ljava/lang/Thread;")) {
@@ -92,7 +101,7 @@ public class SuspiciousThreadInterrupted extends BytecodeScanningDetector implem
                 } else {
                     state = SEEN_POSSIBLE_THREAD;
                 }
-            } else if ((seen == GETFIELD || seen == GETSTATIC) && getSigConstantOperand().equals("Ljava/lang/Thread;")) {
+            } else if ((seen == GETFIELD || seen == GETSTATIC) && "Ljava/lang/Thread;".equals(getSigConstantOperand())) {
                 state = SEEN_POSSIBLE_THREAD;
             }
             break;
@@ -112,8 +121,8 @@ public class SuspiciousThreadInterrupted extends BytecodeScanningDetector implem
             break;
 
         default:
-            if ((seen == INVOKESTATIC) && getClassConstantOperand().equals("java/lang/Thread")
-                    && getNameConstantOperand().equals("interrupted") && getSigConstantOperand().equals("()Z")) {
+            if ((seen == INVOKESTATIC) && "java/lang/Thread".equals(getClassConstantOperand())
+                    && "interrupted".equals(getNameConstantOperand()) && "()Z".equals(getSigConstantOperand())) {
                 if (state == SEEN_POP_AFTER_CURRENTTHREAD) {
                     bugReporter.reportBug(new BugInstance(this, "STI_INTERRUPTED_ON_CURRENTTHREAD", LOW_PRIORITY)
                     .addClassAndMethod(this).addSourceLine(this));
diff --git a/SwitchFallthrough.java b/SwitchFallthrough.java
index 983a38bc1f817e5b7dbed1dd28764c86d9cfac63..63c60cd9f9b351c4c4ef4d4e8ade2058968bdab7 100644
--- a/SwitchFallthrough.java
+++ b/SwitchFallthrough.java
@@ -243,11 +243,11 @@ public class SwitchFallthrough extends OpcodeStackDetector implements StatelessD
         }
 
 
-        if (seen == INVOKEVIRTUAL && getNameConstantOperand().equals("ordinal") && getSigConstantOperand().equals("()I")) {
+        if (seen == INVOKEVIRTUAL && "ordinal".equals(getNameConstantOperand()) && "()I".equals(getSigConstantOperand())) {
             XClass c = getXClassOperand();
             if (c != null) {
                 ClassDescriptor superclassDescriptor = c.getSuperclassDescriptor();
-                if (superclassDescriptor != null && superclassDescriptor.getClassName().equals("java/lang/Enum")) {
+                if (superclassDescriptor != null && "java/lang/Enum".equals(superclassDescriptor.getClassName())) {
                     enumType = c;
                 }
                 if (DEBUG) {
@@ -303,7 +303,7 @@ public class SwitchFallthrough extends OpcodeStackDetector implements StatelessD
             reachable = true;
         }
 
-        justSawHashcode =   seen == INVOKEVIRTUAL && getNameConstantOperand().equals("hashCode") && getSigConstantOperand().equals("()I");
+        justSawHashcode =   seen == INVOKEVIRTUAL && "hashCode".equals(getNameConstantOperand()) && "()I".equals(getSigConstantOperand());
         lastPC = getPC();
         fallthroughDistance++;
     }
diff --git a/SynchronizationOnSharedBuiltinConstant.java b/SynchronizationOnSharedBuiltinConstant.java
index e8f5a6f8499da47f78ac42407dd482d306518e69..e0c853fd90a8a94ac9ff9a1ecddb438f6b8cdad7 100644
--- a/SynchronizationOnSharedBuiltinConstant.java
+++ b/SynchronizationOnSharedBuiltinConstant.java
@@ -56,7 +56,7 @@ public class SynchronizationOnSharedBuiltinConstant extends OpcodeStackDetector
         if (method == null) {
             return false;
         }
-        return method.getName().equals("<init>");
+        return "<init>".equals(method.getName());
     }
 
     private static final Pattern identified = Pattern.compile("\\p{Alnum}+");
@@ -90,7 +90,7 @@ public class SynchronizationOnSharedBuiltinConstant extends OpcodeStackDetector
             syncSignature = top.getSignature();
             isSyncOnBoolean = false;
             Object constant = top.getConstant();
-            if (syncSignature.equals("Ljava/lang/String;") && constant instanceof String) {
+            if ("Ljava/lang/String;".equals(syncSignature) && constant instanceof String) {
 
                 pendingBug = new BugInstance(this, "DL_SYNCHRONIZATION_ON_SHARED_CONSTANT", NORMAL_PRIORITY)
                 .addClassAndMethod(this);
@@ -101,7 +101,7 @@ public class SynchronizationOnSharedBuiltinConstant extends OpcodeStackDetector
                 }
 
             } else if (badSignatures.contains(syncSignature)) {
-                isSyncOnBoolean = syncSignature.equals("Ljava/lang/Boolean;");
+                isSyncOnBoolean = "Ljava/lang/Boolean;".equals(syncSignature);
                 XField field = top.getXField();
                 FieldSummary fieldSummary = AnalysisContext.currentAnalysisContext().getFieldSummary();
                 OpcodeStack.Item summary = fieldSummary.getSummary(field);
diff --git a/SynchronizeOnClassLiteralNotGetClass.java b/SynchronizeOnClassLiteralNotGetClass.java
index 6fb2b0d15b5b34fe038bc340ee7cf2937107a25b..9c22acfd3f0f96a432f167af501230663f4ebdba 100644
--- a/SynchronizeOnClassLiteralNotGetClass.java
+++ b/SynchronizeOnClassLiteralNotGetClass.java
@@ -106,8 +106,8 @@ public class SynchronizeOnClassLiteralNotGetClass extends OpcodeStackDetector {
             }
             break;
         case 1:
-            if (seen == INVOKEVIRTUAL && getNameConstantOperand().equals("getClass")
-            && getSigConstantOperand().equals("()Ljava/lang/Class;")) {
+            if (seen == INVOKEVIRTUAL && "getClass".equals(getNameConstantOperand())
+            && "()Ljava/lang/Class;".equals(getSigConstantOperand())) {
                 state = 2;
             } else {
                 state = 0;
diff --git a/TestASM.java b/TestASM.java
index 74bac53ec92d0cbc9bd75a6c873a183f603f9a7c..f555b89482863231069f6f4945a5c9edfe9c5273 100644
--- a/TestASM.java
+++ b/TestASM.java
@@ -64,8 +64,8 @@ public class TestASM extends ClassNodeDetector {
 
             @Override
             public void visitMethodInsn(int opcode, String owner, String invokedName, String invokedDesc, boolean itf) {
-                if (prevPC + 1 == getPC() && prevOpcode == I2D && opcode == INVOKESTATIC && owner.equals("java/lang/Math")
-                        && invokedName.equals("ceil") && invokedDesc.equals("(D)D")) {
+                if (prevPC + 1 == getPC() && prevOpcode == I2D && opcode == INVOKESTATIC && "java/lang/Math".equals(owner)
+                        && "ceil".equals(invokedName) && "(D)D".equals(invokedDesc)) {
                     BugInstance bug0 = new BugInstance(TestASM.this, "ICAST_INT_CAST_TO_DOUBLE_PASSED_TO_CEIL", NORMAL_PRIORITY);
                     MethodAnnotation methodAnnotation = MethodAnnotation.fromForeignMethod(TestASM.this.name, name, desc, access);
                     bug0.addClass(TestASM.this).addMethod(methodAnnotation);
diff --git a/TrainLongInstantfParams.java b/TrainLongInstantfParams.java
index e7ab64929364da03af212db0b84b0faf5020e503..d0c9e65b129b932b5206d28c7f8af781a182f212 100644
--- a/TrainLongInstantfParams.java
+++ b/TrainLongInstantfParams.java
@@ -91,13 +91,13 @@ public class TrainLongInstantfParams extends PreorderVisitor implements Detector
             LocalVariable localVariable = t.getLocalVariable(index, 0);
             if (localVariable != null) {
                 String name = localVariable.getName();
-                if (s.equals("J") && (name.toLowerCase().indexOf("instant") >= 0 || name.startsWith("date"))) {
+                if ("J".equals(s) && (name.toLowerCase().indexOf("instant") >= 0 || name.startsWith("date"))) {
 
                     // System.out.println(getFullyQualifiedMethodName() + " " + s + " " + index + " " + name);
                     property.setParamWithProperty(parameterNumber, true);
                 }
             }
-            if (s.equals("J") || s.equals("D")) {
+            if ("J".equals(s) || "D".equals(s)) {
                 index += 2;
             } else {
                 index += 1;
diff --git a/URLProblems.java b/URLProblems.java
index 2e2d698ea5488fe6a5427eab0dcc695d1ba279ca..f75a0adb5be64980663ec7305aaf1a81ed82336a 100644
--- a/URLProblems.java
+++ b/URLProblems.java
@@ -18,8 +18,10 @@
  */
 package edu.umd.cs.findbugs.detect;
 
-import java.util.regex.Pattern;
+import java.util.Arrays;
+import java.util.List;
 
+import org.apache.bcel.classfile.Code;
 import org.apache.bcel.classfile.JavaClass;
 import org.apache.bcel.classfile.Signature;
 
@@ -27,7 +29,9 @@ import edu.umd.cs.findbugs.BugAccumulator;
 import edu.umd.cs.findbugs.BugInstance;
 import edu.umd.cs.findbugs.BugReporter;
 import edu.umd.cs.findbugs.OpcodeStack;
+import edu.umd.cs.findbugs.ba.ClassContext;
 import edu.umd.cs.findbugs.bcel.OpcodeStackDetector;
+import edu.umd.cs.findbugs.classfile.MethodDescriptor;
 
 /**
  * equals and hashCode are blocking methods on URL's. Warn about invoking equals
@@ -35,23 +39,55 @@ import edu.umd.cs.findbugs.bcel.OpcodeStackDetector;
  */
 public class URLProblems extends OpcodeStackDetector {
 
+    private static final MethodDescriptor URL_EQUALS = new MethodDescriptor("java/net/URL", "equals", "(Ljava/lang/Object;)Z");
+    private static final MethodDescriptor URL_HASHCODE = new MethodDescriptor("java/net/URL", "hashCode", "()I");
+
     final static String[] BAD_SIGNATURES = { "Hashtable<Ljava/net/URL", "Map<Ljava/net/URL", "Set<Ljava/net/URL" };
 
+    // Must be sorted
+    private static final String[] HASHSET_KEY_METHODS = {"add", "contains", "remove"};
+    private static final String[] HASHMAP_KEY_METHODS = {"containsKey", "get", "remove"};
+    private static final String[] HASHMAP_TWO_ARG_KEY_METHODS = {"put"};
+
+    private static final List<MethodDescriptor> methods = Arrays.asList(URL_EQUALS, URL_HASHCODE,
+            new MethodDescriptor("", "add", "(Ljava/lang/Object;)Z"),
+            new MethodDescriptor("", "contains", "(Ljava/lang/Object;)Z"),
+            new MethodDescriptor("", "remove", "(Ljava/lang/Object;)Z"),
+            new MethodDescriptor("", "containsKey", "(Ljava/lang/Object;)Z"),
+            new MethodDescriptor("", "get", "(Ljava/lang/Object;)Ljava/lang/Object;"),
+            new MethodDescriptor("", "remove", "(Ljava/lang/Object;)Ljava/lang/Object;"),
+            new MethodDescriptor("", "put", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;"));
+
     final private BugReporter bugReporter;
 
     final private BugAccumulator accumulator;
 
+    private boolean hasInterestingMethodCalls;
+
     public URLProblems(BugReporter bugReporter) {
         this.bugReporter = bugReporter;
         this.accumulator = new BugAccumulator(bugReporter);
     }
 
     @Override
+    public void visitClassContext(ClassContext classContext) {
+        this.hasInterestingMethodCalls = hasInterestingMethod(classContext.getJavaClass().getConstantPool(), methods);
+        super.visitClassContext(classContext);
+    }
+
+    @Override
     public void visitAfter(JavaClass obj) {
         accumulator.reportAccumulatedBugs();
     }
 
     @Override
+    public void visit(Code obj) {
+        if(this.hasInterestingMethodCalls) {
+            super.visit(obj);
+        }
+    }
+
+    @Override
     public void visit(Signature obj) {
         String sig = obj.getSignature();
         for (String s : BAD_SIGNATURES) {
@@ -69,8 +105,8 @@ public class URLProblems extends OpcodeStackDetector {
         }
     }
 
-    void check(String className, Pattern name, int target, int url) {
-        if (!name.matcher(getNameConstantOperand()).matches()) {
+    void check(String className, String[] methodNames, int target, int url) {
+        if (Arrays.binarySearch(methodNames, getNameConstantOperand()) < 0) {
             return;
         }
         if (stack.getStackDepth() <= target) {
@@ -78,7 +114,7 @@ public class URLProblems extends OpcodeStackDetector {
         }
         OpcodeStack.Item targetItem = stack.getStackItem(target);
         OpcodeStack.Item urlItem = stack.getStackItem(url);
-        if (!urlItem.getSignature().equals("Ljava/net/URL;")) {
+        if (!"Ljava/net/URL;".equals(urlItem.getSignature())) {
             return;
         }
         if (!targetItem.getSignature().equals(className)) {
@@ -91,21 +127,17 @@ public class URLProblems extends OpcodeStackDetector {
     @Override
     public void sawOpcode(int seen) {
 
-        // System.out.println(getPC() + " " + OPCODE_NAMES[seen] + " " + stack);
         if (seen == INVOKEVIRTUAL || seen == INVOKEINTERFACE) {
-            check("Ljava/util/HashSet;", Pattern.compile("add|remove|contains"), 1, 0);
-            check("Ljava/util/HashMap;", Pattern.compile("remove|containsKey|get"), 1, 0);
-            check("Ljava/util/HashMap;", Pattern.compile("put"), 2, 1);
-
+            check("Ljava/util/HashSet;", HASHSET_KEY_METHODS, 1, 0);
+            check("Ljava/util/HashMap;", HASHMAP_KEY_METHODS, 1, 0);
+            check("Ljava/util/HashMap;", HASHMAP_TWO_ARG_KEY_METHODS, 2, 1);
         }
 
-        if (seen == INVOKEVIRTUAL && getClassConstantOperand().equals("java/net/URL")) {
-            if (getNameConstantOperand().equals("equals") && getSigConstantOperand().equals("(Ljava/lang/Object;)Z")
-                    || getNameConstantOperand().equals("hashCode") && getSigConstantOperand().equals("()I")) {
-                accumulator.accumulateBug(
-                        new BugInstance(this, "DMI_BLOCKING_METHODS_ON_URL", HIGH_PRIORITY).addClassAndMethod(this)
-                        .addCalledMethod(this), this);
-            }
+        if (seen == INVOKEVIRTUAL && (getMethodDescriptorOperand().equals(URL_EQUALS)
+                || getMethodDescriptorOperand().equals(URL_HASHCODE))) {
+            accumulator.accumulateBug(
+                    new BugInstance(this, "DMI_BLOCKING_METHODS_ON_URL", HIGH_PRIORITY).addClassAndMethod(this)
+                    .addCalledMethod(this), this);
         }
     }
 }
diff --git a/UncallableMethodOfAnonymousClass.java b/UncallableMethodOfAnonymousClass.java
index e2417621f274412076aec90929e999b25e41d71b..19a6047314039ecd29c6a7ee3877773ba609137c 100644
--- a/UncallableMethodOfAnonymousClass.java
+++ b/UncallableMethodOfAnonymousClass.java
@@ -65,7 +65,7 @@ public class UncallableMethodOfAnonymousClass extends BytecodeScanningDetector {
         }
 
         String superclassName2 = getSuperclassName();
-        boolean weird = superclassName2.equals("java.lang.Object") && obj.getInterfaceIndices().length == 0;
+        boolean weird = "java.lang.Object".equals(superclassName2) && obj.getInterfaceIndices().length == 0;
         boolean hasAnonymousName = ClassName.isAnonymous(obj.getClassName());
         boolean isAnonymousInnerClass = hasAnonymousName && !weird;
         if (isAnonymousInnerClass) {
@@ -157,13 +157,13 @@ public class UncallableMethodOfAnonymousClass extends BytecodeScanningDetector {
 
         String methodName = obj.getName();
         String sig = obj.getSignature();
-        if (methodName.equals("<init>")) {
+        if ("<init>".equals(methodName)) {
             return true;
         }
-        if (methodName.equals("<clinit>")) {
+        if ("<clinit>".equals(methodName)) {
             return true;
         }
-        if (sig.equals("()Ljava/lang/Object;") && (methodName.equals("readResolve") || methodName.equals("writeReplace"))) {
+        if ("()Ljava/lang/Object;".equals(sig) && ("readResolve".equals(methodName) || "writeReplace".equals(methodName))) {
             return true;
         }
         if (methodName.startsWith("access$")) {
@@ -191,7 +191,7 @@ public class UncallableMethodOfAnonymousClass extends BytecodeScanningDetector {
                 String role = ClassAnnotation.SUPERCLASS_ROLE;
 
                 @DottedClassName String superclassName =  ClassName.toDottedClassName(getSuperclassName());
-                if (superclassName.equals("java.lang.Object")) {
+                if ("java.lang.Object".equals(superclassName)) {
 
                     try {
                         JavaClass interfaces[] = getThisClass().getInterfaces();
@@ -261,7 +261,7 @@ public class UncallableMethodOfAnonymousClass extends BytecodeScanningDetector {
                 int priority = NORMAL_PRIORITY;
                 JavaClass superClass = clazz.getSuperClass();
                 String superClassName = superClass.getClassName();
-                if (superClassName.equals("java.lang.Object")) {
+                if ("java.lang.Object".equals(superClassName)) {
                     priority = NORMAL_PRIORITY;
 
                 } else if (definedInClass(superClass).containsAll(definedInClass(clazz))) {
diff --git a/UnnecessaryMath.java b/UnnecessaryMath.java
index d2a93238b64d91bf647c902db9324fea08f66dc9..2f5bfde119d2175b309b60586a663d6a382340fa 100644
--- a/UnnecessaryMath.java
+++ b/UnnecessaryMath.java
@@ -20,6 +20,7 @@
 
 package edu.umd.cs.findbugs.detect;
 
+import java.util.Collections;
 import java.util.HashSet;
 import java.util.Set;
 
@@ -33,6 +34,7 @@ import edu.umd.cs.findbugs.BugInstance;
 import edu.umd.cs.findbugs.BugReporter;
 import edu.umd.cs.findbugs.BytecodeScanningDetector;
 import edu.umd.cs.findbugs.StatelessDetector;
+import edu.umd.cs.findbugs.ba.ClassContext;
 
 /**
  * Find occurrences of Math using constants, where the result of the calculation
@@ -109,10 +111,17 @@ public class UnnecessaryMath extends BytecodeScanningDetector implements Statele
     }
 
     @Override
+    public void visitClassContext(ClassContext classContext) {
+        if(hasInterestingClass(classContext.getJavaClass().getConstantPool(), Collections.singleton("java/lang/Math"))) {
+            super.visitClassContext(classContext);
+        }
+    }
+
+    @Override
     public void visit(Code obj) {
         // Don't complain about unnecessary math calls in class initializers,
         // since they may be there to improve readability.
-        if (getMethod().getName().equals("<clinit>")) {
+        if ("<clinit>".equals(getMethod().getName())) {
             return;
         }
 
@@ -142,7 +151,7 @@ public class UnnecessaryMath extends BytecodeScanningDetector implements Statele
         } else if (state == SEEN_DCONST) {
             if (seen == INVOKESTATIC) {
                 state = SEEN_NOTHING;
-                if (getDottedClassConstantOperand().equals("java.lang.Math")) {
+                if ("java.lang.Math".equals(getDottedClassConstantOperand())) {
                     String methodName = getNameConstantOperand();
 
                     if (((constValue == 0.0) && zeroMethods.contains(methodName))
diff --git a/UnreadFields.java b/UnreadFields.java
index 70dd131ab637e8c53c4b089efdd67bc7c6959fca..5deb99a528b09b2864f7263a26a8806612002892 100644
--- a/UnreadFields.java
+++ b/UnreadFields.java
@@ -206,9 +206,9 @@ public class UnreadFields extends OpcodeStackDetector {
         // Does this class directly implement Serializable?
         String[] interface_names = obj.getInterfaceNames();
         for (String interface_name : interface_names) {
-            if (interface_name.equals("java.io.Externalizable")) {
+            if ("java.io.Externalizable".equals(interface_name)) {
                 isSerializable = true;
-            } else if (interface_name.equals("java.io.Serializable")) {
+            } else if ("java.io.Serializable".equals(interface_name)) {
                 isSerializable = true;
                 break;
             }
@@ -267,10 +267,10 @@ public class UnreadFields extends OpcodeStackDetector {
         XField f = XFactory.createXField(this);
         data.allMyFields.add(f);
         String signature = obj.getSignature();
-        if (!getFieldName().equals("serialVersionUID")) {
+        if (!"serialVersionUID".equals(getFieldName())) {
 
             data.myFields.add(f);
-            if (obj.getName().equals("_jspx_dependants")) {
+            if ("_jspx_dependants".equals(obj.getName())) {
                 data.containerFields.add(f);
             }
         }
@@ -280,8 +280,8 @@ public class UnreadFields extends OpcodeStackDetector {
     }
 
     public static boolean isSeleniumWebElement(String signature) {
-        return signature.equals("Lorg/openqa/selenium/RenderedWebElement;")
-                || signature.equals("Lorg/openqa/selenium/WebElement;");
+        return "Lorg/openqa/selenium/RenderedWebElement;".equals(signature)
+                || "Lorg/openqa/selenium/WebElement;".equals(signature);
     }
 
     @Override
@@ -301,17 +301,17 @@ public class UnreadFields extends OpcodeStackDetector {
     public static boolean isInjectionAttribute(@DottedClassName String annotationClass) {
         if (annotationClass.startsWith("javax.annotation.")
                 || annotationClass.startsWith("javax.ejb")
-                || annotationClass.equals("org.apache.tapestry5.annotations.Persist")
-                || annotationClass.equals("org.jboss.seam.annotations.In")
+                || "org.apache.tapestry5.annotations.Persist".equals(annotationClass)
+                || "org.jboss.seam.annotations.In".equals(annotationClass)
                 || annotationClass.startsWith("javax.persistence")
                 || annotationClass.endsWith("SpringBean")
-                || annotationClass.equals("com.google.inject.Inject")
+                || "com.google.inject.Inject".equals(annotationClass)
                 || annotationClass.startsWith("com.google.") && annotationClass.endsWith(".Bind")
                 && annotationClass.hashCode() == -243168318
                 || annotationClass.startsWith("org.nuxeo.common.xmap.annotation")
                 || annotationClass.startsWith("com.google.gwt.uibinder.client")
                 || annotationClass.startsWith("org.springframework.beans.factory.annotation")
-                || annotationClass.equals("javax.ws.rs.core.Context")) {
+                || "javax.ws.rs.core.Context".equals(annotationClass)) {
             return true;
         }
         int lastDot = annotationClass.lastIndexOf('.');
@@ -328,6 +328,7 @@ public class UnreadFields extends OpcodeStackDetector {
         // set during visitation of the Field are still valid here
         XField f = XFactory.createXField(this);
         data.constantFields.add(f);
+        data.writtenFields.add(f);
     }
 
     int count_aload_1;
@@ -347,7 +348,7 @@ public class UnreadFields extends OpcodeStackDetector {
         seenMonitorEnter = getMethod().isSynchronized();
         data.staticFieldsReadInThisMethod.clear();
         super.visit(obj);
-        if (getMethodName().equals("<init>") && count_aload_1 > 1
+        if ("<init>".equals(getMethodName()) && count_aload_1 > 1
                 && (getClassName().indexOf('$') >= 0 || getClassName().indexOf('+') >= 0)) {
             data.needsOuterObjectInConstructor.add(getDottedClassName());
             // System.out.println(betterClassName +
@@ -361,7 +362,7 @@ public class UnreadFields extends OpcodeStackDetector {
         if (DEBUG) {
             System.out.println("Checking " + getClassName() + "." + obj.getName());
         }
-        if (getMethodName().equals("<init>") && (obj.isPublic() || obj.isProtected())) {
+        if ("<init>".equals(getMethodName()) && (obj.isPublic() || obj.isProtected())) {
             publicOrProtectedConstructor = true;
         }
         pendingGetField = null;
@@ -435,8 +436,8 @@ public class UnreadFields extends OpcodeStackDetector {
             saState = 0;
         }
 
-        if (seen == INVOKESTATIC && getClassConstantOperand().equals("java/util/concurrent/atomic/AtomicReferenceFieldUpdater")
-                && getNameConstantOperand().equals("newUpdater")) {
+        if (seen == INVOKESTATIC && "java/util/concurrent/atomic/AtomicReferenceFieldUpdater".equals(getClassConstantOperand())
+                && "newUpdater".equals(getNameConstantOperand())) {
             String fieldName = (String) stack.getStackItem(0).getConstant();
             String fieldSignature = (String) stack.getStackItem(1).getConstant();
             String fieldClass = (String) stack.getStackItem(2).getConstant();
@@ -447,8 +448,8 @@ public class UnreadFields extends OpcodeStackDetector {
             }
 
         }
-        if (seen == INVOKESTATIC && getClassConstantOperand().equals("java/util/concurrent/atomic/AtomicIntegerFieldUpdater")
-                && getNameConstantOperand().equals("newUpdater")) {
+        if (seen == INVOKESTATIC && "java/util/concurrent/atomic/AtomicIntegerFieldUpdater".equals(getClassConstantOperand())
+                && "newUpdater".equals(getNameConstantOperand())) {
             String fieldName = (String) stack.getStackItem(0).getConstant();
             String fieldClass = (String) stack.getStackItem(1).getConstant();
             if (fieldName != null && fieldClass != null) {
@@ -457,8 +458,8 @@ public class UnreadFields extends OpcodeStackDetector {
             }
 
         }
-        if (seen == INVOKESTATIC && getClassConstantOperand().equals("java/util/concurrent/atomic/AtomicLongFieldUpdater")
-                && getNameConstantOperand().equals("newUpdater")) {
+        if (seen == INVOKESTATIC && "java/util/concurrent/atomic/AtomicLongFieldUpdater".equals(getClassConstantOperand())
+                && "newUpdater".equals(getNameConstantOperand())) {
             String fieldName = (String) stack.getStackItem(0).getConstant();
             String fieldClass = (String) stack.getStackItem(1).getConstant();
             if (fieldName != null && fieldClass != null) {
@@ -533,14 +534,14 @@ public class UnreadFields extends OpcodeStackDetector {
 
                 // Decrease priority for boolean fields used to control
                 // debug/test settings
-                if (f.getName().indexOf("DEBUG") >= 0 || f.getName().indexOf("VERBOSE") >= 0 && f.getSignature().equals("Z")) {
+                if (f.getName().indexOf("DEBUG") >= 0 || f.getName().indexOf("VERBOSE") >= 0 && "Z".equals(f.getSignature())) {
                     priority++;
                     priority++;
                 }
                 // Eclipse bundles which implements start/stop *very* often
                 // assigns static instances there
-                if ((getMethodName().equals("start") || getMethodName().equals("stop"))
-                        && getMethodSig().equals("(Lorg/osgi/framework/BundleContext;)V")) {
+                if (("start".equals(getMethodName()) || "stop".equals(getMethodName()))
+                        && "(Lorg/osgi/framework/BundleContext;)V".equals(getMethodSig())) {
                     try {
                         JavaClass bundleClass = Repository.lookupClass("org.osgi.framework.BundleActivator");
                         if (getThisClass().instanceOf(bundleClass)) {
@@ -575,7 +576,7 @@ public class UnreadFields extends OpcodeStackDetector {
             String sig = getSigConstantOperand();
             String invokedClassName = getClassConstantOperand();
             if (invokedClassName.equals(getClassName())
-                    && (getMethodName().equals("<init>") || getMethodName().equals("<clinit>"))) {
+                    && ("<init>".equals(getMethodName()) || "<clinit>".equals(getMethodName()))) {
 
                 data.calledFromConstructors.add(getNameConstantOperand() + ":" + sig);
             }
@@ -589,7 +590,7 @@ public class UnreadFields extends OpcodeStackDetector {
                 }
 
                 boolean selfCall = item.getRegisterNumber() == 0 && !superCall;
-                if (selfCall && getMethodName().equals("<init>")) {
+                if (selfCall && "<init>".equals(getMethodName())) {
                     sawSelfCallInConstructor = true;
                     if (DEBUG) {
                         System.out.println("Saw self call in " + getFullyQualifiedMethodName() + " to " + invokedClassName + "."
@@ -675,7 +676,7 @@ public class UnreadFields extends OpcodeStackDetector {
                         }
 
                     } catch (CheckedAnalysisException e) {
-                        AnalysisContext.logError("foo", e);
+                        AnalysisContext.logError("INV dataflow error when analyzing "+getMethodDescriptor(), e);
                     }
                     if (DEBUG) {
                         System.out.println("RRR: " + f + " " + data.nullTested.contains(f) + " "
@@ -702,7 +703,7 @@ public class UnreadFields extends OpcodeStackDetector {
         } else if (seen == GETFIELD || seen == GETSTATIC) {
             XField f = XFactory.createReferencedXField(this);
             pendingGetField = f;
-            if (getMethodName().equals("readResolve") && seen == GETFIELD) {
+            if ("readResolve".equals(getMethodName()) && seen == GETFIELD) {
                 data.writtenFields.add(f);
                 data.writtenNonNullFields.add(f);
             }
@@ -740,15 +741,15 @@ public class UnreadFields extends OpcodeStackDetector {
                 data.fieldAccess.put(f, SourceLineAnnotation.fromVisitedInstruction(this));
             }
 
-            boolean isConstructor = getMethodName().equals("<init>") || getMethodName().equals("<clinit>");
+            boolean isConstructor = "<init>".equals(getMethodName()) || "<clinit>".equals(getMethodName());
             if (getMethod().isStatic() == f.isStatic()
                     && (isConstructor || data.calledFromConstructors.contains(getMethodName() + ":" + getMethodSig())
-                            || getMethodName().equals("init") || getMethodName().equals("init")
-                            || getMethodName().equals("initialize") || getMethod().isPrivate())) {
+                            || "init".equals(getMethodName()) || "init".equals(getMethodName())
+                            || "initialize".equals(getMethodName()) || getMethod().isPrivate())) {
 
                 if (isConstructor) {
                     data.writtenInConstructorFields.add(f);
-                    if (f.getSignature().equals("Ljava/lang/ThreadLocal;") && item != null && item.isNewlyAllocated()) {
+                    if ("Ljava/lang/ThreadLocal;".equals(f.getSignature()) && item != null && item.isNewlyAllocated()) {
                         data.threadLocalAssignedInConstructor.put(f, new ProgramPoint(this));
                     }
                 } else {
@@ -1080,7 +1081,7 @@ public class UnreadFields extends OpcodeStackDetector {
                     for (XField of : outerXClass.getXFields()) {
                         if (!of.isStatic()) {
                             String sourceSignature = of.getSourceSignature();
-                            if (sourceSignature != null && of.getSignature().equals("Ljava/lang/ThreadLocal;")) {
+                            if (sourceSignature != null && "Ljava/lang/ThreadLocal;".equals(of.getSignature())) {
                                 Type ofType = GenericUtilities.getType(sourceSignature);
                                 if (ofType instanceof GenericObjectType) {
                                     GenericObjectType gType = (GenericObjectType) ofType;
@@ -1108,7 +1109,7 @@ public class UnreadFields extends OpcodeStackDetector {
 
                     boolean outerClassIsInnerClass = false;
                     for (Field field : outerClass.getFields()) {
-                        if (field.getName().equals("this$0")) {
+                        if ("this$0".equals(field.getName())) {
                             outerClassIsInnerClass = true;
                         }
                     }
diff --git a/UselessSubclassMethod.java b/UselessSubclassMethod.java
index a05b6e6109a8195b6445f8e4b017f22f2d36b59b..511c73fb17cab4ca6ab650002ae66f931f3cf6a9 100644
--- a/UselessSubclassMethod.java
+++ b/UselessSubclassMethod.java
@@ -112,7 +112,7 @@ public class UselessSubclassMethod extends BytecodeScanningDetector implements S
         try {
             String methodName = getMethodName();
 
-            if (!methodName.equals("<init>") && !methodName.equals("clone")
+            if (!"<init>".equals(methodName) && !"clone".equals(methodName)
                     && ((getMethod().getAccessFlags() & (Constants.ACC_STATIC | Constants.ACC_SYNTHETIC)) == 0)) {
 
                 /*
@@ -286,7 +286,7 @@ public class UselessSubclassMethod extends BytecodeScanningDetector implements S
             }
         }
 
-        if (!superclassName.equals("Object")) {
+        if (!"Object".equals(superclassName)) {
             @DottedClassName String superSuperClassName = superClass.getSuperclassName();
             if (superSuperClassName.equals(superclassName)) {
                 throw new ClassNotFoundException("superclass of " + superclassName + " is itself");
@@ -324,7 +324,6 @@ public class UselessSubclassMethod extends BytecodeScanningDetector implements S
         if (!thrownExceptions(m1).equals(thrownExceptions(m2))) {
             return false;
         }
-        m1.getExceptionTable();
         return false;
     }
 }
diff --git a/VarArgsProblems.java b/VarArgsProblems.java
index 5db16c9027363e4217ea7c4928829df872df2f37..c6959e9819d4b1ed3e03c8cdcc6ef4f77cc69443 100644
--- a/VarArgsProblems.java
+++ b/VarArgsProblems.java
@@ -138,7 +138,7 @@ public class VarArgsProblems extends BytecodeScanningDetector implements Statele
                         break;
                     }
                     int priority = NORMAL_PRIORITY;
-                    if (getNameConstantOperand().equals("asList") && getClassConstantOperand().equals("java/util/Arrays")) {
+                    if ("asList".equals(getNameConstantOperand()) && "java/util/Arrays".equals(getClassConstantOperand())) {
                         priority = HIGH_PRIORITY;
                     }
                     bugReporter.reportBug(new BugInstance(this, "VA_PRIMITIVE_ARRAY_PASSED_TO_OBJECT_VARARG", priority)
diff --git a/VolatileUsage.java b/VolatileUsage.java
index f37198b81a3868f6a197316ff0d390491c2b6e3c..85bf74d65727da8f9a8bbfb76aba7ffbf9b49797 100644
--- a/VolatileUsage.java
+++ b/VolatileUsage.java
@@ -93,7 +93,7 @@ public class VolatileUsage extends BytecodeScanningDetector {
         case ADD:
             if (seen == PUTFIELD && incrementField.equals(getXFieldOperand())) {
                 bugReporter.reportBug(new BugInstance(this, "VO_VOLATILE_INCREMENT",
-                        incrementField.getSignature().equals("J") ? Priorities.HIGH_PRIORITY : Priorities.NORMAL_PRIORITY)
+                        "J".equals(incrementField.getSignature()) ? Priorities.HIGH_PRIORITY : Priorities.NORMAL_PRIORITY)
                 .addClassAndMethod(this).addField(incrementField).addSourceLine(this));
             }
             resetIncrementState();
@@ -105,7 +105,7 @@ public class VolatileUsage extends BytecodeScanningDetector {
             if (!isVolatileArray(f)) {
                 return;
             }
-            if (getMethodName().equals("<clinit>")) {
+            if ("<clinit>".equals(getMethodName())) {
                 initializationWrites.add(f);
             } else {
                 otherWrites.add(f);
@@ -118,7 +118,7 @@ public class VolatileUsage extends BytecodeScanningDetector {
                 return;
             }
 
-            if (getMethodName().equals("<init>")) {
+            if ("<init>".equals(getMethodName())) {
                 initializationWrites.add(f);
             } else {
                 otherWrites.add(f);
diff --git a/WaitInLoop.java b/WaitInLoop.java
index 9e2b8e78053d6c5529bb654996fa38a7fa013895..3df7d1deef646069fd91ab46fd794c4e1125009d 100644
--- a/WaitInLoop.java
+++ b/WaitInLoop.java
@@ -70,20 +70,20 @@ public class WaitInLoop extends BytecodeScanningDetector implements StatelessDet
     @Override
     public void sawOpcode(int seen) {
 
-        if ((seen == INVOKEVIRTUAL || seen == INVOKEINTERFACE) && getNameConstantOperand().equals("notify")
-                && getSigConstantOperand().equals("()V")) {
+        if ((seen == INVOKEVIRTUAL || seen == INVOKEINTERFACE) && "notify".equals(getNameConstantOperand())
+                && "()V".equals(getSigConstantOperand())) {
             sawNotify = true;
             notifyPC = getPC();
         }
         if (!(sawWait || sawAwait) && (seen == INVOKEVIRTUAL || seen == INVOKEINTERFACE)
                 && (isMonitorWait() || isConditionAwait())) {
 
-            if (getNameConstantOperand().equals("wait")) {
+            if ("wait".equals(getNameConstantOperand())) {
                 sawWait = true;
             } else {
                 sawAwait = true;
             }
-            waitHasTimeout = !getSigConstantOperand().equals("()V");
+            waitHasTimeout = !"()V".equals(getSigConstantOperand());
             waitAt = getPC();
             earliestJump = getPC() + 1;
             return;
@@ -98,7 +98,7 @@ public class WaitInLoop extends BytecodeScanningDetector implements StatelessDet
         String name = getNameConstantOperand();
         String sig = getSigConstantOperand();
 
-        if (!className.equals("java/util/concurrent/locks/Condition")) {
+        if (!"java/util/concurrent/locks/Condition".equals(className)) {
             return false;
         }
 
@@ -106,16 +106,16 @@ public class WaitInLoop extends BytecodeScanningDetector implements StatelessDet
             return false;
         }
 
-        if (name.equals("await") && (sig.equals("()V") || sig.equals("(JLjava/util/concurrent/TimeUnit;)V"))) {
+        if ("await".equals(name) && ("()V".equals(sig) || "(JLjava/util/concurrent/TimeUnit;)V".equals(sig))) {
             return true;
         }
-        if (name.equals("awaitNanos") && sig.equals("(J)V")) {
+        if ("awaitNanos".equals(name) && "(J)V".equals(sig)) {
             return true;
         }
-        if (name.equals("awaitUninterruptibly") && sig.equals("()V")) {
+        if ("awaitUninterruptibly".equals(name) && "()V".equals(sig)) {
             return true;
         }
-        if (name.equals("awaitUntil") && sig.equals("(Ljava/util/Date;)V")) {
+        if ("awaitUntil".equals(name) && "(Ljava/util/Date;)V".equals(sig)) {
             return true;
         }
 
@@ -126,7 +126,7 @@ public class WaitInLoop extends BytecodeScanningDetector implements StatelessDet
         String name = getNameConstantOperand();
         String sig = getSigConstantOperand();
 
-        return name.equals("wait") && (sig.equals("()V") || sig.equals("(J)V") || sig.equals("(JI)V"));
+        return "wait".equals(name) && ("()V".equals(sig) || "(J)V".equals(sig) || "(JI)V".equals(sig));
     }
 
 }
diff --git a/WrongMapIterator.java b/WrongMapIterator.java
index c25a81ef689ce5a19b5e09653fd6c665b7d28197..61027115c318ac0696cea9942fb49f70c4487f65 100644
--- a/WrongMapIterator.java
+++ b/WrongMapIterator.java
@@ -20,6 +20,9 @@
 
 package edu.umd.cs.findbugs.detect;
 
+import java.util.Collections;
+import java.util.Set;
+
 import org.apache.bcel.classfile.Code;
 import org.apache.bcel.classfile.Method;
 
@@ -29,45 +32,89 @@ import edu.umd.cs.findbugs.BugReporter;
 import edu.umd.cs.findbugs.BytecodeScanningDetector;
 import edu.umd.cs.findbugs.MethodAnnotation;
 import edu.umd.cs.findbugs.StatelessDetector;
+import edu.umd.cs.findbugs.ba.ClassContext;
 import edu.umd.cs.findbugs.ba.XClass;
 import edu.umd.cs.findbugs.classfile.CheckedAnalysisException;
 import edu.umd.cs.findbugs.classfile.ClassDescriptor;
+import edu.umd.cs.findbugs.classfile.FieldDescriptor;
 import edu.umd.cs.findbugs.classfile.Global;
+import edu.umd.cs.findbugs.classfile.MethodDescriptor;
 
 public class WrongMapIterator extends BytecodeScanningDetector implements StatelessDetector {
-    private final BugAccumulator bugAccumulator;
-
-    private static final int SAW_NOTHING = 0;
-
-    private static final int SAW_MAP_LOAD1 = 1;
-
-    private static final int SAW_KEYSET = 2;
+    private static final Set<MethodDescriptor> methods = Collections.singleton(new MethodDescriptor("", "keySet", "()Ljava/util/Set;"));
 
-    private static final int SAW_KEYSET_STORE = 3;
+    static enum LoadedVariableState {
+        NOTHING, LOCAL, FIELD
+    }
 
-    private static final int SAW_ITERATOR = 4;
+    final LoadedVariable NONE = new LoadedVariable(LoadedVariableState.NOTHING, 0, null);
 
-    private static final int SAW_ITERATOR_STORE = 5;
+    final class LoadedVariable {
+        private final LoadedVariableState lvState;
+        private final int num;
+        private final FieldDescriptor fd;
 
-    private static final int SAW_ITERATOR_LOAD = 6;
+        private LoadedVariable(LoadedVariableState state, int num, FieldDescriptor fd) {
+            this.lvState = state;
+            this.num = num;
+            this.fd = fd;
+        }
 
-    private static final int SAW_NEXT = 7;
+        public boolean none() {
+            return lvState == LoadedVariableState.NOTHING;
+        }
 
-    private static final int SAW_CHECKCAST_ON_NEXT = 8;
+        public boolean isRegister(int register) {
+            return lvState == LoadedVariableState.LOCAL && num == register;
+        }
 
-    private static final int SAW_KEY_STORE = 9;
+        public LoadedVariable seen(int opcode) {
+            if(isRegisterLoad() && !isRegisterStore()) {
+                return new LoadedVariable(LoadedVariableState.LOCAL, getRegisterOperand(), null);
+            }
+            switch(opcode) {
+            case GETSTATIC:
+                return new LoadedVariable(LoadedVariableState.FIELD, 0, getFieldDescriptorOperand());
+            case GETFIELD:
+                if(lvState == LoadedVariableState.LOCAL && num == 0) {
+                    // Ignore fields from other classes
+                    return new LoadedVariable(LoadedVariableState.FIELD, 0, getFieldDescriptorOperand());
+                }
+                return NONE;
+            default:
+                return NONE;
+            }
+        }
 
-    private static final int NEED_KEYSET_LOAD = 10;
+        public boolean same(LoadedVariable other) {
+            if(other.lvState != lvState) {
+                return false;
+            }
+            if(lvState == LoadedVariableState.LOCAL && num != other.num) {
+                return false;
+            }
+            if ((lvState == LoadedVariableState.FIELD) && !fd.equals(other.fd)) {
+                return false;
+            }
+            return true;
+        }
 
-    private static final int SAW_MAP_LOAD2 = 11;
+        public BugInstance annotate(BugInstance bug) {
+            if(lvState == LoadedVariableState.FIELD) {
+                bug.addField(fd);
+            }
+            return bug;
+        }
+    }
 
-    private static final int SAW_KEY_LOAD = 12;
+    private final BugAccumulator bugAccumulator;
 
-    private int state;
+    private static final int NOT_FOUND = -2;
+    private static final int IN_STACK = -1;
 
-    private int loadedRegister;
+    private LoadedVariable loadedVariable = NONE;
 
-    private int mapRegister;
+    private LoadedVariable mapVariable = NONE;
 
     private int keySetRegister;
 
@@ -75,18 +122,31 @@ public class WrongMapIterator extends BytecodeScanningDetector implements Statel
 
     private int keyRegister;
 
+    private boolean mapAndKeyLoaded;
+
     public WrongMapIterator(BugReporter bugReporter) {
         this.bugAccumulator = new BugAccumulator(bugReporter);
     }
 
     @Override
+    public void visitClassContext(ClassContext classContext) {
+        if(hasInterestingMethod(classContext.getJavaClass().getConstantPool(), methods)) {
+            super.visitClassContext(classContext);
+        }
+    }
+
+    @Override
     public void visit(Method obj) {
-        state = SAW_NOTHING;
-        loadedRegister = -1;
-        mapRegister = -1;
-        keySetRegister = -1;
-        iteratorRegister = -1;
-        keyRegister = -1;
+        reset();
+    }
+
+    private void reset() {
+        loadedVariable = NONE;
+        mapVariable = NONE;
+        mapAndKeyLoaded = false;
+        keySetRegister = NOT_FOUND;
+        iteratorRegister = NOT_FOUND;
+        keyRegister = NOT_FOUND;
     }
 
     @Override
@@ -125,165 +185,96 @@ public class WrongMapIterator extends BytecodeScanningDetector implements Statel
         return false;
     }
 
-    @Override
-    public void sawOpcode(int seen) {
-        switch (state) {
-        case SAW_NOTHING:
-            loadedRegister = getLoadStoreRegister(seen, true);
-            if (loadedRegister >= 0) {
-                state = SAW_MAP_LOAD1;
-            }
-            break;
-
-        case SAW_MAP_LOAD1:
-            // Doesn't check to see if the target object is a Map
-            if (((seen == INVOKEINTERFACE) || (seen == INVOKEVIRTUAL)) && ("keySet".equals(getNameConstantOperand()))
-                    && ("()Ljava/util/Set;".equals(getSigConstantOperand()))
-                    // Following check solves sourceforge bug 1830576
-                    && implementsMap(getClassDescriptorOperand())) {
-                mapRegister = loadedRegister;
-                state = SAW_KEYSET;
-            } else {
-                state = SAW_NOTHING;
-            }
-            break;
-
-        case SAW_KEYSET:
-            keySetRegister = getLoadStoreRegister(seen, false);
-            if (keySetRegister >= 0) {
-                state = SAW_KEYSET_STORE;
-            } else if ((seen == INVOKEINTERFACE) && ("iterator".equals(getNameConstantOperand()))
-                    && ("()Ljava/util/Iterator;".equals(getSigConstantOperand()))) {
-                state = SAW_ITERATOR;
-            } else {
-                state = SAW_NOTHING;
-            }
-            break;
-
-        case SAW_KEYSET_STORE:
-            if ((seen == INVOKEINTERFACE) && ("iterator".equals(getNameConstantOperand()))
-                    && ("()Ljava/util/Iterator;".equals(getSigConstantOperand()))) {
-                state = SAW_ITERATOR;
-            } else {
-                state = NEED_KEYSET_LOAD;
-            }
-            break;
-
-        case NEED_KEYSET_LOAD:
-            loadedRegister = getLoadStoreRegister(seen, true);
-            if (loadedRegister == iteratorRegister) {
-                state = SAW_ITERATOR;
-            }
-            break;
-
-        case SAW_ITERATOR:
-            iteratorRegister = getLoadStoreRegister(seen, false);
-            if (iteratorRegister >= 0) {
-                state = SAW_ITERATOR_STORE;
-            } else {
-                state = SAW_NOTHING;
-            }
-            break;
-
-        case SAW_ITERATOR_STORE:
-            loadedRegister = getLoadStoreRegister(seen, true);
-            if (loadedRegister == iteratorRegister) {
-                state = SAW_ITERATOR_LOAD;
-            }
-            break;
-
-        case SAW_ITERATOR_LOAD:
-            if ((seen == INVOKEINTERFACE) && ("next".equals(getNameConstantOperand()))
-                    && ("()Ljava/lang/Object;".equals(getSigConstantOperand()))) {
-                state = SAW_NEXT;
-            } else {
-                state = SAW_ITERATOR_STORE;
-            }
-            break;
-
-        case SAW_NEXT:
-            if (seen == CHECKCAST) {
-                state = SAW_CHECKCAST_ON_NEXT;
-            } else {
-                keyRegister = getLoadStoreRegister(seen, false);
-                if (keyRegister >= 0) {
-                    state = SAW_KEY_STORE;
-                } else {
-                    state = SAW_NOTHING;
-                }
-            }
-            break;
-
-        case SAW_CHECKCAST_ON_NEXT:
-            keyRegister = getLoadStoreRegister(seen, false);
-            if (keyRegister >= 0) {
-                state = SAW_KEY_STORE;
-            }
-            break;
-
-        case SAW_KEY_STORE:
-            loadedRegister = getLoadStoreRegister(seen, true);
-            if (loadedRegister == mapRegister) {
-                state = SAW_MAP_LOAD2;
-            }
-            break;
-
-        case SAW_MAP_LOAD2:
-            loadedRegister = getLoadStoreRegister(seen, true);
-            if (loadedRegister == keyRegister) {
-                state = SAW_KEY_LOAD;
-            } else {
-                state = SAW_KEY_STORE;
-            }
-            break;
-
-        case SAW_KEY_LOAD:
-            if (((seen == INVOKEINTERFACE) || (seen == INVOKEVIRTUAL)) && ("get".equals(getNameConstantOperand()))
-                    && ("(Ljava/lang/Object;)Ljava/lang/Object;".equals(getSigConstantOperand()))) {
-                MethodAnnotation ma = MethodAnnotation.fromVisitedMethod(this);
-                bugAccumulator.accumulateBug(new BugInstance(this, "WMI_WRONG_MAP_ITERATOR", NORMAL_PRIORITY).addClass(this)
-                        .addMethod(ma), this);
-                state = SAW_NOTHING;
-            }
-            break;
-        default:
-            break;
+    private int handleStore(int storeRegister, int current) {
+        if(storeRegister == current) {
+            return NOT_FOUND;
         }
+        if(current == IN_STACK) {
+            return storeRegister;
+        }
+        return current;
     }
 
-    private int getLoadStoreRegister(int seen, boolean doLoad) {
-        switch (seen) {
-        case ALOAD_0:
-        case ALOAD_1:
-        case ALOAD_2:
-        case ALOAD_3:
-            if (doLoad) {
-                return seen - ALOAD_0;
-            }
-            break;
+    private void handleStore(int register) {
+        keySetRegister = handleStore(register, keySetRegister);
+        iteratorRegister = handleStore(register, iteratorRegister);
+        keyRegister = handleStore(register, keyRegister);
+    }
 
-        case ALOAD:
-            if (doLoad) {
-                return getRegisterOperand();
-            }
-            break;
-
-        case ASTORE_0:
-        case ASTORE_1:
-        case ASTORE_2:
-        case ASTORE_3:
-            if (!doLoad) {
-                return seen - ASTORE_0;
-            }
-            break;
+    private void removedFromStack(boolean includeKey) {
+        if(keySetRegister == IN_STACK) {
+            keySetRegister = NOT_FOUND;
+        }
+        if(iteratorRegister == IN_STACK) {
+            iteratorRegister = NOT_FOUND;
+        }
+        if(keyRegister == IN_STACK && includeKey) {
+            keyRegister = NOT_FOUND;
+        }
+    }
 
-        case ASTORE:
-            if (!doLoad) {
-                return getRegisterOperand();
+    @Override
+    public void sawOpcode(int seen) {
+        boolean loadedPreserved = false;
+        if(isRegisterStore() && !isRegisterLoad()) {
+            handleStore(getRegisterOperand());
+        } else {
+            switch (seen) {
+            case INVOKEINTERFACE:
+            case INVOKEVIRTUAL:
+                if (!loadedVariable.none() &&
+                        "keySet".equals(getNameConstantOperand()) && "()Ljava/util/Set;".equals(getSigConstantOperand())
+                        // Following check solves sourceforge bug 1830576
+                        && implementsMap(getClassDescriptorOperand())) {
+                    mapVariable = loadedVariable;
+                    removedFromStack(true);
+                    keySetRegister = IN_STACK;
+                } else if ((keySetRegister == IN_STACK || loadedVariable.isRegister(keySetRegister))
+                        && "iterator".equals(getNameConstantOperand()) && "()Ljava/util/Iterator;".equals(getSigConstantOperand())) {
+                    removedFromStack(true);
+                    iteratorRegister = IN_STACK;
+                } else if ((iteratorRegister == IN_STACK || loadedVariable.isRegister(iteratorRegister))
+                        && "next".equals(getNameConstantOperand())
+                        && "()Ljava/lang/Object;".equals(getSigConstantOperand())) {
+                    removedFromStack(true);
+                    keyRegister = IN_STACK;
+                } else if (mapAndKeyLoaded && "get".equals(getNameConstantOperand())
+                        && "(Ljava/lang/Object;)Ljava/lang/Object;".equals(getSigConstantOperand())) {
+                    MethodAnnotation ma = MethodAnnotation.fromVisitedMethod(this);
+                    bugAccumulator.accumulateBug(mapVariable
+                            .annotate(new BugInstance(this, "WMI_WRONG_MAP_ITERATOR", NORMAL_PRIORITY).addClass(this).addMethod(ma)),
+                            this);
+                    reset();
+                } else if(("intValue".equals(getNameConstantOperand()) && "java/lang/Integer".equals(getClassConstantOperand())) ||
+                        ("longValue".equals(getNameConstantOperand()) && "java/lang/Long".equals(getClassConstantOperand())) ||
+                        ("doubleValue".equals(getNameConstantOperand()) && "java/lang/Double".equals(getClassConstantOperand())) ||
+                        ("floatValue".equals(getNameConstantOperand()) && "java/lang/Float".equals(getClassConstantOperand()))) {
+                    removedFromStack(false);
+                } else {
+                    removedFromStack(true);
+                }
+                break;
+            case INVOKESTATIC:
+                if ("valueOf".equals(getNameConstantOperand())
+                        && ("java/lang/Integer".equals(getClassConstantOperand())
+                                || "java/lang/Long".equals(getClassConstantOperand())
+                                || "java/lang/Double".equals(getClassConstantOperand()) || "java/lang/Float"
+                                .equals(getClassConstantOperand()))) {
+                    loadedPreserved = true;
+                }
+                removedFromStack(true);
+                break;
+            case CHECKCAST:
+                removedFromStack(false);
+                break;
+            default:
+                removedFromStack(true);
             }
-            break;
         }
-
-        return -1;
+        if(!loadedPreserved) {
+            boolean mapLoaded = !loadedVariable.none() && loadedVariable.same(mapVariable);
+            loadedVariable = loadedVariable.seen(seen);
+            mapAndKeyLoaded = mapLoaded && loadedVariable.isRegister(keyRegister);
+        }
     }
 }
diff --git a/XMLFactoryBypass.java b/XMLFactoryBypass.java
index a02907d9fa79157d8918f51bf805ae5232c793f5..7d443c71621a43d0f419164b320c399334d1fc68 100644
--- a/XMLFactoryBypass.java
+++ b/XMLFactoryBypass.java
@@ -84,7 +84,7 @@ public class XMLFactoryBypass extends BytecodeScanningDetector {
                     return;
                 }
 
-                if (!getNameConstantOperand().equals("<init>")) {
+                if (!"<init>".equals(getNameConstantOperand())) {
                     return;
                 }
 
